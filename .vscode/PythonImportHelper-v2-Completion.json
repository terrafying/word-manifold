[
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "pformat",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "jmespath",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "jmespath",
        "description": "jmespath",
        "detail": "jmespath",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "jmespath",
        "description": "jmespath",
        "isExtraImport": true,
        "detail": "jmespath",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "euclidean_distances",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "cosine_distances",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "euclidean_distances",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "cosine_similarity",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "euclidean_distances",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "cosine_distances",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "cosine_similarity",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "DistanceType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "DistanceType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "DistanceType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "Cell",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "Cell",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "Cell",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "Cell",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "OCCULT_TERMS",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "OCCULT_TERMS",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "EmbeddingMode",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModel",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModel",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModel",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "CLIPProcessor",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "CLIPModel",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModel",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModelForSequenceClassification",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "pipeline",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModel",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModelForCausalLM",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "spacy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "spacy",
        "description": "spacy",
        "detail": "spacy",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "spacy.tokens",
        "description": "spacy.tokens",
        "isExtraImport": true,
        "detail": "spacy.tokens",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "spacy.tokens",
        "description": "spacy.tokens",
        "isExtraImport": true,
        "detail": "spacy.tokens",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings",
        "description": "word_manifold.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings",
        "description": "word_manifold.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings",
        "description": "word_manifold.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings",
        "description": "word_manifold.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "RitualWorking",
        "importPath": "word_manifold.examples.ritual_evolution",
        "description": "word_manifold.examples.ritual_evolution",
        "isExtraImport": true,
        "detail": "word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "RitualWorking",
        "importPath": "word_manifold.examples.ritual_evolution",
        "description": "word_manifold.examples.ritual_evolution",
        "isExtraImport": true,
        "detail": "word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "CellularRule",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleParameterSet",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleSequence",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "HermeticPrinciple",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "ElementalForce",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "VibrationDirection",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_sequences",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "CellularRule",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleParameterSet",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleSequence",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "HermeticPrinciple",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "ElementalForce",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "VibrationDirection",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "CellularRule",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleSequence",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "matplotlib.animation",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FFMpegWriter",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FFMpegWriter",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "PillowWriter",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FFMpegWriter",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "imageio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "imageio",
        "description": "imageio",
        "detail": "imageio",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFilter",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageEnhance",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageOps",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "PyPDF2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "nltk",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nltk",
        "description": "nltk",
        "detail": "nltk",
        "documentation": {}
    },
    {
        "label": "word_tokenize",
        "importPath": "nltk.tokenize",
        "description": "nltk.tokenize",
        "isExtraImport": true,
        "detail": "nltk.tokenize",
        "documentation": {}
    },
    {
        "label": "sent_tokenize",
        "importPath": "nltk.tokenize",
        "description": "nltk.tokenize",
        "isExtraImport": true,
        "detail": "nltk.tokenize",
        "documentation": {}
    },
    {
        "label": "word_tokenize",
        "importPath": "nltk.tokenize",
        "description": "nltk.tokenize",
        "isExtraImport": true,
        "detail": "nltk.tokenize",
        "documentation": {}
    },
    {
        "label": "sent_tokenize",
        "importPath": "nltk.tokenize",
        "description": "nltk.tokenize",
        "isExtraImport": true,
        "detail": "nltk.tokenize",
        "documentation": {}
    },
    {
        "label": "stopwords",
        "importPath": "nltk.corpus",
        "description": "nltk.corpus",
        "isExtraImport": true,
        "detail": "nltk.corpus",
        "documentation": {}
    },
    {
        "label": "stopwords",
        "importPath": "nltk.corpus",
        "description": "nltk.corpus",
        "isExtraImport": true,
        "detail": "nltk.corpus",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "cached_property",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "SystemState",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "SystemState",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold",
        "description": "word_manifold.manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold",
        "description": "word_manifold.manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "ConvexHull",
        "importPath": "scipy.spatial",
        "description": "scipy.spatial",
        "isExtraImport": true,
        "detail": "scipy.spatial",
        "documentation": {}
    },
    {
        "label": "ConvexHull",
        "importPath": "scipy.spatial",
        "description": "scipy.spatial",
        "isExtraImport": true,
        "detail": "scipy.spatial",
        "documentation": {}
    },
    {
        "label": "splprep",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "splev",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "Rbf",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "splprep",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "splev",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "DBSCAN",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "TSNE",
        "importPath": "sklearn.manifold",
        "description": "sklearn.manifold",
        "isExtraImport": true,
        "detail": "sklearn.manifold",
        "documentation": {}
    },
    {
        "label": "umap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "umap",
        "description": "umap",
        "detail": "umap",
        "documentation": {}
    },
    {
        "label": "librosa",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "librosa",
        "description": "librosa",
        "detail": "librosa",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "torch.nn.functional",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "click",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "click",
        "description": "click",
        "detail": "click",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "hypertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hypertools",
        "description": "hypertools",
        "detail": "hypertools",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "matplotlib.colors",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "LinearSegmentedColormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "Colormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "LinearSegmentedColormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "cdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "cosine",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "euclidean",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "pdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "plotly.graph_objects",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.graph_objects",
        "description": "plotly.graph_objects",
        "detail": "plotly.graph_objects",
        "documentation": {}
    },
    {
        "label": "Dash",
        "importPath": "dash",
        "description": "dash",
        "isExtraImport": true,
        "detail": "dash",
        "documentation": {}
    },
    {
        "label": "html",
        "importPath": "dash",
        "description": "dash",
        "isExtraImport": true,
        "detail": "dash",
        "documentation": {}
    },
    {
        "label": "dcc",
        "importPath": "dash",
        "description": "dash",
        "isExtraImport": true,
        "detail": "dash",
        "documentation": {}
    },
    {
        "label": "Input",
        "importPath": "dash",
        "description": "dash",
        "isExtraImport": true,
        "detail": "dash",
        "documentation": {}
    },
    {
        "label": "Output",
        "importPath": "dash",
        "description": "dash",
        "isExtraImport": true,
        "detail": "dash",
        "documentation": {}
    },
    {
        "label": "State",
        "importPath": "dash",
        "description": "dash",
        "isExtraImport": true,
        "detail": "dash",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "MinMaxScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_from_directory",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Blueprint",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_file",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_file",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "colorsys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "colorsys",
        "description": "colorsys",
        "detail": "colorsys",
        "documentation": {}
    },
    {
        "label": "gaussian_filter1d",
        "importPath": "scipy.ndimage",
        "description": "scipy.ndimage",
        "isExtraImport": true,
        "detail": "scipy.ndimage",
        "documentation": {}
    },
    {
        "label": "gaussian_filter1d",
        "importPath": "scipy.ndimage",
        "description": "scipy.ndimage",
        "isExtraImport": true,
        "detail": "scipy.ndimage",
        "documentation": {}
    },
    {
        "label": "LineCollection",
        "importPath": "matplotlib.collections",
        "description": "matplotlib.collections",
        "isExtraImport": true,
        "detail": "matplotlib.collections",
        "documentation": {}
    },
    {
        "label": "LineCollection",
        "importPath": "matplotlib.collections",
        "description": "matplotlib.collections",
        "isExtraImport": true,
        "detail": "matplotlib.collections",
        "documentation": {}
    },
    {
        "label": "PathPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Circle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "PathPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "PathPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "PathPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "matplotlib.path",
        "description": "matplotlib.path",
        "isExtraImport": true,
        "detail": "matplotlib.path",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "matplotlib.path",
        "description": "matplotlib.path",
        "isExtraImport": true,
        "detail": "matplotlib.path",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "matplotlib.path",
        "description": "matplotlib.path",
        "isExtraImport": true,
        "detail": "matplotlib.path",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "matplotlib.path",
        "description": "matplotlib.path",
        "isExtraImport": true,
        "detail": "matplotlib.path",
        "documentation": {}
    },
    {
        "label": "ScalarMappable",
        "importPath": "matplotlib.cm",
        "description": "matplotlib.cm",
        "isExtraImport": true,
        "detail": "matplotlib.cm",
        "documentation": {}
    },
    {
        "label": "make_subplots",
        "importPath": "plotly.subplots",
        "description": "plotly.subplots",
        "isExtraImport": true,
        "detail": "plotly.subplots",
        "documentation": {}
    },
    {
        "label": "make_subplots",
        "importPath": "plotly.subplots",
        "description": "plotly.subplots",
        "isExtraImport": true,
        "detail": "plotly.subplots",
        "documentation": {}
    },
    {
        "label": "make_subplots",
        "importPath": "plotly.subplots",
        "description": "plotly.subplots",
        "isExtraImport": true,
        "detail": "plotly.subplots",
        "documentation": {}
    },
    {
        "label": "networkx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "networkx",
        "description": "networkx",
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "scipy.signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "NullFormatter",
        "importPath": "matplotlib.ticker",
        "description": "matplotlib.ticker",
        "isExtraImport": true,
        "detail": "matplotlib.ticker",
        "documentation": {}
    },
    {
        "label": "manifold",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "datasets",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "RecursiveReducer",
        "importPath": "word_manifold.manifold.reduction",
        "description": "word_manifold.manifold.reduction",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.reduction",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "ipywidgets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ipywidgets",
        "description": "ipywidgets",
        "detail": "ipywidgets",
        "documentation": {}
    },
    {
        "label": "display",
        "importPath": "IPython.display",
        "description": "IPython.display",
        "isExtraImport": true,
        "detail": "IPython.display",
        "documentation": {}
    },
    {
        "label": "clear_output",
        "importPath": "IPython.display",
        "description": "IPython.display",
        "isExtraImport": true,
        "detail": "IPython.display",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "PlotlyEngine",
        "importPath": "word_manifold.visualization.engines.plotly_engine",
        "description": "word_manifold.visualization.engines.plotly_engine",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.plotly_engine",
        "documentation": {}
    },
    {
        "label": "InteractiveRenderer",
        "importPath": "word_manifold.visualization.renderers.interactive",
        "description": "word_manifold.visualization.renderers.interactive",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.renderers.interactive",
        "documentation": {}
    },
    {
        "label": "InteractiveRenderer",
        "importPath": "word_manifold.visualization.renderers.interactive",
        "description": "word_manifold.visualization.renderers.interactive",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.renderers.interactive",
        "documentation": {}
    },
    {
        "label": "InteractiveRenderer",
        "importPath": "word_manifold.visualization.renderers.interactive",
        "description": "word_manifold.visualization.renderers.interactive",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.renderers.interactive",
        "documentation": {}
    },
    {
        "label": "ShapeVisualizer",
        "importPath": "word_manifold.visualization.shape_visualizer",
        "description": "word_manifold.visualization.shape_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "ExportConfig",
        "importPath": "word_manifold.visualization.shape_visualizer",
        "description": "word_manifold.visualization.shape_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "ShapeVisualizer",
        "importPath": "word_manifold.visualization.shape_visualizer",
        "description": "word_manifold.visualization.shape_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "ExportConfig",
        "importPath": "word_manifold.visualization.shape_visualizer",
        "description": "word_manifold.visualization.shape_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "ShapeVisualizer",
        "importPath": "word_manifold.visualization.shape_visualizer",
        "description": "word_manifold.visualization.shape_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "ShapeEngine",
        "importPath": "word_manifold.visualization.engines.shape_engine",
        "description": "word_manifold.visualization.engines.shape_engine",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.shape_engine",
        "documentation": {}
    },
    {
        "label": "ShapeRenderer",
        "importPath": "word_manifold.visualization.renderers.shape_renderer",
        "description": "word_manifold.visualization.renderers.shape_renderer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.renderers.shape_renderer",
        "documentation": {}
    },
    {
        "label": "SymbolicVisualizer",
        "importPath": "word_manifold.visualization.symbolic_visualizer",
        "description": "word_manifold.visualization.symbolic_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.symbolic_visualizer",
        "documentation": {}
    },
    {
        "label": "SymbolicPattern",
        "importPath": "word_manifold.visualization.symbolic_visualizer",
        "description": "word_manifold.visualization.symbolic_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.symbolic_visualizer",
        "documentation": {}
    },
    {
        "label": "SymbolicVisualizer",
        "importPath": "word_manifold.visualization.symbolic_visualizer",
        "description": "word_manifold.visualization.symbolic_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.symbolic_visualizer",
        "documentation": {}
    },
    {
        "label": "ASCIIEngine",
        "importPath": "word_manifold.visualization.engines.ascii_engine",
        "description": "word_manifold.visualization.engines.ascii_engine",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.ascii_engine",
        "documentation": {}
    },
    {
        "label": "ASCIIRenderer",
        "importPath": "word_manifold.visualization.renderers.ascii_renderer",
        "description": "word_manifold.visualization.renderers.ascii_renderer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.renderers.ascii_renderer",
        "documentation": {}
    },
    {
        "label": "ASCIIEngine",
        "importPath": "word_manifold.visualization.engines.ascii",
        "description": "word_manifold.visualization.engines.ascii",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.ascii",
        "documentation": {}
    },
    {
        "label": "ASCIIEngine",
        "importPath": "word_manifold.visualization.engines.ascii",
        "description": "word_manifold.visualization.engines.ascii",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.ascii",
        "documentation": {}
    },
    {
        "label": "ASCIIEngine",
        "importPath": "word_manifold.visualization.engines.ascii",
        "description": "word_manifold.visualization.engines.ascii",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.ascii",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "importPath": "word_manifold.visualization.engines.ascii",
        "description": "word_manifold.visualization.engines.ascii",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.ascii",
        "documentation": {}
    },
    {
        "label": "ASCIIRenderer",
        "importPath": "word_manifold.visualization.renderers.ascii",
        "description": "word_manifold.visualization.renderers.ascii",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.renderers.ascii",
        "documentation": {}
    },
    {
        "label": "ASCIIRenderer",
        "importPath": "word_manifold.visualization.renderers.ascii",
        "description": "word_manifold.visualization.renderers.ascii",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.renderers.ascii",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "SemanticTreeVisualizer",
        "importPath": "word_manifold.visualization.semantic_tree_visualizer",
        "description": "word_manifold.visualization.semantic_tree_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "SemanticNode",
        "importPath": "word_manifold.visualization.semantic_tree_visualizer",
        "description": "word_manifold.visualization.semantic_tree_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "SemanticTreeVisualizer",
        "importPath": "word_manifold.visualization.semantic_tree_visualizer",
        "description": "word_manifold.visualization.semantic_tree_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "PhraseEmbedder",
        "importPath": "word_manifold.embeddings.phrase_embeddings",
        "description": "word_manifold.embeddings.phrase_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "soundfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "soundfile",
        "description": "soundfile",
        "detail": "soundfile",
        "documentation": {}
    },
    {
        "label": "ray",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ray",
        "description": "ray",
        "detail": "ray",
        "documentation": {}
    },
    {
        "label": "serve",
        "importPath": "ray",
        "description": "ray",
        "isExtraImport": true,
        "detail": "ray",
        "documentation": {}
    },
    {
        "label": "air",
        "importPath": "ray",
        "description": "ray",
        "isExtraImport": true,
        "detail": "ray",
        "documentation": {}
    },
    {
        "label": "tune",
        "importPath": "ray",
        "description": "ray",
        "isExtraImport": true,
        "detail": "ray",
        "documentation": {}
    },
    {
        "label": "serve",
        "importPath": "ray",
        "description": "ray",
        "isExtraImport": true,
        "detail": "ray",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "ResonantMandalaEngine",
        "importPath": "word_manifold.visualization.engines.resonant_mandala",
        "description": "word_manifold.visualization.engines.resonant_mandala",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.resonant_mandala",
        "documentation": {}
    },
    {
        "label": "ResonanceConfig",
        "importPath": "word_manifold.visualization.engines.resonant_mandala",
        "description": "word_manifold.visualization.engines.resonant_mandala",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.resonant_mandala",
        "documentation": {}
    },
    {
        "label": "ResonanceField",
        "importPath": "word_manifold.visualization.engines.resonant_mandala",
        "description": "word_manifold.visualization.engines.resonant_mandala",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.resonant_mandala",
        "documentation": {}
    },
    {
        "label": "MandalaConfig",
        "importPath": "word_manifold.visualization.engines.resonant_mandala",
        "description": "word_manifold.visualization.engines.resonant_mandala",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.resonant_mandala",
        "documentation": {}
    },
    {
        "label": "MandalaStyle",
        "importPath": "word_manifold.visualization.engines.resonant_mandala",
        "description": "word_manifold.visualization.engines.resonant_mandala",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.resonant_mandala",
        "documentation": {}
    },
    {
        "label": "create_resonance_network",
        "importPath": "word_manifold.discovery.resonance_network",
        "description": "word_manifold.discovery.resonance_network",
        "isExtraImport": true,
        "detail": "word_manifold.discovery.resonance_network",
        "documentation": {}
    },
    {
        "label": "CollectiveState",
        "importPath": "word_manifold.discovery.resonance_network",
        "description": "word_manifold.discovery.resonance_network",
        "isExtraImport": true,
        "detail": "word_manifold.discovery.resonance_network",
        "documentation": {}
    },
    {
        "label": "wavfile",
        "importPath": "scipy.io",
        "description": "scipy.io",
        "isExtraImport": true,
        "detail": "scipy.io",
        "documentation": {}
    },
    {
        "label": "wavfile",
        "importPath": "scipy.io",
        "description": "scipy.io",
        "isExtraImport": true,
        "detail": "scipy.io",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "AudioParams",
        "importPath": "word_manifold.core.audio",
        "description": "word_manifold.core.audio",
        "isExtraImport": true,
        "detail": "word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "generate_sacred_audio",
        "importPath": "word_manifold.core.audio",
        "description": "word_manifold.core.audio",
        "isExtraImport": true,
        "detail": "word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "get_audio_features",
        "importPath": "word_manifold.core.audio",
        "description": "word_manifold.core.audio",
        "isExtraImport": true,
        "detail": "word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "WaveShape",
        "importPath": "word_manifold.core.audio",
        "description": "word_manifold.core.audio",
        "isExtraImport": true,
        "detail": "word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "ModulationType",
        "importPath": "word_manifold.core.audio",
        "description": "word_manifold.core.audio",
        "isExtraImport": true,
        "detail": "word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "AudioParams",
        "importPath": "word_manifold.core.audio",
        "description": "word_manifold.core.audio",
        "isExtraImport": true,
        "detail": "word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "generate_sacred_audio",
        "importPath": "word_manifold.core.audio",
        "description": "word_manifold.core.audio",
        "isExtraImport": true,
        "detail": "word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "get_audio_features",
        "importPath": "word_manifold.core.audio",
        "description": "word_manifold.core.audio",
        "isExtraImport": true,
        "detail": "word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "save_audio",
        "importPath": "word_manifold.core.audio",
        "description": "word_manifold.core.audio",
        "isExtraImport": true,
        "detail": "word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "WaveShape",
        "importPath": "word_manifold.core.audio",
        "description": "word_manifold.core.audio",
        "isExtraImport": true,
        "detail": "word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "ModulationType",
        "importPath": "word_manifold.core.audio",
        "description": "word_manifold.core.audio",
        "isExtraImport": true,
        "detail": "word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "AudioParams",
        "importPath": "sacred_audio",
        "description": "sacred_audio",
        "isExtraImport": true,
        "detail": "sacred_audio",
        "documentation": {}
    },
    {
        "label": "SacredRatios",
        "importPath": "sacred_audio",
        "description": "sacred_audio",
        "isExtraImport": true,
        "detail": "sacred_audio",
        "documentation": {}
    },
    {
        "label": "SacredFrequencies",
        "importPath": "sacred_audio",
        "description": "sacred_audio",
        "isExtraImport": true,
        "detail": "sacred_audio",
        "documentation": {}
    },
    {
        "label": "WaveShape",
        "importPath": "sacred_audio",
        "description": "sacred_audio",
        "isExtraImport": true,
        "detail": "sacred_audio",
        "documentation": {}
    },
    {
        "label": "generate_vesica_piscis",
        "importPath": "sacred_audio",
        "description": "sacred_audio",
        "isExtraImport": true,
        "detail": "sacred_audio",
        "documentation": {}
    },
    {
        "label": "generate_metatrons_cube",
        "importPath": "sacred_audio",
        "description": "sacred_audio",
        "isExtraImport": true,
        "detail": "sacred_audio",
        "documentation": {}
    },
    {
        "label": "normalize_audio",
        "importPath": "sacred_audio",
        "description": "sacred_audio",
        "isExtraImport": true,
        "detail": "sacred_audio",
        "documentation": {}
    },
    {
        "label": "convert_to_16bit",
        "importPath": "sacred_audio",
        "description": "sacred_audio",
        "isExtraImport": true,
        "detail": "sacred_audio",
        "documentation": {}
    },
    {
        "label": "save_audio_file",
        "importPath": "sacred_audio",
        "description": "sacred_audio",
        "isExtraImport": true,
        "detail": "sacred_audio",
        "documentation": {}
    },
    {
        "label": "ImageRenderer",
        "importPath": "word_manifold.visualization.renderers.image_renderer",
        "description": "word_manifold.visualization.renderers.image_renderer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.renderers.image_renderer",
        "documentation": {}
    },
    {
        "label": "AudioVisualParams",
        "importPath": "sacred_audiovis_complex",
        "description": "sacred_audiovis_complex",
        "isExtraImport": true,
        "detail": "sacred_audiovis_complex",
        "documentation": {}
    },
    {
        "label": "AudioParams",
        "importPath": "sacred_audiovis_complex",
        "description": "sacred_audiovis_complex",
        "isExtraImport": true,
        "detail": "sacred_audiovis_complex",
        "documentation": {}
    },
    {
        "label": "VisualizationParams",
        "importPath": "sacred_audiovis_complex",
        "description": "sacred_audiovis_complex",
        "isExtraImport": true,
        "detail": "sacred_audiovis_complex",
        "documentation": {}
    },
    {
        "label": "generate_complex_pattern",
        "importPath": "sacred_audiovis_complex",
        "description": "sacred_audiovis_complex",
        "isExtraImport": true,
        "detail": "sacred_audiovis_complex",
        "documentation": {}
    },
    {
        "label": "AsyncTaskManager",
        "importPath": "word_manifold.utils.debug",
        "description": "word_manifold.utils.debug",
        "isExtraImport": true,
        "detail": "word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "DebugContext",
        "importPath": "word_manifold.utils.debug",
        "description": "word_manifold.utils.debug",
        "isExtraImport": true,
        "detail": "word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "log_errors",
        "importPath": "word_manifold.utils.debug",
        "description": "word_manifold.utils.debug",
        "isExtraImport": true,
        "detail": "word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "time_it",
        "importPath": "word_manifold.utils.debug",
        "description": "word_manifold.utils.debug",
        "isExtraImport": true,
        "detail": "word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "memory_usage",
        "importPath": "word_manifold.utils.debug",
        "description": "word_manifold.utils.debug",
        "isExtraImport": true,
        "detail": "word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "profile_function",
        "importPath": "word_manifold.utils.debug",
        "description": "word_manifold.utils.debug",
        "isExtraImport": true,
        "detail": "word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "AsyncTaskManager",
        "importPath": "word_manifold.utils.debug",
        "description": "word_manifold.utils.debug",
        "isExtraImport": true,
        "detail": "word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "DebugContext",
        "importPath": "word_manifold.utils.debug",
        "description": "word_manifold.utils.debug",
        "isExtraImport": true,
        "detail": "word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "log_errors",
        "importPath": "word_manifold.utils.debug",
        "description": "word_manifold.utils.debug",
        "isExtraImport": true,
        "detail": "word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "time_it",
        "importPath": "word_manifold.utils.debug",
        "description": "word_manifold.utils.debug",
        "isExtraImport": true,
        "detail": "word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "memory_usage",
        "importPath": "word_manifold.utils.debug",
        "description": "word_manifold.utils.debug",
        "isExtraImport": true,
        "detail": "word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "profile_function",
        "importPath": "word_manifold.utils.debug",
        "description": "word_manifold.utils.debug",
        "isExtraImport": true,
        "detail": "word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Observer",
        "importPath": "watchdog.observers",
        "description": "watchdog.observers",
        "isExtraImport": true,
        "detail": "watchdog.observers",
        "documentation": {}
    },
    {
        "label": "Observer",
        "importPath": "watchdog.observers",
        "description": "watchdog.observers",
        "isExtraImport": true,
        "detail": "watchdog.observers",
        "documentation": {}
    },
    {
        "label": "FileSystemEventHandler",
        "importPath": "watchdog.events",
        "description": "watchdog.events",
        "isExtraImport": true,
        "detail": "watchdog.events",
        "documentation": {}
    },
    {
        "label": "FileSystemEventHandler",
        "importPath": "watchdog.events",
        "description": "watchdog.events",
        "isExtraImport": true,
        "detail": "watchdog.events",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "constr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "EmbeddingRequest",
        "importPath": "word_manifold.api.models.embeddings",
        "description": "word_manifold.api.models.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "EmbeddingResponse",
        "importPath": "word_manifold.api.models.embeddings",
        "description": "word_manifold.api.models.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "BatchEmbeddingRequest",
        "importPath": "word_manifold.api.models.embeddings",
        "description": "word_manifold.api.models.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "BatchEmbeddingResponse",
        "importPath": "word_manifold.api.models.embeddings",
        "description": "word_manifold.api.models.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "SimilarityRequest",
        "importPath": "word_manifold.api.models.embeddings",
        "description": "word_manifold.api.models.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "SimilarityResponse",
        "importPath": "word_manifold.api.models.embeddings",
        "description": "word_manifold.api.models.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "TransformerEmbeddingProvider",
        "importPath": "word_manifold.core.embeddings.transformers",
        "description": "word_manifold.core.embeddings.transformers",
        "isExtraImport": true,
        "detail": "word_manifold.core.embeddings.transformers",
        "documentation": {}
    },
    {
        "label": "InstructEmbeddingProvider",
        "importPath": "word_manifold.core.embeddings.transformers",
        "description": "word_manifold.core.embeddings.transformers",
        "isExtraImport": true,
        "detail": "word_manifold.core.embeddings.transformers",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "urljoin",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "Live",
        "importPath": "rich.live",
        "description": "rich.live",
        "isExtraImport": true,
        "detail": "rich.live",
        "documentation": {}
    },
    {
        "label": "Live",
        "importPath": "rich.live",
        "description": "rich.live",
        "isExtraImport": true,
        "detail": "rich.live",
        "documentation": {}
    },
    {
        "label": "webbrowser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webbrowser",
        "description": "webbrowser",
        "detail": "webbrowser",
        "documentation": {}
    },
    {
        "label": "session",
        "importPath": "ray.air",
        "description": "ray.air",
        "isExtraImport": true,
        "detail": "ray.air",
        "documentation": {}
    },
    {
        "label": "ScalingConfig",
        "importPath": "ray.air.config",
        "description": "ray.air.config",
        "isExtraImport": true,
        "detail": "ray.air.config",
        "documentation": {}
    },
    {
        "label": "TorchTrainer",
        "importPath": "ray.train.torch",
        "description": "ray.train.torch",
        "isExtraImport": true,
        "detail": "ray.train.torch",
        "documentation": {}
    },
    {
        "label": "BaseSettings",
        "importPath": "pydantic_settings",
        "description": "pydantic_settings",
        "isExtraImport": true,
        "detail": "pydantic_settings",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "numpy.typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy.typing",
        "description": "numpy.typing",
        "detail": "numpy.typing",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "Future",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "Zeroconf",
        "importPath": "zeroconf",
        "description": "zeroconf",
        "isExtraImport": true,
        "detail": "zeroconf",
        "documentation": {}
    },
    {
        "label": "ServiceInfo",
        "importPath": "zeroconf",
        "description": "zeroconf",
        "isExtraImport": true,
        "detail": "zeroconf",
        "documentation": {}
    },
    {
        "label": "ServiceBrowser",
        "importPath": "zeroconf",
        "description": "zeroconf",
        "isExtraImport": true,
        "detail": "zeroconf",
        "documentation": {}
    },
    {
        "label": "ServiceStateChange",
        "importPath": "zeroconf",
        "description": "zeroconf",
        "isExtraImport": true,
        "detail": "zeroconf",
        "documentation": {}
    },
    {
        "label": "Zeroconf",
        "importPath": "zeroconf",
        "description": "zeroconf",
        "isExtraImport": true,
        "detail": "zeroconf",
        "documentation": {}
    },
    {
        "label": "ServiceInfo",
        "importPath": "zeroconf",
        "description": "zeroconf",
        "isExtraImport": true,
        "detail": "zeroconf",
        "documentation": {}
    },
    {
        "label": "ServiceBrowser",
        "importPath": "zeroconf",
        "description": "zeroconf",
        "isExtraImport": true,
        "detail": "zeroconf",
        "documentation": {}
    },
    {
        "label": "ServiceStateChange",
        "importPath": "zeroconf",
        "description": "zeroconf",
        "isExtraImport": true,
        "detail": "zeroconf",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "get_ray_manager",
        "importPath": "word_manifold.utils.ray_manager",
        "description": "word_manifold.utils.ray_manager",
        "isExtraImport": true,
        "detail": "word_manifold.utils.ray_manager",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "Empty",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "atexit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "atexit",
        "description": "atexit",
        "detail": "atexit",
        "documentation": {}
    },
    {
        "label": "weakref",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "weakref",
        "description": "weakref",
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "HDBSCAN",
        "importPath": "hdbscan",
        "description": "hdbscan",
        "isExtraImport": true,
        "detail": "hdbscan",
        "documentation": {}
    },
    {
        "label": "spearmanr",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "pearsonr",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "spearmanr",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "metrics",
        "importPath": "ray.util",
        "description": "ray.util",
        "isExtraImport": true,
        "detail": "ray.util",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "numpy.fft",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy.fft",
        "description": "numpy.fft",
        "detail": "numpy.fft",
        "documentation": {}
    },
    {
        "label": "ProjectionEngine",
        "importPath": "word_manifold.visualization.engines.projection",
        "description": "word_manifold.visualization.engines.projection",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.projection",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "import_module",
        "importPath": "importlib",
        "description": "importlib",
        "isExtraImport": true,
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "Figure",
        "importPath": "matplotlib.figure",
        "description": "matplotlib.figure",
        "isExtraImport": true,
        "detail": "matplotlib.figure",
        "documentation": {}
    },
    {
        "label": "Figure",
        "importPath": "matplotlib.figure",
        "description": "matplotlib.figure",
        "isExtraImport": true,
        "detail": "matplotlib.figure",
        "documentation": {}
    },
    {
        "label": "Figure",
        "importPath": "matplotlib.figure",
        "description": "matplotlib.figure",
        "isExtraImport": true,
        "detail": "matplotlib.figure",
        "documentation": {}
    },
    {
        "label": "Figure",
        "importPath": "matplotlib.figure",
        "description": "matplotlib.figure",
        "isExtraImport": true,
        "detail": "matplotlib.figure",
        "documentation": {}
    },
    {
        "label": "Poly3DCollection",
        "importPath": "mpl_toolkits.mplot3d.art3d",
        "description": "mpl_toolkits.mplot3d.art3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d.art3d",
        "documentation": {}
    },
    {
        "label": "Slider",
        "importPath": "matplotlib.widgets",
        "description": "matplotlib.widgets",
        "isExtraImport": true,
        "detail": "matplotlib.widgets",
        "documentation": {}
    },
    {
        "label": "Button",
        "importPath": "matplotlib.widgets",
        "description": "matplotlib.widgets",
        "isExtraImport": true,
        "detail": "matplotlib.widgets",
        "documentation": {}
    },
    {
        "label": "CheckButtons",
        "importPath": "matplotlib.widgets",
        "description": "matplotlib.widgets",
        "isExtraImport": true,
        "detail": "matplotlib.widgets",
        "documentation": {}
    },
    {
        "label": "CORS",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "TimeSeriesEngine",
        "importPath": "word_manifold.visualization.engines.timeseries",
        "description": "word_manifold.visualization.engines.timeseries",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.timeseries",
        "documentation": {}
    },
    {
        "label": "PatternType",
        "importPath": "word_manifold.visualization.engines.timeseries",
        "description": "word_manifold.visualization.engines.timeseries",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.timeseries",
        "documentation": {}
    },
    {
        "label": "TimeSeriesEngine",
        "importPath": "word_manifold.visualization.engines.timeseries",
        "description": "word_manifold.visualization.engines.timeseries",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.engines.timeseries",
        "documentation": {}
    },
    {
        "label": "TimeSeriesRenderer",
        "importPath": "word_manifold.visualization.renderers.timeseries",
        "description": "word_manifold.visualization.renderers.timeseries",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.renderers.timeseries",
        "documentation": {}
    },
    {
        "label": "TimeSeriesRenderer",
        "importPath": "word_manifold.visualization.renderers.timeseries",
        "description": "word_manifold.visualization.renderers.timeseries",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.renderers.timeseries",
        "documentation": {}
    },
    {
        "label": "ServiceRegistry",
        "importPath": "word_manifold.discovery.service_registry",
        "description": "word_manifold.discovery.service_registry",
        "isExtraImport": true,
        "detail": "word_manifold.discovery.service_registry",
        "documentation": {}
    },
    {
        "label": "WorkerPool",
        "importPath": "word_manifold.core.worker_pool",
        "description": "word_manifold.core.worker_pool",
        "isExtraImport": true,
        "detail": "word_manifold.core.worker_pool",
        "documentation": {}
    },
    {
        "label": "MetricsCollector",
        "importPath": "word_manifold.monitoring.metrics",
        "description": "word_manifold.monitoring.metrics",
        "isExtraImport": true,
        "detail": "word_manifold.monitoring.metrics",
        "documentation": {}
    },
    {
        "label": "MetricsExporter",
        "importPath": "word_manifold.monitoring.metrics",
        "description": "word_manifold.monitoring.metrics",
        "isExtraImport": true,
        "detail": "word_manifold.monitoring.metrics",
        "documentation": {}
    },
    {
        "label": "RayCloudManager",
        "importPath": "word_manifold.cloud.ray_cloud",
        "description": "word_manifold.cloud.ray_cloud",
        "isExtraImport": true,
        "detail": "word_manifold.cloud.ray_cloud",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "Mock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "Mock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "Mock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "RitualVisualizer",
        "importPath": "word_manifold.visualization.ritual_visualizer",
        "description": "word_manifold.visualization.ritual_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "RitualPhase",
        "importPath": "word_manifold.visualization.ritual_visualizer",
        "description": "word_manifold.visualization.ritual_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "HermeticPrinciple",
        "importPath": "word_manifold.automata.hermetic_principles",
        "description": "word_manifold.automata.hermetic_principles",
        "isExtraImport": true,
        "detail": "word_manifold.automata.hermetic_principles",
        "documentation": {}
    },
    {
        "label": "Visualizer",
        "importPath": "word_manifold.visualization.base",
        "description": "word_manifold.visualization.base",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "InteractiveVisualizer",
        "importPath": "word_manifold.visualization.base",
        "description": "word_manifold.visualization.base",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "VisualizationData",
        "importPath": "word_manifold.visualization.base",
        "description": "word_manifold.visualization.base",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "ManifoldVisualizer",
        "importPath": "word_manifold.visualization.manifold_vis",
        "description": "word_manifold.visualization.manifold_vis",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.manifold_vis",
        "documentation": {}
    },
    {
        "label": "ManifoldPlotData",
        "importPath": "word_manifold.visualization.manifold_vis",
        "description": "word_manifold.visualization.manifold_vis",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.manifold_vis",
        "documentation": {}
    },
    {
        "label": "InteractiveManifoldVisualizer",
        "importPath": "word_manifold.visualization.interactive",
        "description": "word_manifold.visualization.interactive",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.interactive",
        "documentation": {}
    },
    {
        "label": "create_color_gradient",
        "importPath": "word_manifold.visualization.utils",
        "description": "word_manifold.visualization.utils",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "scale_coordinates",
        "importPath": "word_manifold.visualization.utils",
        "description": "word_manifold.visualization.utils",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "calculate_marker_sizes",
        "importPath": "word_manifold.visualization.utils",
        "description": "word_manifold.visualization.utils",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "create_subplot_grid",
        "importPath": "word_manifold.visualization.utils",
        "description": "word_manifold.visualization.utils",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "BasePredictor",
        "importPath": "cog",
        "description": "cog",
        "isExtraImport": true,
        "detail": "cog",
        "documentation": {}
    },
    {
        "label": "Input",
        "importPath": "cog",
        "description": "cog",
        "isExtraImport": true,
        "detail": "cog",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "cog",
        "description": "cog",
        "isExtraImport": true,
        "detail": "cog",
        "documentation": {}
    },
    {
        "label": "WordManifoldClient",
        "importPath": "word_manifold.api.client",
        "description": "word_manifold.api.client",
        "isExtraImport": true,
        "detail": "word_manifold.api.client",
        "documentation": {}
    },
    {
        "label": "MagicVisualizer",
        "importPath": "word_manifold.visualization.magic_visualizer",
        "description": "word_manifold.visualization.magic_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.magic_visualizer",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.bin.jp",
        "description": ".venv.bin.jp",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('expression')\n    parser.add_argument('-f', '--filename',\n                        help=('The filename containing the input data.  '\n                              'If a filename is not given then data is '\n                              'read from stdin.'))\n    parser.add_argument('--ast', action='store_true',\n                        help=('Pretty print the AST, do not search the data.'))\n    args = parser.parse_args()",
        "detail": ".venv.bin.jp",
        "documentation": {}
    },
    {
        "label": "create_celestial_rules",
        "kind": 2,
        "importPath": "build.lib.word_manifold.automata.additional_rules",
        "description": "build.lib.word_manifold.automata.additional_rules",
        "peekOfCode": "def create_celestial_rules() -> Dict[str, CellularRule]:\n    \"\"\"\n    Create rules based on celestial bodies and higher spiritual archetypes.\n    These rules complement the base rule set by adding transformations\n    related to cosmic forces and stellar/planetary influences.\n    Returns:\n        Dictionary mapping rule names to CellularRule objects\n    \"\"\"\n    rules = {}",
        "detail": "build.lib.word_manifold.automata.additional_rules",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.automata.additional_rules",
        "description": "build.lib.word_manifold.automata.additional_rules",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef create_celestial_rules() -> Dict[str, CellularRule]:\n    \"\"\"\n    Create rules based on celestial bodies and higher spiritual archetypes.\n    These rules complement the base rule set by adding transformations\n    related to cosmic forces and stellar/planetary influences.\n    Returns:\n        Dictionary mapping rule names to CellularRule objects\n    \"\"\"\n    rules = {}",
        "detail": "build.lib.word_manifold.automata.additional_rules",
        "documentation": {}
    },
    {
        "label": "HermeticPrinciple",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "class HermeticPrinciple(Enum):\n    \"\"\"The seven Hermetic principles that govern transformation rules.\"\"\"\n    MENTALISM = auto()         # \"THE ALL is MIND; The Universe is Mental.\"\n    CORRESPONDENCE = auto()    # \"As above, so below; as below, so above.\"\n    VIBRATION = auto()         # \"Nothing rests; everything moves; everything vibrates.\"\n    POLARITY = auto()          # \"Everything is Dual; everything has poles.\"\n    RHYTHM = auto()            # \"Everything flows, out and in; everything has its tides.\"\n    CAUSE_EFFECT = auto()      # \"Every Cause has its Effect; Every Effect has its Cause.\"\n    GENDER = auto()            # \"Gender is in everything; everything has its Masculine and Feminine.\"\nclass ElementalForce(Enum):",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "ElementalForce",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "class ElementalForce(Enum):\n    \"\"\"The four elemental forces that influence transformation.\"\"\"\n    EARTH = auto()  # Stability, materiality, resistance to change\n    AIR = auto()    # Intellect, communication, adaptability\n    FIRE = auto()   # Energy, transformation, creation/destruction\n    WATER = auto()  # Emotion, intuition, connection\nclass VibrationDirection(Enum):\n    \"\"\"Possible directions of vibrational change in the vector space.\"\"\"\n    ASCENDING = auto()  # Moving towards higher vibration (complexity, abstraction)\n    DESCENDING = auto() # Moving towards lower vibration (simplicity, concreteness)",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "VibrationDirection",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "class VibrationDirection(Enum):\n    \"\"\"Possible directions of vibrational change in the vector space.\"\"\"\n    ASCENDING = auto()  # Moving towards higher vibration (complexity, abstraction)\n    DESCENDING = auto() # Moving towards lower vibration (simplicity, concreteness)\n    EXPANDING = auto()  # Increasing in scope or influence\n    CONTRACTING = auto() # Decreasing in scope or influence\n    HARMONIZING = auto() # Moving towards balance with neighbors\n    POLARIZING = auto()  # Moving away from neighbors, increasing distinction\n@dataclass\nclass RuleParameterSet:",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleParameterSet",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "class RuleParameterSet:\n    \"\"\"Parameters that define how a transformation rule behaves.\"\"\"\n    magnitude: float = 1.0                  # Base strength of transformation\n    principle: HermeticPrinciple = HermeticPrinciple.CORRESPONDENCE\n    elemental_influence: Dict[ElementalForce, float] = None  # Influence of each element\n    numerological_weights: Dict[int, float] = None  # Weights by numerological value\n    cell_type_weights: Dict[CellType, float] = None  # Weights by cell type\n    vibration_direction: VibrationDirection = VibrationDirection.HARMONIZING\n    def __init__(self, magnitude=1.0, principle=None, vibration_direction=None,\n                 numerological_weights=None, elemental_influence=None, cell_type_weights=None):",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "CellularRule",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "class CellularRule:\n    \"\"\"\n    A rule that defines how cells transform in the vector space.\n    Each rule embodies one or more hermetic principles and governs \n    the evolution of the cellular automata system.\n    \"\"\"\n    def __init__(\n        self, \n        name: str, \n        description: str,",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleSequence",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "class RuleSequence:\n    \"\"\"\n    A sequence of cellular automata rules to be applied in a specific order.\n    The sequence can be applied in different ways:\n    - Sequentially (default): Rules are applied in order\n    - Conditionally: Rules are applied based on conditions\n    - With branching: Different paths can be taken based on state\n    The sequence also supports:\n    - Dependencies between rules\n    - Conditions for rule application",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "kind": 2,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "def create_predefined_rules() -> Dict[str, CellularRule]:\n    \"\"\"\n    Create a set of predefined cellular automata rules based on\n    hermetic principles and occult correspondences.\n    Returns:\n        Dictionary mapping rule names to CellularRule objects\n    \"\"\"\n    rules = {}\n    # The Great Work Rule - Based on alchemical transformation\n    great_work_params = RuleParameterSet(",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_sequences",
        "kind": 2,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "def create_predefined_sequences() -> Dict[str, RuleSequence]:\n    \"\"\"\n    Create a set of predefined rule sequences based on\n    magical rituals and occult correspondences.\n    Returns:\n        Dictionary mapping sequence names to RuleSequence objects\n    \"\"\"\n    rules = create_predefined_rules()\n    sequences = {}\n    # The Great Work Sequence - Alchemical transformation from base to divine",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HermeticPrinciple(Enum):\n    \"\"\"The seven Hermetic principles that govern transformation rules.\"\"\"\n    MENTALISM = auto()         # \"THE ALL is MIND; The Universe is Mental.\"\n    CORRESPONDENCE = auto()    # \"As above, so below; as below, so above.\"\n    VIBRATION = auto()         # \"Nothing rests; everything moves; everything vibrates.\"\n    POLARITY = auto()          # \"Everything is Dual; everything has poles.\"\n    RHYTHM = auto()            # \"Everything flows, out and in; everything has its tides.\"\n    CAUSE_EFFECT = auto()      # \"Every Cause has its Effect; Every Effect has its Cause.\"\n    GENDER = auto()            # \"Gender is in everything; everything has its Masculine and Feminine.\"",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.system",
        "description": "build.lib.word_manifold.automata.system",
        "peekOfCode": "class EvolutionPattern(Enum):\n    \"\"\"Patterns of evolution that the automata system can follow.\"\"\"\n    LINEAR = auto()      # Sequential application of rules\n    CYCLIC = auto()      # Repeated application of rules in a cycle\n    SPIRAL = auto()      # Cyclic with increasing intensity\n    CHAOTIC = auto()     # Random selection of rules\n    THELEMIC = auto()    # Rules selected based on True Will principle\n    KABBALISTIC = auto() # Rules follow Tree of Life pattern\n@dataclass\nclass SystemState:",
        "detail": "build.lib.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "SystemState",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.system",
        "description": "build.lib.word_manifold.automata.system",
        "peekOfCode": "class SystemState:\n    \"\"\"State of the automata system at a point in time.\"\"\"\n    generation: int                # Current generation number\n    active_rules: List[str]        # Names of rules currently active\n    manifold_state: Dict[str, Any] # State snapshot of the manifold\n    timestamp: float               # Unix timestamp when state was captured\n    metrics: Dict[str, float]      # Metrics about the system's state\nclass AutomataSystem:\n    \"\"\"\n    A system that orchestrates the application of cellular automata rules",
        "detail": "build.lib.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.system",
        "description": "build.lib.word_manifold.automata.system",
        "peekOfCode": "class AutomataSystem:\n    \"\"\"\n    A system that orchestrates the application of cellular automata rules\n    to a word vector manifold according to hermetic principles.\n    This class manages the evolution of the manifold through generations,\n    applying rules according to specified patterns and tracking the system's\n    state over time.\n    \"\"\"\n    def __init__(\n        self,",
        "detail": "build.lib.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.automata.system",
        "description": "build.lib.word_manifold.automata.system",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass EvolutionPattern(Enum):\n    \"\"\"Patterns of evolution that the automata system can follow.\"\"\"\n    LINEAR = auto()      # Sequential application of rules\n    CYCLIC = auto()      # Repeated application of rules in a cycle\n    SPIRAL = auto()      # Cyclic with increasing intensity\n    CHAOTIC = auto()     # Random selection of rules\n    THELEMIC = auto()    # Rules selected based on True Will principle\n    KABBALISTIC = auto() # Rules follow Tree of Life pattern\n@dataclass",
        "detail": "build.lib.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "PhraseEmbedding",
        "kind": 6,
        "importPath": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "description": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "class PhraseEmbedding:\n    \"\"\"\n    A class representing the embedding of a phrase or sentence,\n    including both its semantic content and structural shape.\n    \"\"\"\n    def __init__(self, text: str, embedding: np.ndarray, shape_params: Dict):\n        self.text = text\n        self.embedding = embedding\n        self.shape_params = shape_params\nclass PhraseEmbedder:",
        "detail": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "PhraseEmbedder",
        "kind": 6,
        "importPath": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "description": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "class PhraseEmbedder:\n    \"\"\"\n    A class for embedding phrases and sentences into a semantic manifold,\n    extracting both meaning and structural patterns.\n    \"\"\"\n    def __init__(\n        self,\n        model_name: str = \"Snowflake/snowflake-arctic-embed-l\",  # Updated to use Arctic-embed\n        use_gpu: bool = True\n    ):",
        "detail": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "description": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n# Create formatters and handlers if they don't exist\nif not logger.handlers:\n    # Create console handler with formatting\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    console_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - [%(levelname)s] - %(message)s'\n    )",
        "detail": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "EMOTION_ANCHORS",
        "kind": 5,
        "importPath": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "description": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "EMOTION_ANCHORS = {\n    'joy': nlp(' '.join(['happy', 'joyful', 'delighted', 'elated'])).vector.mean(axis=0),\n    'sadness': nlp(' '.join(['sad', 'depressed', 'gloomy', 'melancholy'])).vector.mean(axis=0),\n    'anger': nlp(' '.join(['angry', 'furious', 'enraged', 'hostile'])).vector.mean(axis=0),\n    'fear': nlp(' '.join(['afraid', 'scared', 'terrified', 'anxious'])).vector.mean(axis=0),\n    'surprise': nlp(' '.join(['surprised', 'amazed', 'astonished', 'shocked'])).vector.mean(axis=0),\n    'disgust': nlp(' '.join(['disgusted', 'repulsed', 'revolted', 'appalled'])).vector.mean(axis=0),\n    'trust': nlp(' '.join(['trusting', 'confident', 'secure', 'reliable'])).vector.mean(axis=0),\n    'anticipation': nlp(' '.join(['expectant', 'eager', 'excited', 'hopeful'])).vector.mean(axis=0)\n}",
        "detail": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "EMOTION_ANCHORS",
        "kind": 5,
        "importPath": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "description": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "EMOTION_ANCHORS = {\n    emotion: vector / np.linalg.norm(vector)\n    for emotion, vector in EMOTION_ANCHORS.items()\n}\nclass PhraseEmbedding:\n    \"\"\"\n    A class representing the embedding of a phrase or sentence,\n    including both its semantic content and structural shape.\n    \"\"\"\n    def __init__(self, text: str, embedding: np.ndarray, shape_params: Dict):",
        "detail": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "kind": 6,
        "importPath": "build.lib.word_manifold.embeddings.word_embeddings",
        "description": "build.lib.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "class WordEmbeddings:\n    \"\"\"\n    A class to manage word embeddings from various sources.\n    Supports:\n    - spaCy models (e.g., 'en_core_web_sm', 'en_core_web_md', 'en_core_web_lg')\n    - HuggingFace models (e.g., 'bert-base-uncased', 'gpt2', etc.)\n    - Custom embedding spaces\n    \"\"\"\n    def __init__(\n        self,",
        "detail": "build.lib.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.embeddings.word_embeddings",
        "description": "build.lib.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass WordEmbeddings:\n    \"\"\"\n    A class to manage word embeddings from various sources.\n    Supports:\n    - spaCy models (e.g., 'en_core_web_sm', 'en_core_web_md', 'en_core_web_lg')\n    - HuggingFace models (e.g., 'bert-base-uncased', 'gpt2', etc.)\n    - Custom embedding spaces\n    \"\"\"\n    def __init__(",
        "detail": "build.lib.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "ForceFieldDemo",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.force_field_demo",
        "description": "build.lib.word_manifold.examples.force_field_demo",
        "peekOfCode": "class ForceFieldDemo:\n    def __init__(self, n_dimensions=3):\n        \"\"\"Initialize the force field demonstration.\n        Args:\n            n_dimensions (int): Number of dimensions for the semantic space\n        \"\"\"\n        self.n_dimensions = n_dimensions\n        self.embeddings = None\n        self.manifold = None\n        self.visualizer = None",
        "detail": "build.lib.word_manifold.examples.force_field_demo",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "build.lib.word_manifold.examples.force_field_demo",
        "description": "build.lib.word_manifold.examples.force_field_demo",
        "peekOfCode": "def main():\n    \"\"\"Run the force field visualization demo.\"\"\"\n    # Create and run simulation\n    demo = ForceFieldDemo(n_dimensions=3)\n    demo.prepare_components()\n    viz_path = demo.simulate_force_field()\n    logger.info(f\"\"\"\n    Force field visualization complete!\n    This demonstration shows how concepts move through a semantic force field:\n    - Red points are attractors (positive concepts)",
        "detail": "build.lib.word_manifold.examples.force_field_demo",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.force_field_demo",
        "description": "build.lib.word_manifold.examples.force_field_demo",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ForceFieldDemo:\n    def __init__(self, n_dimensions=3):\n        \"\"\"Initialize the force field demonstration.\n        Args:\n            n_dimensions (int): Number of dimensions for the semantic space\n        \"\"\"\n        self.n_dimensions = n_dimensions\n        self.embeddings = None\n        self.manifold = None",
        "detail": "build.lib.word_manifold.examples.force_field_demo",
        "documentation": {}
    },
    {
        "label": "HyperdimensionalRitual",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "description": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "peekOfCode": "class HyperdimensionalRitual:\n    \"\"\"\n    A class demonstrating hyperdimensional visualization of Thelemic rituals.\n    \"\"\"\n    def __init__(\n        self,\n        n_dimensions: int = 5,  # We'll use 5D for richer semantic representation\n        output_dir: str = \"visualizations/hyperdimensional\"\n    ):\n        self.n_dimensions = n_dimensions",
        "detail": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "description": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "peekOfCode": "def main():\n    \"\"\"Run the hyperdimensional ritual visualization example.\"\"\"\n    # Create and prepare the ritual\n    ritual = HyperdimensionalRitual(n_dimensions=5)\n    ritual.prepare_components()\n    # Create visualization\n    viz_path = ritual.visualize_ritual_transformation()\n    logger.info(f\"\"\"\n    Hyperdimensional ritual visualization complete!\n    The visualization shows the evolution of Thelemic concepts through a 5-dimensional",
        "detail": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "description": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HyperdimensionalRitual:\n    \"\"\"\n    A class demonstrating hyperdimensional visualization of Thelemic rituals.\n    \"\"\"\n    def __init__(\n        self,\n        n_dimensions: int = 5,  # We'll use 5D for richer semantic representation\n        output_dir: str = \"visualizations/hyperdimensional\"\n    ):",
        "detail": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "documentation": {}
    },
    {
        "label": "RitualWorking",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.ritual_evolution",
        "description": "build.lib.word_manifold.examples.ritual_evolution",
        "peekOfCode": "class RitualWorking:\n    \"\"\"\n    A class that implements a complete magical working in word vector space.\n    \"\"\"\n    def _create_evolution_animation(self, key_terms):\n        \"\"\"\n        Create an animation of the evolution of machinic desires using fluid visual transformations and emergent patterns.\n        Args:\n            key_terms: List of key terms to highlight in the animation description\n        Returns:",
        "detail": "build.lib.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "memoize",
        "kind": 2,
        "importPath": "build.lib.word_manifold.examples.ritual_evolution",
        "description": "build.lib.word_manifold.examples.ritual_evolution",
        "peekOfCode": "def memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.\n    Results are cached in memory and on disk for persistence between runs.\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # Create a unique key based on function name and arguments\n        key_parts = [func.__name__]\n        # Add class name if it's a method",
        "detail": "build.lib.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "build.lib.word_manifold.examples.ritual_evolution",
        "description": "build.lib.word_manifold.examples.ritual_evolution",
        "peekOfCode": "def main():\n    \"\"\" Demonstrate the ritual evolution process. \"\"\"\n    ritual = RitualWorking(\n        ritual_name=\"True Will Discovery\",\n        ritual_intent=\"To discover and align with one's True Will through semantic transformation\"\n    )\n    # Prepare components\n    ritual.prepare_components()\n    # Perform the ritual\n    ritual.perform_ritual()",
        "detail": "build.lib.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.ritual_evolution",
        "description": "build.lib.word_manifold.examples.ritual_evolution",
        "peekOfCode": "logger = logging.getLogger(\"ritual_evolution\")\n# Directory for saving outputs\nOUTPUT_DIR = Path(\"ritual_outputs\")\nCACHE_DIR = Path(\".ritual_cache\")\n# Create cache directory if it doesn't exist\nCACHE_DIR.mkdir(exist_ok=True)\n# Function cache decorator with key based on function arguments\ndef memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.",
        "detail": "build.lib.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "OUTPUT_DIR",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.ritual_evolution",
        "description": "build.lib.word_manifold.examples.ritual_evolution",
        "peekOfCode": "OUTPUT_DIR = Path(\"ritual_outputs\")\nCACHE_DIR = Path(\".ritual_cache\")\n# Create cache directory if it doesn't exist\nCACHE_DIR.mkdir(exist_ok=True)\n# Function cache decorator with key based on function arguments\ndef memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.\n    Results are cached in memory and on disk for persistence between runs.\n    \"\"\"",
        "detail": "build.lib.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "CACHE_DIR",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.ritual_evolution",
        "description": "build.lib.word_manifold.examples.ritual_evolution",
        "peekOfCode": "CACHE_DIR = Path(\".ritual_cache\")\n# Create cache directory if it doesn't exist\nCACHE_DIR.mkdir(exist_ok=True)\n# Function cache decorator with key based on function arguments\ndef memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.\n    Results are cached in memory and on disk for persistence between runs.\n    \"\"\"\n    @functools.wraps(func)",
        "detail": "build.lib.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "ReadingStep",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.semantic_crystallization",
        "description": "build.lib.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "class ReadingStep:\n    \"\"\"Represents a single step in the reading sequence.\"\"\"\n    card: str  # The card or concept being integrated\n    keywords: List[str]  # Associated keywords/meanings\n    position: str  # Position or aspect in the reading (e.g., \"past\", \"present\", \"future\")\n    influence: float = 1.0  # Relative influence of this step (0-1)\nterms=[\n                # Major Arcana\n                \"fool\", \"magician\", \"priestess\", \"empress\", \"emperor\",\n                \"hierophant\", \"lovers\", \"chariot\", \"strength\", \"hermit\",",
        "detail": "build.lib.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "SemanticCrystallization",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.semantic_crystallization",
        "description": "build.lib.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "class SemanticCrystallization:\n    \"\"\"\n    Visualizes the crystallization of meaning during a reading sequence.\n    This class tracks how semantic space transforms as each new card or concept\n    is integrated, showing the accumulation and crystallization of meaning over time.\n    \"\"\"\n    def __init__(\n        self,\n        n_dimensions: int = 5,\n        output_dir: str = \"visualizations/crystallization\",",
        "detail": "build.lib.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "build.lib.word_manifold.examples.semantic_crystallization",
        "description": "build.lib.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "def main():\n    \"\"\"Run the semantic crystallization example.\"\"\"\n    # Create and prepare crystallization viewer\n    crystal = SemanticCrystallization(n_dimensions=5)\n    crystal.prepare_components()\n    # Example Celtic Cross reading sequence\n    reading_sequence = [\n        # Central cross\n        (\"present\", \"tower\", [\"disruption\", \"awakening\", \"revelation\"]),\n        (\"challenge\", \"death\", [\"transformation\", \"ending\", \"rebirth\"]),",
        "detail": "build.lib.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.semantic_crystallization",
        "description": "build.lib.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass ReadingStep:\n    \"\"\"Represents a single step in the reading sequence.\"\"\"\n    card: str  # The card or concept being integrated\n    keywords: List[str]  # Associated keywords/meanings\n    position: str  # Position or aspect in the reading (e.g., \"past\", \"present\", \"future\")\n    influence: float = 1.0  # Relative influence of this step (0-1)\nterms=[\n                # Major Arcana",
        "detail": "build.lib.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "ThelemaMetrics",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.thelemic_evolution",
        "description": "build.lib.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "class ThelemaMetrics:\n    \"\"\"\n    A class to calculate and track metrics for the Thelemic evolution of a word manifold.\n    Metrics include:\n    - Semantic entropy: Measure of semantic diversity\n    - Numerological alignment: Correspondence between numerological values\n    - Will manifestation: How closely the system follows its \"True Will\"\n    - Transmutation index: Degree of alchemical transformation\n    \"\"\"\n    def __init__(self):",
        "detail": "build.lib.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "BasicVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.thelemic_evolution",
        "description": "build.lib.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "class BasicVisualizer:\n    \"\"\"\n    A basic visualization class for when the full visualizer is not available.\n    This creates simple 2D plots of the manifold's reduced representation.\n    \"\"\"\n    def __init__(self, manifold: VectorManifold, save_path: str):\n        \"\"\"\n        Initialize the basic visualizer.\n        Args:\n            manifold: The vector manifold to visualize",
        "detail": "build.lib.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "run_thelemic_evolution",
        "kind": 2,
        "importPath": "build.lib.word_manifold.examples.thelemic_evolution",
        "description": "build.lib.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "def run_thelemic_evolution(\n    generations: int = 22,  # One for each Major Arcana\n    save_path: str = None,\n    model_name: str = \"bert-base-uncased\",\n    n_cells: int = 22,\n    random_state: int = 93  # Significant in Thelema/Crowley's work\n):\n    \"\"\"\n    Run the Thelemic evolution of the word manifold.\n    Args:",
        "detail": "build.lib.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.thelemic_evolution",
        "description": "build.lib.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Add the project root to the Python path if running as a script\nif __name__ == \"__main__\":\n    project_root = str(Path(__file__).resolve().parents[3])\n    sys.path.insert(0, project_root)\n# Import Word Manifold components\nfrom word_manifold.embeddings.word_embeddings import WordEmbeddings\nfrom word_manifold.manifold.vector_manifold import VectorManifold, CellType\nfrom word_manifold.automata.cellular_rules import create_predefined_rules\nfrom word_manifold.automata.system import AutomataSystem, EvolutionPattern, SystemState",
        "detail": "build.lib.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "ShapePoint",
        "kind": 6,
        "importPath": "build.lib.word_manifold.manifold.semantic_shape",
        "description": "build.lib.word_manifold.manifold.semantic_shape",
        "peekOfCode": "class ShapePoint:\n    \"\"\"A point in the semantic shape with its associated properties.\"\"\"\n    position: np.ndarray\n    intensity: float  # Emotional/semantic intensity\n    direction: np.ndarray  # Flow direction\n    properties: Dict  # Additional shape properties\nclass SemanticShape:\n    \"\"\"\n    A class representing the shape of meaning in semantic space.\n    This captures both the geometric form and the dynamic properties",
        "detail": "build.lib.word_manifold.manifold.semantic_shape",
        "documentation": {}
    },
    {
        "label": "SemanticShape",
        "kind": 6,
        "importPath": "build.lib.word_manifold.manifold.semantic_shape",
        "description": "build.lib.word_manifold.manifold.semantic_shape",
        "peekOfCode": "class SemanticShape:\n    \"\"\"\n    A class representing the shape of meaning in semantic space.\n    This captures both the geometric form and the dynamic properties\n    of a semantic expression (phrase, sentence, or text chunk).\n    \"\"\"\n    def __init__(\n        self,\n        phrase_embedding: PhraseEmbedding,\n        n_control_points: int = 10",
        "detail": "build.lib.word_manifold.manifold.semantic_shape",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.manifold.semantic_shape",
        "description": "build.lib.word_manifold.manifold.semantic_shape",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass ShapePoint:\n    \"\"\"A point in the semantic shape with its associated properties.\"\"\"\n    position: np.ndarray\n    intensity: float  # Emotional/semantic intensity\n    direction: np.ndarray  # Flow direction\n    properties: Dict  # Additional shape properties\nclass SemanticShape:\n    \"\"\"",
        "detail": "build.lib.word_manifold.manifold.semantic_shape",
        "documentation": {}
    },
    {
        "label": "Cell",
        "kind": 6,
        "importPath": "build.lib.word_manifold.manifold.vector_manifold",
        "description": "build.lib.word_manifold.manifold.vector_manifold",
        "peekOfCode": "class Cell:\n    \"\"\"\n    A cell in the manifold representing a region in the vector space.\n    \"\"\"\n    id: int\n    terms: List[str]  # Words that belong to this cell\n    centroid: np.ndarray  # Center point of the cell in embedding space\n    type: CellType  # Type of cell with occult significance\n    numerological_value: int  # Numerological value of the cell\n    boundary_points: Optional[np.ndarray] = None  # Points defining the boundary (if available)",
        "detail": "build.lib.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "ManifoldReducedState",
        "kind": 6,
        "importPath": "build.lib.word_manifold.manifold.vector_manifold",
        "description": "build.lib.word_manifold.manifold.vector_manifold",
        "peekOfCode": "class ManifoldReducedState(NamedTuple):\n    \"\"\"State of the reduced manifold for visualization and cellular operations.\"\"\"\n    points: np.ndarray         # 2D or 3D points\n    labels: List[int]          # Cell labels for each point\n    cell_centroids: np.ndarray # Reduced centroids\n    boundaries: Any            # Boundary representations (e.g., Voronoi)\nclass VectorManifold:\n    \"\"\"\n    A class representing a manifold in vector space for word embeddings.\n    This class handles the geometric relationships between word embeddings,",
        "detail": "build.lib.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "kind": 6,
        "importPath": "build.lib.word_manifold.manifold.vector_manifold",
        "description": "build.lib.word_manifold.manifold.vector_manifold",
        "peekOfCode": "class VectorManifold:\n    \"\"\"\n    A class representing a manifold in vector space for word embeddings.\n    This class handles the geometric relationships between word embeddings,\n    including Voronoi tessellation and neighborhood calculations.\n    \"\"\"\n    def __init__(\n        self,\n        word_embeddings: WordEmbeddings,\n        n_cells: int = 22,  # Default to 22 cells (major arcana)",
        "detail": "build.lib.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.manifold.vector_manifold",
        "description": "build.lib.word_manifold.manifold.vector_manifold",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass Cell:\n    \"\"\"\n    A cell in the manifold representing a region in the vector space.\n    \"\"\"\n    id: int\n    terms: List[str]  # Words that belong to this cell\n    centroid: np.ndarray  # Center point of the cell in embedding space\n    type: CellType  # Type of cell with occult significance",
        "detail": "build.lib.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "AudioFeatures",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.audio_visualizer",
        "description": "build.lib.word_manifold.visualization.audio_visualizer",
        "peekOfCode": "class AudioFeatures:\n    \"\"\"Container for extracted audio features.\"\"\"\n    mfcc: np.ndarray\n    chroma: np.ndarray\n    spectral_contrast: np.ndarray\n    tonnetz: np.ndarray\n    onset_strength: np.ndarray\n    tempogram: np.ndarray\nclass AudioEncoder(nn.Module):\n    \"\"\"Neural network for encoding audio features into semantic space.\"\"\"",
        "detail": "build.lib.word_manifold.visualization.audio_visualizer",
        "documentation": {}
    },
    {
        "label": "AudioEncoder",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.audio_visualizer",
        "description": "build.lib.word_manifold.visualization.audio_visualizer",
        "peekOfCode": "class AudioEncoder(nn.Module):\n    \"\"\"Neural network for encoding audio features into semantic space.\"\"\"\n    def __init__(\n        self,\n        input_dim: int,\n        embedding_dim: int,\n        hidden_dim: int = 256,\n        n_layers: int = 3\n    ):\n        \"\"\"",
        "detail": "build.lib.word_manifold.visualization.audio_visualizer",
        "documentation": {}
    },
    {
        "label": "AudioVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.audio_visualizer",
        "description": "build.lib.word_manifold.visualization.audio_visualizer",
        "peekOfCode": "class AudioVisualizer:\n    \"\"\"Main class for audio visualization in semantic space.\"\"\"\n    def __init__(\n        self,\n        embedding_dim: int,\n        sample_rate: int = 22050,\n        hop_length: int = 512,\n        device: str = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n    ):\n        \"\"\"",
        "detail": "build.lib.word_manifold.visualization.audio_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.audio_visualizer",
        "description": "build.lib.word_manifold.visualization.audio_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass AudioFeatures:\n    \"\"\"Container for extracted audio features.\"\"\"\n    mfcc: np.ndarray\n    chroma: np.ndarray\n    spectral_contrast: np.ndarray\n    tonnetz: np.ndarray\n    onset_strength: np.ndarray\n    tempogram: np.ndarray",
        "detail": "build.lib.word_manifold.visualization.audio_visualizer",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 2,
        "importPath": "build.lib.word_manifold.visualization.cli",
        "description": "build.lib.word_manifold.visualization.cli",
        "peekOfCode": "def cli():\n    \"\"\"Word Manifold Visualization Tools\"\"\"\n    pass\n@cli.command()\n@click.option('--model', default='en_core_web_sm', help='Spacy model to use')\n@click.option('--terms', '-t', multiple=True, help='Terms to visualize')\n@click.option('--terms-file', type=click.Path(exists=True), help='File containing terms (one per line)')\n@click.option('--output-dir', default='visualizations', help='Output directory for visualizations')\n@click.option('--dimensions', default=4, help='Number of dimensions for visualization')\n@click.option('--interactive/--no-interactive', default=True, help='Enable/disable interactive mode')",
        "detail": "build.lib.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "visualize",
        "kind": 2,
        "importPath": "build.lib.word_manifold.visualization.cli",
        "description": "build.lib.word_manifold.visualization.cli",
        "peekOfCode": "def visualize(model: str, terms: List[str], terms_file: Optional[str], output_dir: str,\n             dimensions: int, interactive: bool, auto_rotate: bool, show_trails: bool,\n             show_force_field: bool, color_palette: str, save_format: str):\n    \"\"\"Create an interactive visualization of word vectors.\"\"\"\n    # Load terms from file if provided\n    if terms_file:\n        with open(terms_file) as f:\n            file_terms = [line.strip() for line in f if line.strip()]\n        terms = list(terms) + file_terms\n    if not terms:",
        "detail": "build.lib.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "animate_ritual",
        "kind": 2,
        "importPath": "build.lib.word_manifold.visualization.cli",
        "description": "build.lib.word_manifold.visualization.cli",
        "peekOfCode": "def animate_ritual(model: str, ritual_file: str, output_dir: str,\n                  duration: float, fps: int, add_trails: bool):\n    \"\"\"Create an animated visualization of a ritual sequence.\"\"\"\n    import json\n    # Load ritual sequence\n    with open(ritual_file) as f:\n        ritual_data = json.load(f)\n    # Initialize embeddings and manifold\n    embeddings = WordEmbeddings(model)\n    terms = set()",
        "detail": "build.lib.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "serve",
        "kind": 2,
        "importPath": "build.lib.word_manifold.visualization.cli",
        "description": "build.lib.word_manifold.visualization.cli",
        "peekOfCode": "def serve(host: str, port: int, debug: bool):\n    \"\"\"Start the visualization server.\"\"\"\n    from .server import VisualizationServer\n    server = VisualizationServer()\n    server.run(host=host, port=port, debug=debug)\nif __name__ == '__main__':\n    cli()",
        "detail": "build.lib.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.cli",
        "description": "build.lib.word_manifold.visualization.cli",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@click.group()\ndef cli():\n    \"\"\"Word Manifold Visualization Tools\"\"\"\n    pass\n@cli.command()\n@click.option('--model', default='en_core_web_sm', help='Spacy model to use')\n@click.option('--terms', '-t', multiple=True, help='Terms to visualize')\n@click.option('--terms-file', type=click.Path(exists=True), help='File containing terms (one per line)')\n@click.option('--output-dir', default='visualizations', help='Output directory for visualizations')",
        "detail": "build.lib.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "description": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "class HyperToolsVisualizer:\n    \"\"\"\n    Advanced high-dimensional visualization class using HyperTools.\n    This visualizer provides fluid, interactive visualizations of semantic\n    transformations in high-dimensional spaces, with advanced animation\n    capabilities for ritual evolution processes and 4D+ rotations.\n    \"\"\"\n    def __init__(\n        self,\n        output_dir: str = \"visualizations/hypertools\",",
        "detail": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "is_string_like",
        "kind": 2,
        "importPath": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "description": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "def is_string_like(obj):\n    \"\"\"Check if the object is a string-like object (str or bytes)\"\"\"\n    return isinstance(obj, (str, bytes))\n# Apply the patch to hypertools\ntry:\n    # Get the reduce function from hypertools.tools\n    if hasattr(hyp.tools, 'reduce'):\n        original_reduce = hyp.tools.reduce\n    else:\n        # If reduce isn't directly accessible, try to get it from the module",
        "detail": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "hypertools_path",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "description": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "hypertools_path = Path(__file__).parent.parent.parent.parent / 'hypertools'\nsys.path.insert(0, str(hypertools_path))\nimport hypertools as hyp\nimport warnings\nimport datetime\nfrom typing import List, Dict, Optional, Tuple, Union, Any\nimport logging\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.colors as mcolors\nfrom mpl_toolkits.mplot3d import Axes3D",
        "detail": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "description": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Monkey patch for NumPy 2.0 compatibility\ndef is_string_like(obj):\n    \"\"\"Check if the object is a string-like object (str or bytes)\"\"\"\n    return isinstance(obj, (str, bytes))\n# Apply the patch to hypertools\ntry:\n    # Get the reduce function from hypertools.tools\n    if hasattr(hyp.tools, 'reduce'):\n        original_reduce = hyp.tools.reduce",
        "detail": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "InteractiveVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.interactive_visualizer",
        "description": "build.lib.word_manifold.visualization.interactive_visualizer",
        "peekOfCode": "class InteractiveVisualizer:\n    \"\"\"\n    Interactive visualization class for exploring semantic spaces.\n    This class provides real-time visualization of word embeddings and\n    semantic transformations, with support for:\n    - Dynamic embedding projection\n    - Interactive exploration of semantic neighborhoods\n    - Real-time visualization of transformations\n    - Multiple visualization modes (2D/3D)\n    \"\"\"",
        "detail": "build.lib.word_manifold.visualization.interactive_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.interactive_visualizer",
        "description": "build.lib.word_manifold.visualization.interactive_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass InteractiveVisualizer:\n    \"\"\"\n    Interactive visualization class for exploring semantic spaces.\n    This class provides real-time visualization of word embeddings and\n    semantic transformations, with support for:\n    - Dynamic embedding projection\n    - Interactive exploration of semantic neighborhoods\n    - Real-time visualization of transformations\n    - Multiple visualization modes (2D/3D)",
        "detail": "build.lib.word_manifold.visualization.interactive_visualizer",
        "documentation": {}
    },
    {
        "label": "SemanticNeRF",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.nerf_renderer",
        "description": "build.lib.word_manifold.visualization.nerf_renderer",
        "peekOfCode": "class SemanticNeRF(nn.Module):\n    \"\"\"Neural network for semantic radiance fields.\"\"\"\n    def __init__(\n        self,\n        embedding_dim: int,\n        hidden_dim: int = 256,\n        n_layers: int = 8,\n        activation: nn.Module = nn.ReLU()\n    ):\n        \"\"\"",
        "detail": "build.lib.word_manifold.visualization.nerf_renderer",
        "documentation": {}
    },
    {
        "label": "PositionalEncoding",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.nerf_renderer",
        "description": "build.lib.word_manifold.visualization.nerf_renderer",
        "peekOfCode": "class PositionalEncoding(nn.Module):\n    \"\"\"Positional encoding for continuous input coordinates.\"\"\"\n    def __init__(self, input_dim: int, n_freqs: int = 10):\n        \"\"\"\n        Initialize positional encoding.\n        Args:\n            input_dim: Dimension of input coordinates\n            n_freqs: Number of frequency bands to use\n        \"\"\"\n        super().__init__()",
        "detail": "build.lib.word_manifold.visualization.nerf_renderer",
        "documentation": {}
    },
    {
        "label": "SemanticAttention",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.nerf_renderer",
        "description": "build.lib.word_manifold.visualization.nerf_renderer",
        "peekOfCode": "class SemanticAttention(nn.Module):\n    \"\"\"Attention mechanism for semantic feature refinement.\"\"\"\n    def __init__(self, embedding_dim: int, hidden_dim: int):\n        \"\"\"\n        Initialize semantic attention module.\n        Args:\n            embedding_dim: Dimension of semantic embeddings\n            hidden_dim: Size of hidden layer\n        \"\"\"\n        super().__init__()",
        "detail": "build.lib.word_manifold.visualization.nerf_renderer",
        "documentation": {}
    },
    {
        "label": "NeRFRenderer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.nerf_renderer",
        "description": "build.lib.word_manifold.visualization.nerf_renderer",
        "peekOfCode": "class NeRFRenderer:\n    \"\"\"Main renderer class for semantic NeRF visualization.\"\"\"\n    def __init__(\n        self,\n        embedding_dim: int,\n        device: str = \"cuda\" if torch.cuda.is_available() else \"cpu\",\n        **nerf_kwargs\n    ):\n        \"\"\"\n        Initialize the NeRF renderer.",
        "detail": "build.lib.word_manifold.visualization.nerf_renderer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.nerf_renderer",
        "description": "build.lib.word_manifold.visualization.nerf_renderer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass SemanticNeRF(nn.Module):\n    \"\"\"Neural network for semantic radiance fields.\"\"\"\n    def __init__(\n        self,\n        embedding_dim: int,\n        hidden_dim: int = 256,\n        n_layers: int = 8,\n        activation: nn.Module = nn.ReLU()\n    ):",
        "detail": "build.lib.word_manifold.visualization.nerf_renderer",
        "documentation": {}
    },
    {
        "label": "VisualizationServer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.server",
        "description": "build.lib.word_manifold.visualization.server",
        "peekOfCode": "class VisualizationServer:\n    \"\"\"Server for interactive visualization of word embeddings and semantic analysis.\"\"\"\n    def __init__(\n        self,\n        embeddings: np.ndarray,\n        labels: List[str],\n        host: str = \"localhost\",\n        port: int = 5000,\n        debug: bool = False\n    ):",
        "detail": "build.lib.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.server",
        "description": "build.lib.word_manifold.visualization.server",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass VisualizationServer:\n    \"\"\"Server for interactive visualization of word embeddings and semantic analysis.\"\"\"\n    def __init__(\n        self,\n        embeddings: np.ndarray,\n        labels: List[str],\n        host: str = \"localhost\",\n        port: int = 5000,\n        debug: bool = False",
        "detail": "build.lib.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "ExportConfig",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.shape_visualizer",
        "description": "build.lib.word_manifold.visualization.shape_visualizer",
        "peekOfCode": "class ExportConfig:\n    \"\"\"Configuration for exporting visualizations.\"\"\"\n    def __init__(\n        self,\n        format: str = \"mp4\",\n        dpi: int = 300,\n        fps: int = 60,\n        bitrate: int = 2000,\n        save_frames: bool = True,\n        output_dir: Optional[str] = None",
        "detail": "build.lib.word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "ShapeVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.shape_visualizer",
        "description": "build.lib.word_manifold.visualization.shape_visualizer",
        "peekOfCode": "class ShapeVisualizer:\n    \"\"\"\n    Advanced visualization class for semantic shapes with enhanced visual encoding.\n    \"\"\"\n    def __init__(\n        self,\n        color_scheme: str = \"semantic\",\n        use_textures: bool = True,\n        export_config: Optional[ExportConfig] = None\n    ):",
        "detail": "build.lib.word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.shape_visualizer",
        "description": "build.lib.word_manifold.visualization.shape_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)  # Default to INFO level\n# Create formatters and handlers if they don't exist\nif not logger.handlers:\n    # Create console handler with formatting\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    console_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - [%(levelname)s] - %(message)s'\n    )",
        "detail": "build.lib.word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "Simple3DVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.simple_3d_visualizer",
        "description": "build.lib.word_manifold.visualization.simple_3d_visualizer",
        "peekOfCode": "class Simple3DVisualizer:\n    \"\"\"\n    Basic 3D visualization class as an alternative to HyperTools.\n    This visualizer provides 3D visualizations using matplotlib\n    to avoid compatibility issues with HyperTools and NumPy 2.0.\n    \"\"\"\n    def __init__(\n        self,\n        output_dir: str = \"visualizations/3d\",\n        color_palette: str = \"viridis\",",
        "detail": "build.lib.word_manifold.visualization.simple_3d_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.simple_3d_visualizer",
        "description": "build.lib.word_manifold.visualization.simple_3d_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass Simple3DVisualizer:\n    \"\"\"\n    Basic 3D visualization class as an alternative to HyperTools.\n    This visualizer provides 3D visualizations using matplotlib\n    to avoid compatibility issues with HyperTools and NumPy 2.0.\n    \"\"\"\n    def __init__(\n        self,\n        output_dir: str = \"visualizations/3d\",",
        "detail": "build.lib.word_manifold.visualization.simple_3d_visualizer",
        "documentation": {}
    },
    {
        "label": "ManifoldVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.visualizer",
        "description": "build.lib.word_manifold.visualization.visualizer",
        "peekOfCode": "class ManifoldVisualizer:\n    \"\"\"\n    Advanced visualization class for exploring word manifolds.\n    Features:\n    - Interactive 3D visualization with plotly\n    - Dynamic term relationships\n    - Sonic feedback for term distances\n    - Color encoding of semantic properties\n    - Animated transitions\n    - Multi-scale visualization",
        "detail": "build.lib.word_manifold.visualization.visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.visualizer",
        "description": "build.lib.word_manifold.visualization.visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ManifoldVisualizer:\n    \"\"\"\n    Advanced visualization class for exploring word manifolds.\n    Features:\n    - Interactive 3D visualization with plotly\n    - Dynamic term relationships\n    - Sonic feedback for term distances\n    - Color encoding of semantic properties\n    - Animated transitions",
        "detail": "build.lib.word_manifold.visualization.visualizer",
        "documentation": {}
    },
    {
        "label": "CellType",
        "kind": 6,
        "importPath": "build.lib.word_manifold.types",
        "description": "build.lib.word_manifold.types",
        "peekOfCode": "class CellType(Enum):\n    \"\"\"Types of cells with occult correspondences.\"\"\"\n    ELEMENTAL = auto()   # Corresponds to the four elements\n    PLANETARY = auto()   # Corresponds to planetary influences\n    ZODIACAL = auto()    # Corresponds to zodiac signs\n    TAROT = auto()       # Corresponds to tarot archetypes\n    SEPHIROTIC = auto()  # Corresponds to Kabbalistic sephiroth\n    OTHER = auto()       # Default/unclassified\nclass DistanceType(Enum):\n    \"\"\"Types of distance metrics for cell relationships.\"\"\"",
        "detail": "build.lib.word_manifold.types",
        "documentation": {}
    },
    {
        "label": "DistanceType",
        "kind": 6,
        "importPath": "build.lib.word_manifold.types",
        "description": "build.lib.word_manifold.types",
        "peekOfCode": "class DistanceType(Enum):\n    \"\"\"Types of distance metrics for cell relationships.\"\"\"\n    EUCLIDEAN = auto()      # Standard Euclidean distance\n    COSINE = auto()         # Cosine distance (semantic similarity)\n    NUMEROLOGICAL = auto()  # Distance weighted by numerological values\n    HYBRID = auto()         # Combination of semantic and numerological",
        "detail": "build.lib.word_manifold.types",
        "documentation": {}
    },
    {
        "label": "setup_system",
        "kind": 2,
        "importPath": "examples.automata.evolution_demo",
        "description": "examples.automata.evolution_demo",
        "peekOfCode": "def setup_system():\n    \"\"\"Set up the automata system with initial terms and rules.\"\"\"\n    # Initialize embeddings with occult terms\n    embeddings = WordEmbeddings()\n    terms = {\n        \"thelema\", \"will\", \"love\", \"magick\", \"ritual\",\n        \"knowledge\", \"wisdom\", \"power\", \"light\", \"dark\",\n        \"earth\", \"air\", \"fire\", \"water\", \"spirit\",\n        \"sun\", \"moon\", \"mercury\", \"venus\", \"mars\"\n    }",
        "detail": "examples.automata.evolution_demo",
        "documentation": {}
    },
    {
        "label": "demonstrate_evolution",
        "kind": 2,
        "importPath": "examples.automata.evolution_demo",
        "description": "examples.automata.evolution_demo",
        "peekOfCode": "def demonstrate_evolution(system: AutomataSystem):\n    \"\"\"Demonstrate different evolution patterns.\"\"\"\n    # Individual rule evolution\n    logger.info(\"\\nApplying individual rules:\")\n    for rule_name in [\"great_work\", \"equilibrium\", \"tower\"]:\n        rule = system.rules[rule_name]\n        logger.info(\"Applying rule: %s\" % rule.name)\n        logger.info(\"Description: %s\" % rule.description)\n        rule.apply(system.manifold, system.generation)\n        state = system.manifold.get_manifold_state()",
        "detail": "examples.automata.evolution_demo",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.automata.evolution_demo",
        "description": "examples.automata.evolution_demo",
        "peekOfCode": "def main():\n    # Set up system\n    system = setup_system()\n    logger.info(\"Initialized automata system\")\n    # Demonstrate evolution\n    demonstrate_evolution(system)\n    logger.info(\"\\nEvolution demonstration complete\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "examples.automata.evolution_demo",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.automata.evolution_demo",
        "description": "examples.automata.evolution_demo",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef setup_system():\n    \"\"\"Set up the automata system with initial terms and rules.\"\"\"\n    # Initialize embeddings with occult terms\n    embeddings = WordEmbeddings()\n    terms = {\n        \"thelema\", \"will\", \"love\", \"magick\", \"ritual\",\n        \"knowledge\", \"wisdom\", \"power\", \"light\", \"dark\",\n        \"earth\", \"air\", \"fire\", \"water\", \"spirit\",\n        \"sun\", \"moon\", \"mercury\", \"venus\", \"mars\"",
        "detail": "examples.automata.evolution_demo",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.embeddings.word_embeddings_demo",
        "description": "examples.embeddings.word_embeddings_demo",
        "peekOfCode": "def main():\n    # Initialize embeddings\n    embeddings = WordEmbeddings()\n    logger.info(\"Initialized word embeddings model\")\n    # Load standard occult terms\n    embeddings.load_terms(OCCULT_TERMS)\n    logger.info(f\"Loaded {len(OCCULT_TERMS)} occult terms\")\n    # Demonstrate similarity search\n    query_terms = [\"magic\", \"thelema\", \"ritual\"]\n    k = 5  # Number of similar terms to find",
        "detail": "examples.embeddings.word_embeddings_demo",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.embeddings.word_embeddings_demo",
        "description": "examples.embeddings.word_embeddings_demo",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef main():\n    # Initialize embeddings\n    embeddings = WordEmbeddings()\n    logger.info(\"Initialized word embeddings model\")\n    # Load standard occult terms\n    embeddings.load_terms(OCCULT_TERMS)\n    logger.info(f\"Loaded {len(OCCULT_TERMS)} occult terms\")\n    # Demonstrate similarity search\n    query_terms = [\"magic\", \"thelema\", \"ritual\"]",
        "detail": "examples.embeddings.word_embeddings_demo",
        "documentation": {}
    },
    {
        "label": "n_points",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "n_points = 1000\nX, color = datasets.make_swiss_roll(n_points, random_state=0)\nn_neighbors = 10\nn_components = 2\n# Creating the plot\nfig = plt.figure(figsize=(15, 8))\nfig.suptitle(\"Manifold Learning with %i points, %i neighbors\"\n             % (1000, n_neighbors), fontsize=14)\n# Adding 3d scatter plot\nax = fig.add_subplot(231, projection='3d')",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "n_neighbors",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "n_neighbors = 10\nn_components = 2\n# Creating the plot\nfig = plt.figure(figsize=(15, 8))\nfig.suptitle(\"Manifold Learning with %i points, %i neighbors\"\n             % (1000, n_neighbors), fontsize=14)\n# Adding 3d scatter plot\nax = fig.add_subplot(231, projection='3d')\nax.scatter(X[:, 0], X[:, 1], X[:, 2], c=color, cmap=plt.cm.Spectral)\nax.view_init(4, -72)",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "n_components",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "n_components = 2\n# Creating the plot\nfig = plt.figure(figsize=(15, 8))\nfig.suptitle(\"Manifold Learning with %i points, %i neighbors\"\n             % (1000, n_neighbors), fontsize=14)\n# Adding 3d scatter plot\nax = fig.add_subplot(231, projection='3d')\nax.scatter(X[:, 0], X[:, 1], X[:, 2], c=color, cmap=plt.cm.Spectral)\nax.view_init(4, -72)\n# Making a dictionary 'methods' containing LLE, t-SNE and PCA",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "fig",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "fig = plt.figure(figsize=(15, 8))\nfig.suptitle(\"Manifold Learning with %i points, %i neighbors\"\n             % (1000, n_neighbors), fontsize=14)\n# Adding 3d scatter plot\nax = fig.add_subplot(231, projection='3d')\nax.scatter(X[:, 0], X[:, 1], X[:, 2], c=color, cmap=plt.cm.Spectral)\nax.view_init(4, -72)\n# Making a dictionary 'methods' containing LLE, t-SNE and PCA\nLLE = partial(manifold.LocallyLinearEmbedding,\n              n_neighbors, n_components, eigen_solver='auto')",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "ax",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "ax = fig.add_subplot(231, projection='3d')\nax.scatter(X[:, 0], X[:, 1], X[:, 2], c=color, cmap=plt.cm.Spectral)\nax.view_init(4, -72)\n# Making a dictionary 'methods' containing LLE, t-SNE and PCA\nLLE = partial(manifold.LocallyLinearEmbedding,\n              n_neighbors, n_components, eigen_solver='auto')\nmethods = OrderedDict()\nmethods['LLE'] = LLE(method='standard')\nmethods['t-SNE'] = manifold.TSNE(n_components=n_components, init='pca',\n                                 random_state=0)",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "LLE",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "LLE = partial(manifold.LocallyLinearEmbedding,\n              n_neighbors, n_components, eigen_solver='auto')\nmethods = OrderedDict()\nmethods['LLE'] = LLE(method='standard')\nmethods['t-SNE'] = manifold.TSNE(n_components=n_components, init='pca',\n                                 random_state=0)\nmethods['PCA']=PCA(n_components=2)\n# Plotting the results\nfor i, (label, method) in enumerate(methods.items()):\n    t0 = time()",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "methods",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "methods = OrderedDict()\nmethods['LLE'] = LLE(method='standard')\nmethods['t-SNE'] = manifold.TSNE(n_components=n_components, init='pca',\n                                 random_state=0)\nmethods['PCA']=PCA(n_components=2)\n# Plotting the results\nfor i, (label, method) in enumerate(methods.items()):\n    t0 = time()\n    Y = method.fit_transform(X)\n    t1 = time()",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "methods['LLE']",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "methods['LLE'] = LLE(method='standard')\nmethods['t-SNE'] = manifold.TSNE(n_components=n_components, init='pca',\n                                 random_state=0)\nmethods['PCA']=PCA(n_components=2)\n# Plotting the results\nfor i, (label, method) in enumerate(methods.items()):\n    t0 = time()\n    Y = method.fit_transform(X)\n    t1 = time()\n    print(\"%s: %.2g sec\" % (label, t1 - t0))",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "methods['t-SNE']",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "methods['t-SNE'] = manifold.TSNE(n_components=n_components, init='pca',\n                                 random_state=0)\nmethods['PCA']=PCA(n_components=2)\n# Plotting the results\nfor i, (label, method) in enumerate(methods.items()):\n    t0 = time()\n    Y = method.fit_transform(X)\n    t1 = time()\n    print(\"%s: %.2g sec\" % (label, t1 - t0))\n    ax = fig.add_subplot(2, 3, 2 + i+(i>1))",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "MultimodalVisualizer",
        "kind": 6,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "class MultimodalVisualizer:\n    \"\"\"Class for handling multimodal visualization with text and images.\"\"\"\n    def __init__(self, image_size=128):  # Reduced from 512 to 128 for memory efficiency\n        \"\"\"Initialize the multimodal visualizer with CLIP model.\"\"\"\n        self.image_size = image_size\n        self.device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n        # Load CLIP with memory optimization\n        logger.info(\"Loading CLIP model...\")\n        self.clip_model = CLIPModel.from_pretrained(\n            \"openai/clip-vit-base-patch32\",",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "InteractiveVisualizer",
        "kind": 6,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "class InteractiveVisualizer:\n    \"\"\"Class for handling interactive visualization controls.\"\"\"\n    def __init__(self, manifold, visualizer):\n        self.manifold = manifold\n        self.visualizer = visualizer\n        self.current_level = 0\n        self.fig = None\n        self.animation = None\n        # Create interactive controls\n        self.setup_controls()",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "find_level_data",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def find_level_data(result: Dict[str, Any], target_level: int, current_level: int = 0) -> Optional[Dict[str, Any]]:\n    \"\"\"Find data for a specific level in the recursive reduction results.\"\"\"\n    if current_level == target_level:\n        return result\n    for child in result['children']:\n        found = find_level_data(child, target_level, current_level + 1)\n        if found is not None:\n            return found\n    return None\nclass MultimodalVisualizer:",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "load_embeddings",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def load_embeddings(model_name=\"sentence-transformers/all-MiniLM-L6-v2\"):\n    \"\"\"Load pre-trained embeddings and extract meaningful term clusters.\"\"\"\n    logger.info(f\"Loading model: {model_name}\")\n    # Initialize word embeddings with background processing\n    word_embeddings = WordEmbeddings(model_name=model_name)\n    # Define semantic clusters with rich vocabulary\n    term_clusters = {\n        \"elements\": [\n            \"fire\", \"water\", \"earth\", \"air\", \"aether\", \"void\", \"plasma\",\n            \"crystal\", \"metal\", \"wood\", \"stone\", \"lightning\", \"ice\", \"steam\"",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "plot_coherence_heatmap",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def plot_coherence_heatmap(manifold):\n    \"\"\"Plot coherence heatmap across reduction levels.\"\"\"\n    def extract_coherence(result, depth=0, coherence_matrix=None, max_depth=None):\n        if coherence_matrix is None:\n            # Find max depth first\n            def get_max_depth(r, d=0):\n                if not r['children']:\n                    return d\n                return max(get_max_depth(child, d+1) for child in r['children'])\n            max_depth = get_max_depth(result)",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "plot_term_clusters",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def plot_term_clusters(manifold, level=0, show_labels=True):\n    \"\"\"Create a 3D scatter plot colored by semantic clusters.\"\"\"\n    if not hasattr(manifold, 'recursive_reduced'):\n        raise ValueError(\"Must run recursive_reduce() first\")\n    # Get the points for the specified level\n    level_data = find_level_data(manifold.recursive_reduced, level)\n    if level_data is None:\n        raise ValueError(f\"Level {level} not found\")\n    points = level_data['points']\n    # Create category mapping",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "plot_multimodal_clusters",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def plot_multimodal_clusters(manifold, level=0, visualizer: Optional[MultimodalVisualizer] = None, show_labels=True):\n    \"\"\"Create a multimodal visualization combining semantic and visual embeddings.\"\"\"\n    if not hasattr(manifold, 'recursive_reduced'):\n        raise ValueError(\"Must run recursive_reduce() first\")\n    # Get level data\n    level_data = find_level_data(manifold.recursive_reduced, level)\n    if level_data is None:\n        raise ValueError(f\"Level {level} not found\")\n    points = level_data['points']\n    # Group terms by category",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "create_source_cube",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def create_source_cube(manifold: VectorManifold, n_terms: int = 8) -> Dict[str, Any]:\n    \"\"\"\n    Create a semantic source cube visualization.\n    Args:\n        manifold: The VectorManifold instance\n        n_terms: Number of terms to place at cube vertices (default 8)\n    Returns:\n        Dictionary containing cube visualization data\n    \"\"\"\n    # Get the most semantically diverse terms",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "plot_source_cube",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def plot_source_cube(cube_data: Dict[str, Any], ax: Optional[plt.Axes] = None) -> plt.Axes:\n    \"\"\"\n    Plot the semantic source cube.\n    Args:\n        cube_data: Cube visualization data from create_source_cube\n        ax: Optional matplotlib axes to plot on\n    Returns:\n        The matplotlib axes object\n    \"\"\"\n    if ax is None:",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def main():\n    # Load pre-trained embeddings\n    embeddings = load_embeddings()\n    # Create manifold with reduced dimensionality for visualization\n    manifold = VectorManifold(\n        embeddings=embeddings,\n        n_cells=22,  # Default to 22 cells (major arcana)\n        random_state=93,\n        reduction_dims=3,  # Use 3D for better visualization\n        use_fractals=True,",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef find_level_data(result: Dict[str, Any], target_level: int, current_level: int = 0) -> Optional[Dict[str, Any]]:\n    \"\"\"Find data for a specific level in the recursive reduction results.\"\"\"\n    if current_level == target_level:\n        return result\n    for child in result['children']:\n        found = find_level_data(child, target_level, current_level + 1)\n        if found is not None:\n            return found\n    return None",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "AdvancedVisualization",
        "kind": 6,
        "importPath": "examples.visualization.advanced_hypertools_example",
        "description": "examples.visualization.advanced_hypertools_example",
        "peekOfCode": "class AdvancedVisualization:\n    \"\"\"Advanced visualization capabilities with interactive features.\"\"\"\n    def __init__(self, output_dir: str = \"visualizations/advanced\"):\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        # Initialize components\n        self.embeddings = WordEmbeddings()\n        self.manifold = VectorManifold(self.embeddings)\n        self.visualizer = HyperToolsVisualizer(\n            word_embeddings=self.embeddings,",
        "detail": "examples.visualization.advanced_hypertools_example",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.visualization.advanced_hypertools_example",
        "description": "examples.visualization.advanced_hypertools_example",
        "peekOfCode": "def main():\n    \"\"\"Run advanced visualization examples.\"\"\"\n    try:\n        # Initialize visualization\n        viz = AdvancedVisualization()\n        # Example 1: Ritual Evolution Animation\n        terms = [\n            \"light\", \"darkness\", \"wisdom\", \"understanding\",\n            \"beauty\", \"strength\", \"mercy\", \"severity\",\n            \"foundation\", \"kingdom\", \"crown\", \"spirit\"",
        "detail": "examples.visualization.advanced_hypertools_example",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.visualization.advanced_hypertools_example",
        "description": "examples.visualization.advanced_hypertools_example",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass AdvancedVisualization:\n    \"\"\"Advanced visualization capabilities with interactive features.\"\"\"\n    def __init__(self, output_dir: str = \"visualizations/advanced\"):\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        # Initialize components\n        self.embeddings = WordEmbeddings()\n        self.manifold = VectorManifold(self.embeddings)\n        self.visualizer = HyperToolsVisualizer(",
        "detail": "examples.visualization.advanced_hypertools_example",
        "documentation": {}
    },
    {
        "label": "AdvancedShapeVisualization",
        "kind": 6,
        "importPath": "examples.visualization.advanced_shape_example",
        "description": "examples.visualization.advanced_shape_example",
        "peekOfCode": "class AdvancedShapeVisualization:\n    \"\"\"Advanced shape visualization capabilities.\"\"\"\n    def __init__(self, output_dir: str = \"visualizations/advanced_shapes\"):\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        # Initialize components\n        self.embeddings = WordEmbeddings()\n        self.shape_engine = ShapeEngine()\n        self.shape_renderer = ShapeRenderer()\n        self.interactive_renderer = InteractiveRenderer()",
        "detail": "examples.visualization.advanced_shape_example",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.visualization.advanced_shape_example",
        "description": "examples.visualization.advanced_shape_example",
        "peekOfCode": "def main():\n    \"\"\"Run advanced shape visualization examples.\"\"\"\n    try:\n        # Initialize visualization\n        viz = AdvancedShapeVisualization()\n        # Example 1: Shape Field Evolution\n        ritual_text = \"\"\"\n        In the depths of darkness, a spark ignites.\n        Through sacred geometry, patterns emerge.\n        The flame dances with divine symmetry.",
        "detail": "examples.visualization.advanced_shape_example",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.visualization.advanced_shape_example",
        "description": "examples.visualization.advanced_shape_example",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass AdvancedShapeVisualization:\n    \"\"\"Advanced shape visualization capabilities.\"\"\"\n    def __init__(self, output_dir: str = \"visualizations/advanced_shapes\"):\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        # Initialize components\n        self.embeddings = WordEmbeddings()\n        self.shape_engine = ShapeEngine()\n        self.shape_renderer = ShapeRenderer()",
        "detail": "examples.visualization.advanced_shape_example",
        "documentation": {}
    },
    {
        "label": "AdvancedSymbolicVisualization",
        "kind": 6,
        "importPath": "examples.visualization.advanced_symbolic_example",
        "description": "examples.visualization.advanced_symbolic_example",
        "peekOfCode": "class AdvancedSymbolicVisualization:\n    \"\"\"Advanced symbolic visualization capabilities.\"\"\"\n    def __init__(self, output_dir: str = \"visualizations/advanced_symbolic\"):\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        # Initialize components\n        self.embeddings = WordEmbeddings()\n        self.ascii_engine = ASCIIEngine()\n        self.ascii_renderer = ASCIIRenderer()\n        self.interactive_renderer = InteractiveRenderer()",
        "detail": "examples.visualization.advanced_symbolic_example",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.visualization.advanced_symbolic_example",
        "description": "examples.visualization.advanced_symbolic_example",
        "peekOfCode": "def main():\n    \"\"\"Run advanced symbolic visualization examples.\"\"\"\n    try:\n        # Initialize visualization\n        viz = AdvancedSymbolicVisualization()\n        # Example 1: Animated Mandala\n        central_term = \"enlightenment\"\n        related_terms = [\n            \"wisdom\", \"understanding\", \"knowledge\",\n            \"illumination\", \"awakening\", \"consciousness\"",
        "detail": "examples.visualization.advanced_symbolic_example",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.visualization.advanced_symbolic_example",
        "description": "examples.visualization.advanced_symbolic_example",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass AdvancedSymbolicVisualization:\n    \"\"\"Advanced symbolic visualization capabilities.\"\"\"\n    def __init__(self, output_dir: str = \"visualizations/advanced_symbolic\"):\n        self.output_dir = Path(output_dir)\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        # Initialize components\n        self.embeddings = WordEmbeddings()\n        self.ascii_engine = ASCIIEngine()\n        self.ascii_renderer = ASCIIRenderer()",
        "detail": "examples.visualization.advanced_symbolic_example",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.visualization.ascii_example",
        "description": "examples.visualization.ascii_example",
        "peekOfCode": "def main():\n    \"\"\"Run ASCII visualization examples.\"\"\"\n    try:\n        # Initialize components\n        engine = ASCIIEngine()\n        renderer = ASCIIRenderer()\n        # Create output directory\n        output_dir = Path(\"visualizations/ascii\")\n        output_dir.mkdir(parents=True, exist_ok=True)\n        # Example 1: Mandala Pattern",
        "detail": "examples.visualization.ascii_example",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.visualization.ascii_example",
        "description": "examples.visualization.ascii_example",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef main():\n    \"\"\"Run ASCII visualization examples.\"\"\"\n    try:\n        # Initialize components\n        engine = ASCIIEngine()\n        renderer = ASCIIRenderer()\n        # Create output directory\n        output_dir = Path(\"visualizations/ascii\")\n        output_dir.mkdir(parents=True, exist_ok=True)",
        "detail": "examples.visualization.ascii_example",
        "documentation": {}
    },
    {
        "label": "VisualizationResult",
        "kind": 6,
        "importPath": "examples.visualization.example_visualizations",
        "description": "examples.visualization.example_visualizations",
        "peekOfCode": "class VisualizationResult:\n    \"\"\"Track the success and outputs of visualization operations.\"\"\"\n    def __init__(self):\n        self.ritual_evolution_success = False\n        self.shape_field_success = False\n        self.comparative_success = False\n        self.symbolic_success = False\n        self.saved_files: List[str] = []\n    def add_saved_file(self, filepath: str):\n        \"\"\"Record a successfully saved visualization file.\"\"\"",
        "detail": "examples.visualization.example_visualizations",
        "documentation": {}
    },
    {
        "label": "ritual_evolution_example",
        "kind": 2,
        "importPath": "examples.visualization.example_visualizations",
        "description": "examples.visualization.example_visualizations",
        "peekOfCode": "def ritual_evolution_example(result: VisualizationResult):\n    \"\"\"Demonstrate ritual evolution visualization.\"\"\"\n    try:\n        # Initialize embeddings and manifold\n        embeddings = WordEmbeddings()\n        # Define ritual terms\n        terms = [\n            \"light\", \"darkness\", \"wisdom\", \"understanding\",\n            \"beauty\", \"strength\", \"mercy\", \"severity\"\n        ]",
        "detail": "examples.visualization.example_visualizations",
        "documentation": {}
    },
    {
        "label": "semantic_shape_example",
        "kind": 2,
        "importPath": "examples.visualization.example_visualizations",
        "description": "examples.visualization.example_visualizations",
        "peekOfCode": "def semantic_shape_example(result: VisualizationResult):\n    \"\"\"Demonstrate semantic shape visualization.\"\"\"\n    try:\n        # Initialize visualizer with explicit output directory\n        visualizer = ShapeVisualizer(\n            export_config=ExportConfig(\n                output_dir=\"visualizations/shapes\",\n                format=\"mp4\",\n                save_frames=True\n            )",
        "detail": "examples.visualization.example_visualizations",
        "documentation": {}
    },
    {
        "label": "symbolic_visualization_example",
        "kind": 2,
        "importPath": "examples.visualization.example_visualizations",
        "description": "examples.visualization.example_visualizations",
        "peekOfCode": "def symbolic_visualization_example(result: VisualizationResult):\n    \"\"\"Demonstrate symbolic ASCII visualization.\"\"\"\n    try:\n        # Initialize embeddings and visualizer\n        embeddings = WordEmbeddings()\n        visualizer = SymbolicVisualizer(\n            word_embeddings=embeddings,\n            width=100,  # Wider field for better patterns\n            height=50   # Taller field for better patterns\n        )",
        "detail": "examples.visualization.example_visualizations",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.visualization.example_visualizations",
        "description": "examples.visualization.example_visualizations",
        "peekOfCode": "def main():\n    \"\"\"Run all visualization examples.\"\"\"\n    result = VisualizationResult()\n    print(\"Creating ritual evolution visualization...\")\n    ritual_evolution_example(result)\n    print(\"\\nCreating semantic shape visualization...\")\n    semantic_shape_example(result)\n    print(\"\\nCreating symbolic ASCII visualization...\")\n    symbolic_visualization_example(result)\n    print(result.get_summary())",
        "detail": "examples.visualization.example_visualizations",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.visualization.example_visualizations",
        "description": "examples.visualization.example_visualizations",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass VisualizationResult:\n    \"\"\"Track the success and outputs of visualization operations.\"\"\"\n    def __init__(self):\n        self.ritual_evolution_success = False\n        self.shape_field_success = False\n        self.comparative_success = False\n        self.symbolic_success = False\n        self.saved_files: List[str] = []\n    def add_saved_file(self, filepath: str):",
        "detail": "examples.visualization.example_visualizations",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.visualization.semantic_tree_example",
        "description": "examples.visualization.semantic_tree_example",
        "peekOfCode": "def main():\n    # Initialize visualizer\n    visualizer = SemanticTreeVisualizer(\n        output_dir=\"visualizations/semantic_trees\",\n        node_size_base=800,\n        min_similarity=0.3\n    )\n    # Example 1: Simple concept hierarchy\n    root = \"consciousness\"\n    related_terms = set([",
        "detail": "examples.visualization.semantic_tree_example",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.visualization.shape_visualization",
        "description": "examples.visualization.shape_visualization",
        "peekOfCode": "def main():\n    \"\"\"Run semantic shape visualization examples.\"\"\"\n    # Create visualizer\n    visualizer = ShapeVisualizer()\n    # Example 1: Visualize evolution of a poetic text\n    print(\"Creating visualization of poetic evolution...\")\n    poetic_text = \"\"\"\n    The stars move still, time runs, the clock will strike,\n    The devil will come, and Faustus must be damned.\n    O, I'll leap up to my God! Who pulls me down?",
        "detail": "examples.visualization.shape_visualization",
        "documentation": {}
    },
    {
        "label": "os.environ[\"TOKENIZERS_PARALLELISM\"]",
        "kind": 5,
        "importPath": "examples.visualization.shape_visualization",
        "description": "examples.visualization.shape_visualization",
        "peekOfCode": "os.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"\ndef main():\n    \"\"\"Run semantic shape visualization examples.\"\"\"\n    # Create visualizer\n    visualizer = ShapeVisualizer()\n    # Example 1: Visualize evolution of a poetic text\n    print(\"Creating visualization of poetic evolution...\")\n    poetic_text = \"\"\"\n    The stars move still, time runs, the clock will strike,\n    The devil will come, and Faustus must be damned.",
        "detail": "examples.visualization.shape_visualization",
        "documentation": {}
    },
    {
        "label": "audio_files",
        "kind": 5,
        "importPath": "scripts.check_audio",
        "description": "scripts.check_audio",
        "peekOfCode": "audio_files = glob('data/audiovis/complex/*.wav')\nlatest_file = max(audio_files, key=os.path.getctime)\n# Load and print audio properties\ndata, samplerate = sf.read(latest_file)\nduration = len(data) / samplerate\nprint(f\"Audio file: {latest_file}\")\nprint(f\"Sample rate: {samplerate} Hz\")\nprint(f\"Duration: {duration:.2f} seconds\")\nprint(f\"Channels: {data.shape[1] if len(data.shape) > 1 else 1}\")\nprint(f\"Number of samples: {len(data)}\")",
        "detail": "scripts.check_audio",
        "documentation": {}
    },
    {
        "label": "latest_file",
        "kind": 5,
        "importPath": "scripts.check_audio",
        "description": "scripts.check_audio",
        "peekOfCode": "latest_file = max(audio_files, key=os.path.getctime)\n# Load and print audio properties\ndata, samplerate = sf.read(latest_file)\nduration = len(data) / samplerate\nprint(f\"Audio file: {latest_file}\")\nprint(f\"Sample rate: {samplerate} Hz\")\nprint(f\"Duration: {duration:.2f} seconds\")\nprint(f\"Channels: {data.shape[1] if len(data.shape) > 1 else 1}\")\nprint(f\"Number of samples: {len(data)}\")",
        "detail": "scripts.check_audio",
        "documentation": {}
    },
    {
        "label": "duration",
        "kind": 5,
        "importPath": "scripts.check_audio",
        "description": "scripts.check_audio",
        "peekOfCode": "duration = len(data) / samplerate\nprint(f\"Audio file: {latest_file}\")\nprint(f\"Sample rate: {samplerate} Hz\")\nprint(f\"Duration: {duration:.2f} seconds\")\nprint(f\"Channels: {data.shape[1] if len(data.shape) > 1 else 1}\")\nprint(f\"Number of samples: {len(data)}\")",
        "detail": "scripts.check_audio",
        "documentation": {}
    },
    {
        "label": "ResonanceExplorer",
        "kind": 6,
        "importPath": "scripts.explore_resonance",
        "description": "scripts.explore_resonance",
        "peekOfCode": "class ResonanceExplorer:\n    \"\"\"Explores resonant mandala patterns.\"\"\"\n    def __init__(self, output_dir: Path, port: int = 5000):\n        self.output_dir = output_dir\n        self.port = port\n        self.engine = ResonantMandalaEngine()\n        self.active_fields: Set[ResonanceField] = set()\n        self.discovery = None\n        self.network_manager = None\n        # Create output directories",
        "detail": "scripts.explore_resonance",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 2,
        "importPath": "scripts.explore_resonance",
        "description": "scripts.explore_resonance",
        "peekOfCode": "def cli():\n    \"\"\"Resonance exploration tools.\"\"\"\n    pass\n@cli.command()\n@click.option('--field', type=click.Choice([f.value for f in ResonanceField]), help='Primary resonance field')\n@click.option('--secondary', multiple=True, type=click.Choice([f.value for f in ResonanceField]), help='Secondary fields')\n@click.option('--depth', default=5, help='Meditation depth')\n@click.option('--steps', default=3, help='Evolution steps')\n@click.option('--port', default=5000, help='Network port')\n@click.option('--output-dir', type=click.Path(path_type=Path), default='resonance_output', help='Output directory')",
        "detail": "scripts.explore_resonance",
        "documentation": {}
    },
    {
        "label": "explore",
        "kind": 2,
        "importPath": "scripts.explore_resonance",
        "description": "scripts.explore_resonance",
        "peekOfCode": "def explore(field: str, secondary: tuple, depth: int, steps: int, port: int, output_dir: Path):\n    \"\"\"Explore resonance fields.\"\"\"\n    explorer = ResonanceExplorer(output_dir, port=port)\n    # Initialize network\n    asyncio.run(explorer.initialize_network())\n    try:\n        # Convert field names to enums\n        primary_field = ResonanceField(field)\n        secondary_fields = {ResonanceField(f) for f in secondary}\n        # Start exploration",
        "detail": "scripts.explore_resonance",
        "documentation": {}
    },
    {
        "label": "discover",
        "kind": 2,
        "importPath": "scripts.explore_resonance",
        "description": "scripts.explore_resonance",
        "peekOfCode": "def discover(port: int):\n    \"\"\"Discover active resonance nodes.\"\"\"\n    explorer = ResonanceExplorer(Path('resonance_output'), port=port)\n    async def run_discovery():\n        await explorer.initialize_network()\n        try:\n            while True:\n                await asyncio.sleep(1)\n        except KeyboardInterrupt:\n            if explorer.discovery:",
        "detail": "scripts.explore_resonance",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "scripts.explore_resonance",
        "description": "scripts.explore_resonance",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ResonanceExplorer:\n    \"\"\"Explores resonant mandala patterns.\"\"\"\n    def __init__(self, output_dir: Path, port: int = 5000):\n        self.output_dir = output_dir\n        self.port = port\n        self.engine = ResonantMandalaEngine()\n        self.active_fields: Set[ResonanceField] = set()\n        self.discovery = None\n        self.network_manager = None",
        "detail": "scripts.explore_resonance",
        "documentation": {}
    },
    {
        "label": "generate_test_audio",
        "kind": 2,
        "importPath": "scripts.generate_test_audio",
        "description": "scripts.generate_test_audio",
        "peekOfCode": "def generate_test_audio():\n    \"\"\"Generate a test audio file with various patterns.\"\"\"\n    # Set parameters\n    sample_rate = 44100\n    duration = 10  # seconds\n    t = np.linspace(0, duration, int(sample_rate * duration))\n    # Generate base frequencies\n    f1, f2, f3 = 440, 880, 220  # A4, A5, A3\n    # Create interesting patterns\n    signal = np.zeros_like(t)",
        "detail": "scripts.generate_test_audio",
        "documentation": {}
    },
    {
        "label": "WorkerManager",
        "kind": 6,
        "importPath": "scripts.manage_ray_workers",
        "description": "scripts.manage_ray_workers",
        "peekOfCode": "class WorkerManager:\n    \"\"\"Manages Ray worker nodes.\"\"\"\n    def __init__(self, config_path: Path):\n        self.config_path = config_path\n        self.config = self._load_config()\n        self.worker_info: Dict[str, Dict] = {}\n    def _load_config(self) -> Dict:\n        \"\"\"Load Ray configuration.\"\"\"\n        try:\n            with open(self.config_path) as f:",
        "detail": "scripts.manage_ray_workers",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 2,
        "importPath": "scripts.manage_ray_workers",
        "description": "scripts.manage_ray_workers",
        "peekOfCode": "def cli():\n    \"\"\"Ray worker management tools.\"\"\"\n    pass\n@cli.command()\n@click.option('--head-address', required=True, help='Ray head node address')\n@click.option('--config', type=click.Path(exists=True, path_type=Path), default='ray_config.yaml', help='Path to Ray configuration')\n@click.option('--cpu-limit', type=int, help='Limit CPU cores available to Ray')\n@click.option('--memory-limit', type=float, help='Limit memory (GB) available to Ray')\n@click.option('--gpu-limit', type=int, help='Limit GPUs available to Ray')\ndef register(head_address: str, config: Path, cpu_limit: Optional[int], memory_limit: Optional[float], gpu_limit: Optional[int]):",
        "detail": "scripts.manage_ray_workers",
        "documentation": {}
    },
    {
        "label": "register",
        "kind": 2,
        "importPath": "scripts.manage_ray_workers",
        "description": "scripts.manage_ray_workers",
        "peekOfCode": "def register(head_address: str, config: Path, cpu_limit: Optional[int], memory_limit: Optional[float], gpu_limit: Optional[int]):\n    \"\"\"Register this machine as a Ray worker.\"\"\"\n    manager = WorkerManager(config)\n    # Override system resources if limits provided\n    resources = manager.get_system_resources()\n    if cpu_limit:\n        resources['cpu_count'] = min(cpu_limit, resources['cpu_count'])\n    if memory_limit:\n        resources['memory_gb'] = min(memory_limit, resources['memory_gb'])\n    if gpu_limit:",
        "detail": "scripts.manage_ray_workers",
        "documentation": {}
    },
    {
        "label": "status",
        "kind": 2,
        "importPath": "scripts.manage_ray_workers",
        "description": "scripts.manage_ray_workers",
        "peekOfCode": "def status(config: Path):\n    \"\"\"Check worker status.\"\"\"\n    manager = WorkerManager(config)\n    resources = manager.get_system_resources()\n    click.echo(\"\\nSystem Resources:\")\n    click.echo(f\"CPU Cores: {resources['cpu_count']}\")\n    click.echo(f\"Memory: {resources['memory_gb']:.1f} GB\")\n    click.echo(f\"Disk: {resources['disk_gb']:.1f} GB\")\n    click.echo(f\"GPUs: {resources['gpu_count']}\")\n    click.echo(\"\\nCurrent Usage:\")",
        "detail": "scripts.manage_ray_workers",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "scripts.manage_ray_workers",
        "description": "scripts.manage_ray_workers",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass WorkerManager:\n    \"\"\"Manages Ray worker nodes.\"\"\"\n    def __init__(self, config_path: Path):\n        self.config_path = config_path\n        self.config = self._load_config()\n        self.worker_info: Dict[str, Dict] = {}\n    def _load_config(self) -> Dict:\n        \"\"\"Load Ray configuration.\"\"\"\n        try:",
        "detail": "scripts.manage_ray_workers",
        "documentation": {}
    },
    {
        "label": "WaveShape",
        "kind": 6,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "class WaveShape(Enum):\n    \"\"\"Available waveform shapes.\"\"\"\n    SINE = auto()\n    TRIANGLE = auto()\n    SQUARE = auto()\n    SAWTOOTH = auto()\n@dataclass(frozen=True)\nclass SacredRatios:\n    \"\"\"Immutable collection of sacred geometric ratios.\"\"\"\n    PHI: float = (1 + 5 ** 0.5) / 2  # Golden ratio",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "SacredRatios",
        "kind": 6,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "class SacredRatios:\n    \"\"\"Immutable collection of sacred geometric ratios.\"\"\"\n    PHI: float = (1 + 5 ** 0.5) / 2  # Golden ratio\n    SQRT2: float = 2 ** 0.5         # Sacred cut\n    SQRT3: float = 3 ** 0.5         # Vesica Piscis ratio\n    PI: float = math.pi             # Circle ratio\n    E: float = math.e               # Natural growth\n@dataclass(frozen=True)\nclass SacredFrequencies:\n    \"\"\"Immutable collection of sacred frequencies in Hz.\"\"\"",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "SacredFrequencies",
        "kind": 6,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "class SacredFrequencies:\n    \"\"\"Immutable collection of sacred frequencies in Hz.\"\"\"\n    OM: Hertz = 432.0\n    SOLFEGGIO_UT: Hertz = 396.0   # Liberation from fear\n    SOLFEGGIO_RE: Hertz = 417.0   # Change/transformation\n    SOLFEGGIO_MI: Hertz = 528.0   # DNA repair\n    SOLFEGGIO_FA: Hertz = 639.0   # Connection/relationships\n    SOLFEGGIO_SOL: Hertz = 741.0  # Awakening intuition\n    SOLFEGGIO_LA: Hertz = 852.0   # Spiritual order\n@dataclass(frozen=True)",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "AudioParams",
        "kind": 6,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "class AudioParams:\n    \"\"\"Parameters for audio generation.\"\"\"\n    sample_rate: int = 44100\n    duration: Seconds = 1.0\n    amplitude: Amplitude = 1.0\ndef generate_time_array(params: AudioParams) -> np.ndarray:\n    \"\"\"Generate time array for the given duration and sample rate.\"\"\"\n    return np.linspace(0, params.duration, int(params.sample_rate * params.duration))\ndef generate_waveform(\n    frequency: Hertz,",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "generate_time_array",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def generate_time_array(params: AudioParams) -> np.ndarray:\n    \"\"\"Generate time array for the given duration and sample rate.\"\"\"\n    return np.linspace(0, params.duration, int(params.sample_rate * params.duration))\ndef generate_waveform(\n    frequency: Hertz,\n    shape: WaveShape,\n    t: np.ndarray,\n    amplitude: Amplitude = 1.0,\n    phase: Phase = 0.0\n) -> Sample:",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "generate_waveform",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def generate_waveform(\n    frequency: Hertz,\n    shape: WaveShape,\n    t: np.ndarray,\n    amplitude: Amplitude = 1.0,\n    phase: Phase = 0.0\n) -> Sample:\n    \"\"\"Generate a waveform of specified shape and frequency.\"\"\"\n    angular_freq = 2 * np.pi * frequency\n    if shape == WaveShape.SINE:",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "apply_phase_modulation",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def apply_phase_modulation(\n    carrier_freq: Hertz,\n    mod_freq: Hertz,\n    mod_index: float,\n    t: np.ndarray\n) -> Sample:\n    \"\"\"Apply phase modulation to a carrier frequency.\"\"\"\n    phase = mod_index * np.sin(2 * np.pi * mod_freq * t)\n    return np.sin(2 * np.pi * carrier_freq * t + phase)\ndef generate_vesica_piscis(",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "generate_vesica_piscis",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def generate_vesica_piscis(\n    params: AudioParams,\n    ratios: SacredRatios,\n    freqs: SacredFrequencies\n) -> Sample:\n    \"\"\"Generate sound based on Vesica Piscis geometry.\"\"\"\n    t = generate_time_array(params)\n    # Two overlapping circles - represented by two frequencies\n    f1 = freqs.OM\n    f2 = f1 * ratios.SQRT3",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "generate_flower_of_life",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def generate_flower_of_life(\n    params: AudioParams,\n    freqs: SacredFrequencies,\n    num_petals: int = 6\n) -> Sample:\n    \"\"\"Generate sound based on Flower of Life geometry.\"\"\"\n    t = generate_time_array(params)\n    signal = np.zeros_like(t)\n    # Create overlapping circles\n    for i in range(num_petals):",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "fibonacci",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def fibonacci(n: int) -> int:\n    \"\"\"Calculate nth Fibonacci number using dynamic programming.\"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 1\n    fib = [0] * (n + 1)\n    fib[1] = 1\n    for i in range(2, n + 1):\n        fib[i] = fib[i-1] + fib[i-2]",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "fibonacci_ratio",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def fibonacci_ratio(n: int) -> float:\n    \"\"\"Calculate ratio of consecutive Fibonacci numbers.\"\"\"\n    if n <= 1:\n        return 1.0\n    return fibonacci(n) / fibonacci(n-1)\ndef generate_metatrons_cube(\n    params: AudioParams,\n    freqs: SacredFrequencies,\n    platonic_faces: List[int] = [4, 6, 8, 12, 20]  # Tetrahedron to Icosahedron\n) -> Sample:",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "generate_metatrons_cube",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def generate_metatrons_cube(\n    params: AudioParams,\n    freqs: SacredFrequencies,\n    platonic_faces: List[int] = [4, 6, 8, 12, 20]  # Tetrahedron to Icosahedron\n) -> Sample:\n    \"\"\"Generate sound based on Metatron's Cube geometry.\"\"\"\n    t = generate_time_array(params)\n    signal = np.zeros_like(t)\n    # 13 circles of creation\n    for i in range(13):",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "generate_sri_yantra",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def generate_sri_yantra(\n    params: AudioParams,\n    freqs: SacredFrequencies,\n    ratios: SacredRatios,\n    num_triangles: int = 9\n) -> Sample:\n    \"\"\"Generate sound based on Sri Yantra geometry.\"\"\"\n    t = generate_time_array(params)\n    signal = np.zeros_like(t)\n    for i in range(num_triangles):",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "apply_crossfade",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def apply_crossfade(\n    signals: List[Sample],\n    fade_duration: Seconds,\n    sample_rate: int\n) -> Sample:\n    \"\"\"Apply crossfades between multiple audio signals.\"\"\"\n    if not signals:\n        return np.array([])\n    fade_len = int(sample_rate * fade_duration)\n    fade_in = np.linspace(0, 1, fade_len)",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "normalize_audio",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def normalize_audio(signal: Sample) -> Sample:\n    \"\"\"Normalize audio to [-1, 1] range.\"\"\"\n    return signal / (np.max(np.abs(signal)) + 1e-10)  # Avoid division by zero\ndef convert_to_16bit(signal: Sample) -> np.ndarray:\n    \"\"\"Convert float64 audio to 16-bit PCM.\"\"\"\n    return (signal * 32767).astype(np.int16)\ndef save_audio_file(\n    signal: Sample,\n    sample_rate: int,\n    output_path: Union[str, Path]",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "convert_to_16bit",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def convert_to_16bit(signal: Sample) -> np.ndarray:\n    \"\"\"Convert float64 audio to 16-bit PCM.\"\"\"\n    return (signal * 32767).astype(np.int16)\ndef save_audio_file(\n    signal: Sample,\n    sample_rate: int,\n    output_path: Union[str, Path]\n) -> Path:\n    \"\"\"Save audio to WAV file.\"\"\"\n    output_path = Path(output_path)",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "save_audio_file",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def save_audio_file(\n    signal: Sample,\n    sample_rate: int,\n    output_path: Union[str, Path]\n) -> Path:\n    \"\"\"Save audio to WAV file.\"\"\"\n    output_path = Path(output_path)\n    output_path.parent.mkdir(parents=True, exist_ok=True)\n    wavfile.write(str(output_path), sample_rate, signal)\n    return output_path",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "generate_sacred_geometry_suite",
        "kind": 2,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "def generate_sacred_geometry_suite(\n    params: AudioParams = AudioParams(),\n    fade_duration: Seconds = 0.5\n) -> Path:\n    \"\"\"Generate a suite of sacred geometry sounds.\"\"\"\n    ratios = SacredRatios()\n    freqs = SacredFrequencies()\n    # Generate individual patterns\n    patterns = [\n        generate_vesica_piscis(params, ratios, freqs),",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "Seconds",
        "kind": 5,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "Seconds = float\nHertz = float\nSample = np.ndarray  # 1D array of float64\nAudioSignal = Sample  # Alias for semantic clarity\nPhase = float\nAmplitude = float\nclass WaveShape(Enum):\n    \"\"\"Available waveform shapes.\"\"\"\n    SINE = auto()\n    TRIANGLE = auto()",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "Hertz",
        "kind": 5,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "Hertz = float\nSample = np.ndarray  # 1D array of float64\nAudioSignal = Sample  # Alias for semantic clarity\nPhase = float\nAmplitude = float\nclass WaveShape(Enum):\n    \"\"\"Available waveform shapes.\"\"\"\n    SINE = auto()\n    TRIANGLE = auto()\n    SQUARE = auto()",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "Sample",
        "kind": 5,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "Sample = np.ndarray  # 1D array of float64\nAudioSignal = Sample  # Alias for semantic clarity\nPhase = float\nAmplitude = float\nclass WaveShape(Enum):\n    \"\"\"Available waveform shapes.\"\"\"\n    SINE = auto()\n    TRIANGLE = auto()\n    SQUARE = auto()\n    SAWTOOTH = auto()",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "AudioSignal",
        "kind": 5,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "AudioSignal = Sample  # Alias for semantic clarity\nPhase = float\nAmplitude = float\nclass WaveShape(Enum):\n    \"\"\"Available waveform shapes.\"\"\"\n    SINE = auto()\n    TRIANGLE = auto()\n    SQUARE = auto()\n    SAWTOOTH = auto()\n@dataclass(frozen=True)",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "Phase",
        "kind": 5,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "Phase = float\nAmplitude = float\nclass WaveShape(Enum):\n    \"\"\"Available waveform shapes.\"\"\"\n    SINE = auto()\n    TRIANGLE = auto()\n    SQUARE = auto()\n    SAWTOOTH = auto()\n@dataclass(frozen=True)\nclass SacredRatios:",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "Amplitude",
        "kind": 5,
        "importPath": "scripts.sacred_audio",
        "description": "scripts.sacred_audio",
        "peekOfCode": "Amplitude = float\nclass WaveShape(Enum):\n    \"\"\"Available waveform shapes.\"\"\"\n    SINE = auto()\n    TRIANGLE = auto()\n    SQUARE = auto()\n    SAWTOOTH = auto()\n@dataclass(frozen=True)\nclass SacredRatios:\n    \"\"\"Immutable collection of sacred geometric ratios.\"\"\"",
        "detail": "scripts.sacred_audio",
        "documentation": {}
    },
    {
        "label": "RhythmParams",
        "kind": 6,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "class RhythmParams:\n    \"\"\"Parameters for rhythm generation.\"\"\"\n    tempo: float = 120.0  # BPM\n    subdivision: int = 4   # Subdivisions per beat\n    pattern_length: int = 16  # Beats in pattern\n    accent_probability: float = 0.3\n    swing: float = 0.0  # 0.0 to 0.33\n    phase_shift: float = 0.0\n    euclidean_steps: int = 4\n    euclidean_pulses: int = 3",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "DelayParams",
        "kind": 6,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "class DelayParams:\n    \"\"\"Parameters for delay effects.\"\"\"\n    delay_time: float = 0.25  # seconds\n    feedback: float = 0.4     # 0-1\n    mix: float = 0.3         # dry/wet mix\n    filter_freq: float = 2000.0  # Hz\n    resonance: float = 0.7    # filter Q\n@dataclass\nclass RecursiveParams:\n    \"\"\"Parameters for recursive pattern generation.\"\"\"",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "RecursiveParams",
        "kind": 6,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "class RecursiveParams:\n    \"\"\"Parameters for recursive pattern generation.\"\"\"\n    depth: int = 3\n    decay: float = 0.7\n    mutation_rate: float = 0.2\n    self_similarity: float = 0.8\n    evolution_rate: float = 0.3\n@dataclass\nclass HarmonicParams:\n    \"\"\"Parameters for harmonic synthesis.\"\"\"",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "HarmonicParams",
        "kind": 6,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "class HarmonicParams:\n    \"\"\"Parameters for harmonic synthesis.\"\"\"\n    fundamental: float = 432.0\n    overtones: List[float] = None\n    ratios: List[float] = None\n    phase_coherence: float = 0.8\n    spectral_tilt: float = -6.0  # dB/octave\n    def __post_init__(self):\n        if self.overtones is None:\n            # Harmonic series with golden ratio influences",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "generate_euclidean_rhythm",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def generate_euclidean_rhythm(steps: int, pulses: int) -> List[int]:\n    \"\"\"Generate Euclidean rhythm pattern (even distribution of pulses).\"\"\"\n    if pulses > steps:\n        pulses = steps\n    if pulses == 0:\n        return [0] * steps\n    pattern = []\n    counts = []\n    remainder = [1] * pulses + [0] * (steps - pulses)\n    while len(remainder) > 1:",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "generate_fibonacci_rhythm",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def generate_fibonacci_rhythm(length: int) -> List[int]:\n    \"\"\"Generate rhythm based on Fibonacci sequence.\"\"\"\n    # Generate Fibonacci numbers up to length\n    fib = [1, 1]\n    while fib[-1] < length:\n        fib.append(fib[-1] + fib[-2])\n    # Create rhythm pattern\n    pattern = [0] * length\n    for i in fib:\n        if i < length:",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "generate_golden_rhythm",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def generate_golden_rhythm(length: int) -> List[int]:\n    \"\"\"Generate rhythm based on golden ratio.\"\"\"\n    phi = (1 + np.sqrt(5)) / 2\n    pattern = [0] * length\n    # Place accents at positions based on phi\n    pos = 0\n    while pos < length:\n        pattern[int(pos)] = 1\n        pos += phi\n    return pattern",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "generate_spiral_rhythm",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def generate_spiral_rhythm(sample_rate: int, duration: float, \n                         frequency: float = 1.0, decay: float = 0.5) -> np.ndarray:\n    \"\"\"Generate a rhythm based on logarithmic spiral.\"\"\"\n    t = np.linspace(0, duration, int(sample_rate * duration))\n    spiral = np.exp(-decay * t) * np.sin(2 * np.pi * frequency * t * np.exp(t/duration))\n    return (spiral > 0.3).astype(float)  # Threshold to create rhythm\ndef apply_swing(pattern: List[int], swing_amount: float) -> List[int]:\n    \"\"\"Apply swing feel to rhythm pattern.\"\"\"\n    if len(pattern) % 2 != 0:\n        pattern.append(0)",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "apply_swing",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def apply_swing(pattern: List[int], swing_amount: float) -> List[int]:\n    \"\"\"Apply swing feel to rhythm pattern.\"\"\"\n    if len(pattern) % 2 != 0:\n        pattern.append(0)\n    swung_pattern = []\n    for i in range(0, len(pattern), 2):\n        swung_pattern.append(pattern[i])\n        if i + 1 < len(pattern):\n            # Delay every second eighth note\n            swung_pattern.append(0)",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "create_rhythm_variation",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def create_rhythm_variation(base_rhythm: List[int], variation_type: str,\n                          params: RhythmParams) -> List[int]:\n    \"\"\"Create variation of base rhythm pattern.\"\"\"\n    pattern = base_rhythm.copy()\n    if variation_type == \"density\":\n        # Add notes between existing ones\n        for i in range(len(pattern)-1):\n            if pattern[i] == 1 and pattern[i+1] == 0:\n                if np.random.random() < params.accent_probability:\n                    pattern[i+1] = 0.7",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "pattern_to_signal",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def pattern_to_signal(pattern: List[int], sample_rate: int, tempo: float,\n                     wave_shape: WaveShape = WaveShape.SINE) -> np.ndarray:\n    \"\"\"Convert rhythm pattern to audio signal.\"\"\"\n    # Calculate samples per beat\n    beat_duration = 60.0 / tempo  # seconds per beat\n    samples_per_beat = int(beat_duration * sample_rate)\n    # Create base signal\n    signal = np.zeros(len(pattern) * samples_per_beat)\n    # Generate each beat\n    for i, accent in enumerate(pattern):",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "apply_delay",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def apply_delay(signal: np.ndarray, sample_rate: int, params: DelayParams) -> np.ndarray:\n    \"\"\"Apply delay effect with feedback and filtering.\"\"\"\n    delay_samples = int(params.delay_time * sample_rate)\n    output = signal.copy()\n    feedback_signal = np.zeros_like(signal)\n    # Create resonant filter\n    b, a = sig.butter(2, params.filter_freq / (sample_rate/2), btype='low', analog=False)\n    # Apply delay with feedback\n    for i in range(len(signal)):\n        if i >= delay_samples:",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "generate_recursive_rhythm",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def generate_recursive_rhythm(\n    base_pattern: List[int],\n    params: RecursiveParams\n) -> List[int]:\n    \"\"\"Generate recursive variations of a rhythm pattern.\"\"\"\n    if params.depth <= 0:\n        return base_pattern\n    pattern_length = len(base_pattern)\n    new_pattern = base_pattern.copy()\n    # Apply recursive subdivision",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "synthesize_harmonics",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def synthesize_harmonics(\n    frequency: float,\n    duration: float,\n    sample_rate: int,\n    params: HarmonicParams\n) -> np.ndarray:\n    \"\"\"Synthesize rich harmonic content based on sacred ratios.\"\"\"\n    t = np.linspace(0, duration, int(duration * sample_rate))\n    signal = np.zeros_like(t)\n    # Generate harmonic series",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "generate_variation_suite",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def generate_variation_suite(\n    duration: float = 5.0,\n    sample_rate: int = 44100,\n    base_freq: float = 432.0,\n    tempo: float = 120.0\n) -> Dict[str, np.ndarray]:\n    \"\"\"Generate a suite of rhythm variations with effects.\"\"\"\n    # Initialize parameters\n    rhythm_params = RhythmParams(\n        tempo=tempo,",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "save_variations",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def save_variations(variations: Dict[str, np.ndarray], \n                   output_dir: str = \"data/audio/explorations\",\n                   sample_rate: int = 44100):\n    \"\"\"Save variation suite to files.\"\"\"\n    output_path = Path(output_dir)\n    output_path.mkdir(parents=True, exist_ok=True)\n    timestamp = time.strftime(\"%Y%m%d_%H%M%S\")\n    # Save individual variations\n    for name, signal in variations.items():\n        filename = output_path / f\"{name}_{timestamp}.wav\"",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.sacred_audio_explorer",
        "description": "scripts.sacred_audio_explorer",
        "peekOfCode": "def main():\n    \"\"\"Generate and save rhythm variations.\"\"\"\n    print(\"Generating sacred rhythm variations...\")\n    variations = generate_variation_suite(\n        duration=5.0,\n        sample_rate=44100,\n        base_freq=432.0,\n        tempo=120.0\n    )\n    print(\"\\nSaving variations...\")",
        "detail": "scripts.sacred_audio_explorer",
        "documentation": {}
    },
    {
        "label": "VisualizationParams",
        "kind": 6,
        "importPath": "scripts.sacred_audiovis",
        "description": "scripts.sacred_audiovis",
        "peekOfCode": "class VisualizationParams:\n    \"\"\"Parameters for ASCII visualization.\"\"\"\n    width: int = 80\n    height: int = 40\n    density: float = 0.6\n    style: str = 'mystical'\n    symmetry: int = 8\n    layers: int = 5\n@dataclass(frozen=True)\nclass AudioVisualParams:",
        "detail": "scripts.sacred_audiovis",
        "documentation": {}
    },
    {
        "label": "AudioVisualParams",
        "kind": 6,
        "importPath": "scripts.sacred_audiovis",
        "description": "scripts.sacred_audiovis",
        "peekOfCode": "class AudioVisualParams:\n    \"\"\"Combined parameters for audio-visual generation.\"\"\"\n    audio: AudioParams\n    visual: VisualizationParams\n    duration: float = 5.0  # seconds\n    frames: int = 60      # number of frames for animation\ndef map_frequency_to_radius(freq: float, base_freq: float = 432.0, min_radius: int = 10, max_radius: int = 30) -> int:\n    \"\"\"Map frequency to mandala radius using logarithmic scaling.\"\"\"\n    ratio = math.log2(freq / base_freq)\n    # Map ratio to radius range",
        "detail": "scripts.sacred_audiovis",
        "documentation": {}
    },
    {
        "label": "map_frequency_to_radius",
        "kind": 2,
        "importPath": "scripts.sacred_audiovis",
        "description": "scripts.sacred_audiovis",
        "peekOfCode": "def map_frequency_to_radius(freq: float, base_freq: float = 432.0, min_radius: int = 10, max_radius: int = 30) -> int:\n    \"\"\"Map frequency to mandala radius using logarithmic scaling.\"\"\"\n    ratio = math.log2(freq / base_freq)\n    # Map ratio to radius range\n    radius = min_radius + (max_radius - min_radius) * (ratio + 1) / 2\n    return int(radius)\ndef map_frequency_to_symmetry(freq: float, base_freq: float = 432.0, min_sym: int = 4, max_sym: int = 12) -> int:\n    \"\"\"Map frequency to mandala symmetry using harmonic relationships.\"\"\"\n    ratio = freq / base_freq\n    # Use musical ratios to determine symmetry",
        "detail": "scripts.sacred_audiovis",
        "documentation": {}
    },
    {
        "label": "map_frequency_to_symmetry",
        "kind": 2,
        "importPath": "scripts.sacred_audiovis",
        "description": "scripts.sacred_audiovis",
        "peekOfCode": "def map_frequency_to_symmetry(freq: float, base_freq: float = 432.0, min_sym: int = 4, max_sym: int = 12) -> int:\n    \"\"\"Map frequency to mandala symmetry using harmonic relationships.\"\"\"\n    ratio = freq / base_freq\n    # Use musical ratios to determine symmetry\n    harmonics = [1/2, 2/3, 3/4, 1, 4/3, 3/2, 2]\n    closest_harmonic = min(harmonics, key=lambda x: abs(ratio - x))\n    # Map harmonic to symmetry range\n    sym_range = max_sym - min_sym\n    sym = min_sym + int(sym_range * harmonics.index(closest_harmonic) / (len(harmonics) - 1))\n    return sym",
        "detail": "scripts.sacred_audiovis",
        "documentation": {}
    },
    {
        "label": "map_amplitude_to_density",
        "kind": 2,
        "importPath": "scripts.sacred_audiovis",
        "description": "scripts.sacred_audiovis",
        "peekOfCode": "def map_amplitude_to_density(amplitude: float, min_density: float = 0.3, max_density: float = 0.9) -> float:\n    \"\"\"Map audio amplitude to visual density.\"\"\"\n    return min_density + (max_density - min_density) * amplitude\ndef map_spectrum_to_style(spectrum: np.ndarray) -> str:\n    \"\"\"Map spectral characteristics to visual style.\"\"\"\n    # Calculate spectral centroid\n    freqs = np.linspace(0, 22050, len(spectrum))\n    centroid = np.sum(freqs * spectrum) / np.sum(spectrum)\n    # Map centroid to styles\n    styles = ['mystical', 'cosmic', 'ethereal', 'ancient', 'digital']",
        "detail": "scripts.sacred_audiovis",
        "documentation": {}
    },
    {
        "label": "map_spectrum_to_style",
        "kind": 2,
        "importPath": "scripts.sacred_audiovis",
        "description": "scripts.sacred_audiovis",
        "peekOfCode": "def map_spectrum_to_style(spectrum: np.ndarray) -> str:\n    \"\"\"Map spectral characteristics to visual style.\"\"\"\n    # Calculate spectral centroid\n    freqs = np.linspace(0, 22050, len(spectrum))\n    centroid = np.sum(freqs * spectrum) / np.sum(spectrum)\n    # Map centroid to styles\n    styles = ['mystical', 'cosmic', 'ethereal', 'ancient', 'digital']\n    style_idx = int((centroid / 22050) * len(styles))\n    return styles[min(style_idx, len(styles) - 1)]\ndef generate_frame_parameters(",
        "detail": "scripts.sacred_audiovis",
        "documentation": {}
    },
    {
        "label": "generate_frame_parameters",
        "kind": 2,
        "importPath": "scripts.sacred_audiovis",
        "description": "scripts.sacred_audiovis",
        "peekOfCode": "def generate_frame_parameters(\n    audio_segment: np.ndarray,\n    sample_rate: int,\n    base_params: AudioVisualParams\n) -> VisualizationParams:\n    \"\"\"Generate visualization parameters based on audio segment analysis.\"\"\"\n    # Calculate frequency spectrum\n    spectrum = np.abs(np.fft.rfft(audio_segment))\n    # Find dominant frequency\n    freq_bins = np.fft.rfftfreq(len(audio_segment), 1/sample_rate)",
        "detail": "scripts.sacred_audiovis",
        "documentation": {}
    },
    {
        "label": "generate_synchronized_patterns",
        "kind": 2,
        "importPath": "scripts.sacred_audiovis",
        "description": "scripts.sacred_audiovis",
        "peekOfCode": "def generate_synchronized_patterns(\n    params: AudioVisualParams,\n    output_dir: Path,\n    pattern_type: str = 'mandala'\n) -> Tuple[Path, List[str]]:\n    \"\"\"Generate synchronized audio and visual patterns.\"\"\"\n    output_dir.mkdir(parents=True, exist_ok=True)\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    # Initialize engines\n    ascii_engine = ASCIIEngine()",
        "detail": "scripts.sacred_audiovis",
        "documentation": {}
    },
    {
        "label": "VisualizationParams",
        "kind": 6,
        "importPath": "scripts.sacred_audiovis_complex",
        "description": "scripts.sacred_audiovis_complex",
        "peekOfCode": "class VisualizationParams:\n    \"\"\"Parameters for visualization generation.\"\"\"\n    radius: int = 20\n    symmetry: int = 8\n    style: str = \"mystical\"\n    layers: int = 3\n    width: int = 120\n    height: int = 60\n@dataclass\nclass AudioVisualParams:",
        "detail": "scripts.sacred_audiovis_complex",
        "documentation": {}
    },
    {
        "label": "AudioVisualParams",
        "kind": 6,
        "importPath": "scripts.sacred_audiovis_complex",
        "description": "scripts.sacred_audiovis_complex",
        "peekOfCode": "class AudioVisualParams:\n    \"\"\"Combined parameters for audio-visual generation.\"\"\"\n    sample_rate: int = 44100\n    duration: float = 10.0\n    base_freq: float = 432.0  # Sacred A\n    harmonics: List[float] = None\n    display_size: Tuple[int, int] = (120, 60)\n    frame_rate: int = 12\n    wave_shapes: List[WaveShape] = None\n    modulation_types: List[ModulationType] = None",
        "detail": "scripts.sacred_audiovis_complex",
        "documentation": {}
    },
    {
        "label": "map_audio_to_visual",
        "kind": 2,
        "importPath": "scripts.sacred_audiovis_complex",
        "description": "scripts.sacred_audiovis_complex",
        "peekOfCode": "def map_audio_to_visual(audio_features: dict, base_params: VisualizationParams) -> VisualizationParams:\n    \"\"\"Maps audio features to visual parameters.\"\"\"\n    # Extract audio features\n    freq = audio_features.get('frequency', 432.0)\n    amplitude = audio_features.get('amplitude', 0.5)\n    harmonic_content = audio_features.get('harmonic_content', 0.5)\n    spectral_centroid = audio_features.get('spectral_centroid', 1000)\n    # Map frequency to radius (logarithmic scaling)\n    radius = int(10 + 20 * np.log10(freq / 432.0 + 1))\n    radius = max(5, min(40, radius))",
        "detail": "scripts.sacred_audiovis_complex",
        "documentation": {}
    },
    {
        "label": "generate_synchronized_patterns",
        "kind": 2,
        "importPath": "scripts.sacred_audiovis_complex",
        "description": "scripts.sacred_audiovis_complex",
        "peekOfCode": "def generate_synchronized_patterns(params: AudioVisualParams) -> Tuple[str, List[str]]:\n    \"\"\"Generates synchronized audio and visual patterns.\"\"\"\n    # Create output directory\n    timestamp = time.strftime(\"%Y%m%d_%H%M%S\")\n    output_dir = \"data/audiovis/complex\"\n    os.makedirs(output_dir, exist_ok=True)\n    # Generate multiple audio segments with different parameters\n    segments = []\n    segment_duration = params.duration / 4  # Split into 4 segments\n    for i in range(4):",
        "detail": "scripts.sacred_audiovis_complex",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.sacred_audiovis_complex",
        "description": "scripts.sacred_audiovis_complex",
        "peekOfCode": "def main():\n    \"\"\"Main function to generate synchronized patterns.\"\"\"\n    # Set up parameters\n    params = AudioVisualParams(\n        sample_rate=44100,\n        duration=10.0,\n        base_freq=432.0,\n        display_size=(120, 60),\n        frame_rate=12,\n        use_fibonacci=True,",
        "detail": "scripts.sacred_audiovis_complex",
        "documentation": {}
    },
    {
        "label": "AudioVisualJob",
        "kind": 6,
        "importPath": "scripts.sacred_audiovis_job",
        "description": "scripts.sacred_audiovis_job",
        "peekOfCode": "class AudioVisualJob:\n    \"\"\"Ray actor for managing audio-visual generation job.\"\"\"\n    def __init__(self, config: Dict[str, Any]):\n        self.config = config\n        self.output_dir = Path(config.get('output_dir', 'data/audiovis/complex'))\n        self.output_dir.mkdir(parents=True, exist_ok=True)\n        # Save job config\n        with open(self.output_dir / 'job_config.json', 'w') as f:\n            json.dump(convert_to_serializable(config), f, indent=2)\n    def run(self) -> Dict[str, Any]:",
        "detail": "scripts.sacred_audiovis_job",
        "documentation": {}
    },
    {
        "label": "convert_to_serializable",
        "kind": 2,
        "importPath": "scripts.sacred_audiovis_job",
        "description": "scripts.sacred_audiovis_job",
        "peekOfCode": "def convert_to_serializable(obj: Any) -> Any:\n    \"\"\"Convert numpy types to Python native types.\"\"\"\n    if isinstance(obj, np.ndarray):\n        return obj.tolist()\n    elif isinstance(obj, np.number):\n        return obj.item()\n    elif isinstance(obj, (list, tuple)):\n        return [convert_to_serializable(item) for item in obj]\n    elif isinstance(obj, dict):\n        return {key: convert_to_serializable(value) for key, value in obj.items()}",
        "detail": "scripts.sacred_audiovis_job",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "scripts.sacred_audiovis_job",
        "description": "scripts.sacred_audiovis_job",
        "peekOfCode": "def load_config(config_path: str) -> Dict[str, Any]:\n    \"\"\"Load configuration from YAML file.\"\"\"\n    with open(config_path, 'r') as f:\n        return yaml.safe_load(f)\ndef job_entrypoint(config: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Entrypoint function for Ray job submission.\"\"\"\n    # Initialize Ray if not already done\n    if not ray.is_initialized():\n        ray.init()\n    try:",
        "detail": "scripts.sacred_audiovis_job",
        "documentation": {}
    },
    {
        "label": "job_entrypoint",
        "kind": 2,
        "importPath": "scripts.sacred_audiovis_job",
        "description": "scripts.sacred_audiovis_job",
        "peekOfCode": "def job_entrypoint(config: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Entrypoint function for Ray job submission.\"\"\"\n    # Initialize Ray if not already done\n    if not ray.is_initialized():\n        ray.init()\n    try:\n        # Create job actor\n        job = AudioVisualJob.remote(config)\n        # Run job and get results\n        result = ray.get(job.run.remote())",
        "detail": "scripts.sacred_audiovis_job",
        "documentation": {}
    },
    {
        "label": "get_local_ip",
        "kind": 2,
        "importPath": "scripts.start_ray_cluster",
        "description": "scripts.start_ray_cluster",
        "peekOfCode": "def get_local_ip() -> str:\n    \"\"\"Get local IP address.\"\"\"\n    return \"0.0.0.0\"\ndef load_config(config_path: Path) -> dict:\n    \"\"\"Load Ray configuration.\"\"\"\n    with open(config_path) as f:\n        config = yaml.safe_load(f)\n    # Update head node IP if set to localhost\n    if config[\"head_node\"][\"node_ip\"] == \"localhost\":\n        config[\"head_node\"][\"node_ip\"] = get_local_ip()",
        "detail": "scripts.start_ray_cluster",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "scripts.start_ray_cluster",
        "description": "scripts.start_ray_cluster",
        "peekOfCode": "def load_config(config_path: Path) -> dict:\n    \"\"\"Load Ray configuration.\"\"\"\n    with open(config_path) as f:\n        config = yaml.safe_load(f)\n    # Update head node IP if set to localhost\n    if config[\"head_node\"][\"node_ip\"] == \"localhost\":\n        config[\"head_node\"][\"node_ip\"] = get_local_ip()\n    return config\ndef wait_for_nodes(expected_nodes: int, timeout: int = 60) -> bool:\n    \"\"\"Wait for worker nodes to connect.\"\"\"",
        "detail": "scripts.start_ray_cluster",
        "documentation": {}
    },
    {
        "label": "wait_for_nodes",
        "kind": 2,
        "importPath": "scripts.start_ray_cluster",
        "description": "scripts.start_ray_cluster",
        "peekOfCode": "def wait_for_nodes(expected_nodes: int, timeout: int = 60) -> bool:\n    \"\"\"Wait for worker nodes to connect.\"\"\"\n    start_time = time.time()\n    while time.time() - start_time < timeout:\n        nodes = ray.nodes()\n        alive_nodes = len([n for n in nodes if n[\"alive\"]])\n        if alive_nodes >= expected_nodes:\n            return True\n        time.sleep(1)\n        logger.info(f\"Waiting for nodes... ({alive_nodes}/{expected_nodes})\")",
        "detail": "scripts.start_ray_cluster",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 2,
        "importPath": "scripts.start_ray_cluster",
        "description": "scripts.start_ray_cluster",
        "peekOfCode": "def cli():\n    \"\"\"Ray cluster management CLI.\"\"\"\n    pass\n@cli.command()\n@click.option(\"--config\", type=click.Path(exists=True, path_type=Path), default=\"ray_config.yaml\", help=\"Path to Ray configuration file\")\n@click.option(\"--head/--worker\", default=True, help=\"Start as head node or worker node\")\n@click.option(\"--block/--no-block\", default=True, help=\"Block the script from exiting\")\ndef start(config: Path, head: bool, block: bool):\n    \"\"\"Start Ray node (head or worker).\"\"\"\n    try:",
        "detail": "scripts.start_ray_cluster",
        "documentation": {}
    },
    {
        "label": "start",
        "kind": 2,
        "importPath": "scripts.start_ray_cluster",
        "description": "scripts.start_ray_cluster",
        "peekOfCode": "def start(config: Path, head: bool, block: bool):\n    \"\"\"Start Ray node (head or worker).\"\"\"\n    try:\n        ray_config = load_config(config)\n        if head:\n            logger.info(\"Starting Ray head node...\")\n            ray.init(\n                _system_config=ray_config[\"system_config\"],\n                runtime_env=ray_config[\"runtime_env\"]\n            )",
        "detail": "scripts.start_ray_cluster",
        "documentation": {}
    },
    {
        "label": "status",
        "kind": 2,
        "importPath": "scripts.start_ray_cluster",
        "description": "scripts.start_ray_cluster",
        "peekOfCode": "def status(config: Path):\n    \"\"\"Check Ray cluster status.\"\"\"\n    try:\n        ray_config = load_config(config)\n        # Try to connect to cluster\n        try:\n            head_ip = ray_config[\"head_node\"][\"node_ip\"]\n            head_port = ray_config[\"head_node\"][\"redis_port\"]\n            password = ray_config[\"head_node\"][\"redis_password\"]\n            ray.init(",
        "detail": "scripts.start_ray_cluster",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "scripts.start_ray_cluster",
        "description": "scripts.start_ray_cluster",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef get_local_ip() -> str:\n    \"\"\"Get local IP address.\"\"\"\n    return \"0.0.0.0\"\ndef load_config(config_path: Path) -> dict:\n    \"\"\"Load Ray configuration.\"\"\"\n    with open(config_path) as f:\n        config = yaml.safe_load(f)\n    # Update head node IP if set to localhost\n    if config[\"head_node\"][\"node_ip\"] == \"localhost\":",
        "detail": "scripts.start_ray_cluster",
        "documentation": {}
    },
    {
        "label": "init_ray",
        "kind": 2,
        "importPath": "scripts.test_ascii",
        "description": "scripts.test_ascii",
        "peekOfCode": "def init_ray():\n    \"\"\"Initialize Ray if needed.\"\"\"\n    try:\n        import ray\n        if not ray.is_initialized():\n            # Try to connect to existing Ray instance first\n            try:\n                ray.init(address='auto', ignore_reinit_error=True)\n                logger.info(\"Connected to existing Ray instance\")\n            except:",
        "detail": "scripts.test_ascii",
        "documentation": {}
    },
    {
        "label": "import_visualization",
        "kind": 2,
        "importPath": "scripts.test_ascii",
        "description": "scripts.test_ascii",
        "peekOfCode": "def import_visualization():\n    \"\"\"Import visualization modules with proper error handling.\"\"\"\n    with DebugContext(\"Importing modules\"):\n        try:\n            from word_manifold.visualization.engines.ascii import ASCIIEngine\n            from word_manifold.visualization.renderers.ascii import ASCIIRenderer\n            from word_manifold.types.patterns import Mandala, Field\n            return ASCIIEngine, ASCIIRenderer, Mandala, Field\n        except ImportError as e:\n            logger.error(f\"Failed to import visualization modules: {e}\")",
        "detail": "scripts.test_ascii",
        "documentation": {}
    },
    {
        "label": "test_mandalas",
        "kind": 2,
        "importPath": "scripts.test_ascii",
        "description": "scripts.test_ascii",
        "peekOfCode": "def test_mandalas(task_mgr: AsyncTaskManager):\n    \"\"\"Test mandala patterns with different styles.\"\"\"\n    logger.info(\"Testing mandala patterns...\")\n    ASCIIEngine, ASCIIRenderer, _, _ = import_visualization()\n    engine = ASCIIEngine()\n    renderer = ASCIIRenderer()\n    try:\n        # Test different styles in parallel\n        styles = ['mystical', 'geometric', 'natural']\n        themes = ['mystic', 'fire', 'water']",
        "detail": "scripts.test_ascii",
        "documentation": {}
    },
    {
        "label": "test_wave_patterns",
        "kind": 2,
        "importPath": "scripts.test_ascii",
        "description": "scripts.test_ascii",
        "peekOfCode": "def test_wave_patterns(task_mgr: AsyncTaskManager):\n    \"\"\"Test wave patterns with different styles.\"\"\"\n    logger.info(\"Testing wave patterns...\")\n    ASCIIEngine, ASCIIRenderer, _, _ = import_visualization()\n    engine = ASCIIEngine()\n    renderer = ASCIIRenderer()\n    try:\n        # Test different wave types in parallel\n        wave_types = ['sine', 'square', 'triangle']\n        themes = ['water', 'earth', 'air']",
        "detail": "scripts.test_ascii",
        "documentation": {}
    },
    {
        "label": "test_pattern_blending",
        "kind": 2,
        "importPath": "scripts.test_ascii",
        "description": "scripts.test_ascii",
        "peekOfCode": "def test_pattern_blending(task_mgr: AsyncTaskManager):\n    \"\"\"Test pattern blending with different modes.\"\"\"\n    logger.info(\"Testing pattern blending...\")\n    ASCIIEngine, ASCIIRenderer, _, _ = import_visualization()\n    engine = ASCIIEngine()\n    renderer = ASCIIRenderer()\n    try:\n        # Create base patterns with matching dimensions\n        size = 31  # Odd number for mandala centering\n        radius = (size - 1) // 2",
        "detail": "scripts.test_ascii",
        "documentation": {}
    },
    {
        "label": "test_animations",
        "kind": 2,
        "importPath": "scripts.test_ascii",
        "description": "scripts.test_ascii",
        "peekOfCode": "def test_animations():\n    \"\"\"Test animations with different effects.\"\"\"\n    logger.info(\"Testing animations...\")\n    ASCIIEngine, ASCIIRenderer, _, _ = import_visualization()\n    engine = ASCIIEngine()\n    renderer = ASCIIRenderer()\n    try:\n        # Create different animation types\n        print(\"\\nAnimation Types Available:\")\n        print(\"1. Rotating Mandala (cosmic theme)\")",
        "detail": "scripts.test_ascii",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.test_ascii",
        "description": "scripts.test_ascii",
        "peekOfCode": "def main():\n    \"\"\"Run all tests.\"\"\"\n    try:\n        # Create output directory\n        output_dir = Path(\"test_outputs/ascii\")\n        output_dir.mkdir(parents=True, exist_ok=True)\n        # Initialize Ray if needed (but don't require it)\n        init_ray()\n        # Create task manager for parallel processing\n        task_mgr = AsyncTaskManager(max_workers=4)",
        "detail": "scripts.test_ascii",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "scripts.test_ascii",
        "description": "scripts.test_ascii",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef init_ray():\n    \"\"\"Initialize Ray if needed.\"\"\"\n    try:\n        import ray\n        if not ray.is_initialized():\n            # Try to connect to existing Ray instance first\n            try:\n                ray.init(address='auto', ignore_reinit_error=True)\n                logger.info(\"Connected to existing Ray instance\")",
        "detail": "scripts.test_ascii",
        "documentation": {}
    },
    {
        "label": "EchoModel",
        "kind": 6,
        "importPath": "scripts.test_cluster",
        "description": "scripts.test_cluster",
        "peekOfCode": "class EchoModel:\n    def __init__(self):\n        self._counter = 0\n    async def __call__(self, request) -> Dict:\n        self._counter += 1\n        return {\n            \"echo\": request.query_params.get(\"message\", \"Hello!\"),\n            \"counter\": self._counter\n        }\nclass ClusterTester:",
        "detail": "scripts.test_cluster",
        "documentation": {}
    },
    {
        "label": "ClusterTester",
        "kind": 6,
        "importPath": "scripts.test_cluster",
        "description": "scripts.test_cluster",
        "peekOfCode": "class ClusterTester:\n    def __init__(self):\n        self.console = Console()\n        self.test_results: List[Dict] = []\n        self.current_iteration = 0\n    async def run_tests(self):\n        \"\"\"Run all cluster tests in a continuous loop.\"\"\"\n        while True:\n            self.current_iteration += 1\n            iteration_start = datetime.now()",
        "detail": "scripts.test_cluster",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "scripts.test_cluster",
        "description": "scripts.test_cluster",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@serve.deployment(name=\"echo\", num_replicas=2)\nclass EchoModel:\n    def __init__(self):\n        self._counter = 0\n    async def __call__(self, request) -> Dict:\n        self._counter += 1\n        return {\n            \"echo\": request.query_params.get(\"message\", \"Hello!\"),\n            \"counter\": self._counter",
        "detail": "scripts.test_cluster",
        "documentation": {}
    },
    {
        "label": "import_visualization",
        "kind": 2,
        "importPath": "scripts.test_three",
        "description": "scripts.test_three",
        "peekOfCode": "def import_visualization():\n    \"\"\"Import visualization modules with proper error handling.\"\"\"\n    with DebugContext(\"Importing modules\"):\n        try:\n            from word_manifold.visualization.renderers.three_renderer import ThreeRenderer\n            from word_manifold.visualization.engines.projection import ProjectionEngine\n            return ThreeRenderer, ProjectionEngine\n        except ImportError as e:\n            logger.error(f\"Failed to import visualization modules: {e}\")\n            sys.exit(1)",
        "detail": "scripts.test_three",
        "documentation": {}
    },
    {
        "label": "test_static_visualization",
        "kind": 2,
        "importPath": "scripts.test_three",
        "description": "scripts.test_three",
        "peekOfCode": "def test_static_visualization(task_mgr: AsyncTaskManager):\n    \"\"\"Test static 3D visualization.\"\"\"\n    logger.info(\"Testing static visualization...\")\n    ThreeRenderer, ProjectionEngine = import_visualization()\n    try:\n        # Create test data\n        n_points = 100\n        n_dims = 5\n        points = np.random.randn(n_points, n_dims)\n        # Create edges between nearby points",
        "detail": "scripts.test_three",
        "documentation": {}
    },
    {
        "label": "test_animation",
        "kind": 2,
        "importPath": "scripts.test_three",
        "description": "scripts.test_three",
        "peekOfCode": "def test_animation(task_mgr: AsyncTaskManager):\n    \"\"\"Test animated dimensional transitions.\"\"\"\n    logger.info(\"Testing animation...\")\n    ThreeRenderer, ProjectionEngine = import_visualization()\n    try:\n        # Create test data\n        n_points = 50\n        n_dims = 4\n        points = np.random.randn(n_points, n_dims)\n        # Create edges between nearby points",
        "detail": "scripts.test_three",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.test_three",
        "description": "scripts.test_three",
        "peekOfCode": "def main():\n    \"\"\"Run all tests.\"\"\"\n    mem = memory_usage()\n    if isinstance(mem, dict):\n        mem = mem.get('rss', 0)\n    logger.info(f\"Initial memory usage: {mem:.1f}MB RSS\")\n    with DebugContext(\"Running tests\"):\n        task_mgr = AsyncTaskManager()\n        try:\n            # Run tests",
        "detail": "scripts.test_three",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "scripts.test_three",
        "description": "scripts.test_three",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef import_visualization():\n    \"\"\"Import visualization modules with proper error handling.\"\"\"\n    with DebugContext(\"Importing modules\"):\n        try:\n            from word_manifold.visualization.renderers.three_renderer import ThreeRenderer\n            from word_manifold.visualization.engines.projection import ProjectionEngine\n            return ThreeRenderer, ProjectionEngine\n        except ImportError as e:\n            logger.error(f\"Failed to import visualization modules: {e}\")",
        "detail": "scripts.test_three",
        "documentation": {}
    },
    {
        "label": "ClusterWatcher",
        "kind": 6,
        "importPath": "scripts.watch_cluster",
        "description": "scripts.watch_cluster",
        "peekOfCode": "class ClusterWatcher(FileSystemEventHandler):\n    \"\"\"Watches for changes in cluster-related files and restarts processes.\"\"\"\n    def __init__(self):\n        self.cluster_process: Optional[subprocess.Popen] = None\n        self.last_restart = 0\n        self.restart_cooldown = 1.0  # Minimum seconds between restarts\n    def on_modified(self, event):\n        if event.src_path.endswith('.py'):\n            rel_path = Path(event.src_path).relative_to(Path.cwd())\n            if self._is_cluster_related(rel_path):",
        "detail": "scripts.watch_cluster",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.watch_cluster",
        "description": "scripts.watch_cluster",
        "peekOfCode": "def main():\n    \"\"\"Main entry point for the watch script.\"\"\"\n    src_path = Path('src/word_manifold')\n    if not src_path.exists():\n        logger.error(f\"Source directory not found: {src_path}\")\n        sys.exit(1)\n    # Set up file watcher\n    watcher = ClusterWatcher()\n    observer = Observer()\n    observer.schedule(watcher, str(src_path), recursive=True)",
        "detail": "scripts.watch_cluster",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "scripts.watch_cluster",
        "description": "scripts.watch_cluster",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ClusterWatcher(FileSystemEventHandler):\n    \"\"\"Watches for changes in cluster-related files and restarts processes.\"\"\"\n    def __init__(self):\n        self.cluster_process: Optional[subprocess.Popen] = None\n        self.last_restart = 0\n        self.restart_cooldown = 1.0  # Minimum seconds between restarts\n    def on_modified(self, event):\n        if event.src_path.endswith('.py'):\n            rel_path = Path(event.src_path).relative_to(Path.cwd())",
        "detail": "scripts.watch_cluster",
        "documentation": {}
    },
    {
        "label": "EmbeddingRequest",
        "kind": 6,
        "importPath": "src.word_manifold.api.models.embeddings",
        "description": "src.word_manifold.api.models.embeddings",
        "peekOfCode": "class EmbeddingRequest(BaseModel):\n    \"\"\"Request model for text embedding.\"\"\"\n    text: constr(min_length=1) = Field(..., description=\"Text to embed\")\n    model_name: Optional[str] = Field(\n        \"sentence-transformers/all-MiniLM-L6-v2\",\n        description=\"Name of the model to use for embedding\"\n    )\n    normalize: bool = Field(True, description=\"Whether to L2-normalize the embeddings\")\n    instruction: Optional[str] = Field(None, description=\"Optional instruction for embedding\")\nclass BatchEmbeddingRequest(BaseModel):",
        "detail": "src.word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "BatchEmbeddingRequest",
        "kind": 6,
        "importPath": "src.word_manifold.api.models.embeddings",
        "description": "src.word_manifold.api.models.embeddings",
        "peekOfCode": "class BatchEmbeddingRequest(BaseModel):\n    \"\"\"Request model for batch text embedding.\"\"\"\n    texts: List[constr(min_length=1)] = Field(..., description=\"List of texts to embed\")\n    model_name: Optional[str] = Field(\n        \"sentence-transformers/all-MiniLM-L6-v2\",\n        description=\"Name of the model to use for embedding\"\n    )\n    normalize: bool = Field(True, description=\"Whether to L2-normalize the embeddings\")\n    instruction: Optional[str] = Field(None, description=\"Optional instruction for embedding\")\n    batch_size: Optional[int] = Field(32, description=\"Batch size for processing\")",
        "detail": "src.word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "EmbeddingResponse",
        "kind": 6,
        "importPath": "src.word_manifold.api.models.embeddings",
        "description": "src.word_manifold.api.models.embeddings",
        "peekOfCode": "class EmbeddingResponse(BaseModel):\n    \"\"\"Response model for text embedding.\"\"\"\n    embedding: List[float] = Field(..., description=\"Embedding vector\")\n    model_name: str = Field(..., description=\"Model used for embedding\")\n    dimensions: int = Field(..., description=\"Dimensionality of embedding\")\n    metadata: Optional[Dict[str, Any]] = Field(None, description=\"Additional metadata\")\n    class Config:\n        json_encoders = {\n            np.ndarray: lambda x: x.tolist(),\n            np.float32: float,",
        "detail": "src.word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "BatchEmbeddingResponse",
        "kind": 6,
        "importPath": "src.word_manifold.api.models.embeddings",
        "description": "src.word_manifold.api.models.embeddings",
        "peekOfCode": "class BatchEmbeddingResponse(BaseModel):\n    \"\"\"Response model for batch text embedding.\"\"\"\n    embeddings: List[List[float]] = Field(..., description=\"List of embedding vectors\")\n    model_name: str = Field(..., description=\"Model used for embedding\")\n    dimensions: int = Field(..., description=\"Dimensionality of embeddings\")\n    metadata: Optional[Dict[str, Any]] = Field(None, description=\"Additional metadata\")\n    class Config:\n        json_encoders = {\n            np.ndarray: lambda x: x.tolist(),\n            np.float32: float,",
        "detail": "src.word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "SimilarityRequest",
        "kind": 6,
        "importPath": "src.word_manifold.api.models.embeddings",
        "description": "src.word_manifold.api.models.embeddings",
        "peekOfCode": "class SimilarityRequest(BaseModel):\n    \"\"\"Request model for computing text similarity.\"\"\"\n    text1: constr(min_length=1) = Field(..., description=\"First text\")\n    text2: constr(min_length=1) = Field(..., description=\"Second text\")\n    model_name: Optional[str] = Field(\n        \"sentence-transformers/all-MiniLM-L6-v2\",\n        description=\"Name of the model to use\"\n    )\n    metric: str = Field(\"cosine\", description=\"Similarity metric to use\")\nclass SimilarityResponse(BaseModel):",
        "detail": "src.word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "SimilarityResponse",
        "kind": 6,
        "importPath": "src.word_manifold.api.models.embeddings",
        "description": "src.word_manifold.api.models.embeddings",
        "peekOfCode": "class SimilarityResponse(BaseModel):\n    \"\"\"Response model for text similarity.\"\"\"\n    similarity: float = Field(..., description=\"Similarity score\")\n    model_name: str = Field(..., description=\"Model used for comparison\")\n    metric: str = Field(..., description=\"Similarity metric used\")\n    metadata: Optional[Dict[str, Any]] = Field(None, description=\"Additional metadata\")",
        "detail": "src.word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "get_provider",
        "kind": 2,
        "importPath": "src.word_manifold.api.routes.embeddings",
        "description": "src.word_manifold.api.routes.embeddings",
        "peekOfCode": "def get_provider(\n    model_name: str,\n    instruction: Optional[str] = None\n) -> TransformerEmbeddingProvider:\n    \"\"\"Get or create an embedding provider for the specified model.\"\"\"\n    if model_name not in _provider_cache:\n        device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n        if instruction is not None:\n            provider = InstructEmbeddingProvider(\n                model_name=model_name,",
        "detail": "src.word_manifold.api.routes.embeddings",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "src.word_manifold.api.routes.embeddings",
        "description": "src.word_manifold.api.routes.embeddings",
        "peekOfCode": "router = APIRouter(prefix=\"/embeddings\", tags=[\"embeddings\"])\n# Cache for embedding providers to avoid recreating them\n_provider_cache: Dict[str, TransformerEmbeddingProvider] = {}\ndef get_provider(\n    model_name: str,\n    instruction: Optional[str] = None\n) -> TransformerEmbeddingProvider:\n    \"\"\"Get or create an embedding provider for the specified model.\"\"\"\n    if model_name not in _provider_cache:\n        device = \"cuda\" if torch.cuda.is_available() else \"cpu\"",
        "detail": "src.word_manifold.api.routes.embeddings",
        "documentation": {}
    },
    {
        "label": "create_timeseries",
        "kind": 2,
        "importPath": "src.word_manifold.api.routes.visualizations",
        "description": "src.word_manifold.api.routes.visualizations",
        "peekOfCode": "def create_timeseries():\n    \"\"\"\n    Create time series visualization.\n    Request body:\n    {\n        \"terms\": [\"term1\", \"term2\", ...],\n        \"timeframe\": \"1d\",  # optional\n        \"interval\": \"1h\",   # optional\n        \"pattern_type\": \"cyclic\",  # optional\n        \"interactive\": true,  # optional",
        "detail": "src.word_manifold.api.routes.visualizations",
        "documentation": {}
    },
    {
        "label": "create_magic_structure",
        "kind": 2,
        "importPath": "src.word_manifold.api.routes.visualizations",
        "description": "src.word_manifold.api.routes.visualizations",
        "peekOfCode": "def create_magic_structure():\n    \"\"\"\n    Create magic structure visualization.\n    Request body:\n    {\n        \"dimension\": 2,\n        \"size\": 3,\n        \"terms\": [\"term1\", \"term2\", ...],  # optional\n        \"interactive\": true,  # optional\n        \"show_values\": true,  # optional",
        "detail": "src.word_manifold.api.routes.visualizations",
        "documentation": {}
    },
    {
        "label": "visualizations_bp",
        "kind": 5,
        "importPath": "src.word_manifold.api.routes.visualizations",
        "description": "src.word_manifold.api.routes.visualizations",
        "peekOfCode": "visualizations_bp = Blueprint('visualizations', __name__)\nlogger = logging.getLogger(__name__)\n@visualizations_bp.route('/timeseries', methods=['POST'])\ndef create_timeseries():\n    \"\"\"\n    Create time series visualization.\n    Request body:\n    {\n        \"terms\": [\"term1\", \"term2\", ...],\n        \"timeframe\": \"1d\",  # optional",
        "detail": "src.word_manifold.api.routes.visualizations",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.api.routes.visualizations",
        "description": "src.word_manifold.api.routes.visualizations",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@visualizations_bp.route('/timeseries', methods=['POST'])\ndef create_timeseries():\n    \"\"\"\n    Create time series visualization.\n    Request body:\n    {\n        \"terms\": [\"term1\", \"term2\", ...],\n        \"timeframe\": \"1d\",  # optional\n        \"interval\": \"1h\",   # optional",
        "detail": "src.word_manifold.api.routes.visualizations",
        "documentation": {}
    },
    {
        "label": "WordManifoldClient",
        "kind": 6,
        "importPath": "src.word_manifold.api.client",
        "description": "src.word_manifold.api.client",
        "peekOfCode": "class WordManifoldClient:\n    \"\"\"Client for interacting with Word Manifold API.\"\"\"\n    def __init__(\n        self,\n        base_url: str = \"http://localhost:5000\",\n        timeout: int = 30,\n        verify_ssl: bool = True\n    ):\n        \"\"\"\n        Initialize API client.",
        "detail": "src.word_manifold.api.client",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.api.client",
        "description": "src.word_manifold.api.client",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass WordManifoldClient:\n    \"\"\"Client for interacting with Word Manifold API.\"\"\"\n    def __init__(\n        self,\n        base_url: str = \"http://localhost:5000\",\n        timeout: int = 30,\n        verify_ssl: bool = True\n    ):\n        \"\"\"",
        "detail": "src.word_manifold.api.client",
        "documentation": {}
    },
    {
        "label": "create_celestial_rules",
        "kind": 2,
        "importPath": "src.word_manifold.automata.additional_rules",
        "description": "src.word_manifold.automata.additional_rules",
        "peekOfCode": "def create_celestial_rules() -> Dict[str, CellularRule]:\n    \"\"\"\n    Create rules based on celestial bodies and higher spiritual archetypes.\n    These rules complement the base rule set by adding transformations\n    related to cosmic forces and stellar/planetary influences.\n    Returns:\n        Dictionary mapping rule names to CellularRule objects\n    \"\"\"\n    rules = {}",
        "detail": "src.word_manifold.automata.additional_rules",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.automata.additional_rules",
        "description": "src.word_manifold.automata.additional_rules",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef create_celestial_rules() -> Dict[str, CellularRule]:\n    \"\"\"\n    Create rules based on celestial bodies and higher spiritual archetypes.\n    These rules complement the base rule set by adding transformations\n    related to cosmic forces and stellar/planetary influences.\n    Returns:\n        Dictionary mapping rule names to CellularRule objects\n    \"\"\"\n    rules = {}",
        "detail": "src.word_manifold.automata.additional_rules",
        "documentation": {}
    },
    {
        "label": "HermeticPrinciple",
        "kind": 6,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "class HermeticPrinciple(Enum):\n    \"\"\"The seven Hermetic principles that govern transformation rules.\"\"\"\n    MENTALISM = auto()         # \"THE ALL is MIND; The Universe is Mental.\"\n    CORRESPONDENCE = auto()    # \"As above, so below; as below, so above.\"\n    VIBRATION = auto()         # \"Nothing rests; everything moves; everything vibrates.\"\n    POLARITY = auto()          # \"Everything is Dual; everything has poles.\"\n    RHYTHM = auto()            # \"Everything flows, out and in; everything has its tides.\"\n    CAUSE_EFFECT = auto()      # \"Every Cause has its Effect; Every Effect has its Cause.\"\n    GENDER = auto()            # \"Gender is in everything; everything has its Masculine and Feminine.\"\nclass ElementalForce(Enum):",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "ElementalForce",
        "kind": 6,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "class ElementalForce(Enum):\n    \"\"\"The four elemental forces that influence transformation.\"\"\"\n    EARTH = auto()  # Stability, materiality, resistance to change\n    AIR = auto()    # Intellect, communication, adaptability\n    FIRE = auto()   # Energy, transformation, creation/destruction\n    WATER = auto()  # Emotion, intuition, connection\nclass VibrationDirection(Enum):\n    \"\"\"Possible directions of vibrational change in the vector space.\"\"\"\n    ASCENDING = auto()  # Moving towards higher vibration (complexity, abstraction)\n    DESCENDING = auto() # Moving towards lower vibration (simplicity, concreteness)",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "VibrationDirection",
        "kind": 6,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "class VibrationDirection(Enum):\n    \"\"\"Possible directions of vibrational change in the vector space.\"\"\"\n    ASCENDING = auto()  # Moving towards higher vibration (complexity, abstraction)\n    DESCENDING = auto() # Moving towards lower vibration (simplicity, concreteness)\n    EXPANDING = auto()  # Increasing in scope or influence\n    CONTRACTING = auto() # Decreasing in scope or influence\n    HARMONIZING = auto() # Moving towards balance with neighbors\n    POLARIZING = auto()  # Moving away from neighbors, increasing distinction\n@dataclass\nclass RuleParameterSet:",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleParameterSet",
        "kind": 6,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "class RuleParameterSet:\n    \"\"\"Parameters that define how a transformation rule behaves.\"\"\"\n    magnitude: float = 1.0                  # Base strength of transformation\n    principle: HermeticPrinciple = HermeticPrinciple.CORRESPONDENCE\n    elemental_influence: Dict[ElementalForce, float] = None  # Influence of each element\n    numerological_weights: Dict[int, float] = None  # Weights by numerological value\n    cell_type_weights: Dict[CellType, float] = None  # Weights by cell type\n    vibration_direction: VibrationDirection = VibrationDirection.HARMONIZING\n    def __init__(self, magnitude=1.0, principle=None, vibration_direction=None,\n                 numerological_weights=None, elemental_influence=None, cell_type_weights=None):",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "CellularRule",
        "kind": 6,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "class CellularRule:\n    \"\"\"\n    A rule that defines how cells transform in the vector space.\n    Each rule embodies one or more hermetic principles and governs \n    the evolution of the cellular automata system.\n    \"\"\"\n    def __init__(\n        self, \n        name: str, \n        description: str,",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleSequence",
        "kind": 6,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "class RuleSequence:\n    \"\"\"\n    A sequence of cellular automata rules to be applied in a specific order.\n    The sequence can be applied in different ways:\n    - Sequentially (default): Rules are applied in order\n    - Conditionally: Rules are applied based on conditions\n    - With branching: Different paths can be taken based on state\n    The sequence also supports:\n    - Dependencies between rules\n    - Conditions for rule application",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "kind": 2,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "def create_predefined_rules() -> Dict[str, CellularRule]:\n    \"\"\"\n    Create a set of predefined cellular automata rules based on\n    hermetic principles and occult correspondences.\n    Returns:\n        Dictionary mapping rule names to CellularRule objects\n    \"\"\"\n    rules = {}\n    # The Great Work Rule - Based on alchemical transformation\n    great_work_params = RuleParameterSet(",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_sequences",
        "kind": 2,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "def create_predefined_sequences() -> Dict[str, RuleSequence]:\n    \"\"\"\n    Create a set of predefined rule sequences based on\n    magical rituals and occult correspondences.\n    Returns:\n        Dictionary mapping sequence names to RuleSequence objects\n    \"\"\"\n    rules = create_predefined_rules()\n    sequences = {}\n    # The Great Work Sequence - Alchemical transformation from base to divine",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HermeticPrinciple(Enum):\n    \"\"\"The seven Hermetic principles that govern transformation rules.\"\"\"\n    MENTALISM = auto()         # \"THE ALL is MIND; The Universe is Mental.\"\n    CORRESPONDENCE = auto()    # \"As above, so below; as below, so above.\"\n    VIBRATION = auto()         # \"Nothing rests; everything moves; everything vibrates.\"\n    POLARITY = auto()          # \"Everything is Dual; everything has poles.\"\n    RHYTHM = auto()            # \"Everything flows, out and in; everything has its tides.\"\n    CAUSE_EFFECT = auto()      # \"Every Cause has its Effect; Every Effect has its Cause.\"\n    GENDER = auto()            # \"Gender is in everything; everything has its Masculine and Feminine.\"",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "HermeticPrinciple",
        "kind": 6,
        "importPath": "src.word_manifold.automata.hermetic_principles",
        "description": "src.word_manifold.automata.hermetic_principles",
        "peekOfCode": "class HermeticPrinciple(Enum):\n    \"\"\"The seven hermetic principles from the Kybalion.\"\"\"\n    MENTALISM = auto()      # \"The All is Mind; The Universe is Mental.\"\n    CORRESPONDENCE = auto() # \"As above, so below; as below, so above.\"\n    VIBRATION = auto()     # \"Nothing rests; everything moves; everything vibrates.\"\n    POLARITY = auto()      # \"Everything is dual; everything has poles.\"\n    RHYTHM = auto()        # \"Everything flows, out and in; everything has its tides.\"\n    CAUSATION = auto()     # \"Every cause has its effect; every effect has its cause.\"\n    GENDER = auto()        # \"Gender is in everything; everything has its masculine and feminine principles.\"\n# Principle associations and correspondences",
        "detail": "src.word_manifold.automata.hermetic_principles",
        "documentation": {}
    },
    {
        "label": "Line",
        "kind": 6,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "class Line(Enum):\n    \"\"\"I Ching line types.\"\"\"\n    YIN = 0   # Broken line \n    YANG = 1  # Solid line \nclass CastingMethod(Enum):\n    \"\"\"Methods for casting hexagrams.\"\"\"\n    YARROW_STALKS = \"yarrow\"  # Traditional 50 yarrow stalks method\n    COINS = \"coins\"           # Three coins method\n    ORACLE_BONES = \"bones\"    # Ancient oracle bone method\n@dataclass",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "CastingMethod",
        "kind": 6,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "class CastingMethod(Enum):\n    \"\"\"Methods for casting hexagrams.\"\"\"\n    YARROW_STALKS = \"yarrow\"  # Traditional 50 yarrow stalks method\n    COINS = \"coins\"           # Three coins method\n    ORACLE_BONES = \"bones\"    # Ancient oracle bone method\n@dataclass\nclass Hexagram:\n    \"\"\"Represents an I Ching hexagram.\"\"\"\n    number: int  # 1-64\n    lines: List[Line]  # Bottom to top",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "Hexagram",
        "kind": 6,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "class Hexagram:\n    \"\"\"Represents an I Ching hexagram.\"\"\"\n    number: int  # 1-64\n    lines: List[Line]  # Bottom to top\n    name: str\n    attribute: str\n    image: str\n    nuclear_hexagram: Optional['Hexagram'] = None\n    opposite_hexagram: Optional['Hexagram'] = None\n    @property",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "HexagramRule",
        "kind": 6,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "class HexagramRule(CellularRule):\n    \"\"\"\n    A cellular automata rule based on I Ching hexagram transformations.\n    Each rule embodies the transformative principles of a specific hexagram,\n    applying its wisdom to vector space evolution.\n    \"\"\"\n    def __init__(\n        self,\n        hexagram: Hexagram,\n        parameters: Optional[RuleParameterSet] = None,",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "cast_hexagram",
        "kind": 2,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "def cast_hexagram(method: CastingMethod = CastingMethod.ORACLE_BONES) -> Tuple[Hexagram, List[int]]:\n    \"\"\"\n    Cast a hexagram using the specified method.\n    Args:\n        method: The divination method to use\n    Returns:\n        Tuple of (resulting hexagram, list of changing lines)\n    \"\"\"\n    lines = []\n    changing_lines = []",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "get_default_text",
        "kind": 2,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "def get_default_text() -> str:\n    \"\"\"Get default text for oracle readings.\"\"\"\n    return random.choice(DEFAULT_TEXTS['mystical'])\nclass HexagramRule(CellularRule):\n    \"\"\"\n    A cellular automata rule based on I Ching hexagram transformations.\n    Each rule embodies the transformative principles of a specific hexagram,\n    applying its wisdom to vector space evolution.\n    \"\"\"\n    def __init__(",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "create_hexagram_rules",
        "kind": 2,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "def create_hexagram_rules() -> Dict[str, HexagramRule]:\n    \"\"\"Create the complete set of 64 hexagram-based rules.\"\"\"\n    rules = {}\n    # Create rules for each hexagram\n    for hexagram in hexagram_lookup.values():\n        rule = HexagramRule(hexagram)\n        rules[rule.name] = rule\n    return rules\n# Initialize hexagram lookup table with complete set\nhexagram_lookup: Dict[int, Hexagram] = {",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "nuclear_lines_to_number",
        "kind": 2,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "def nuclear_lines_to_number(lines: List[Line]) -> int:\n    \"\"\"Convert nuclear hexagram lines to hexagram number.\"\"\"\n    # Implementation to convert lines to hexagram number\n    return sum(line.value << i for i, line in enumerate(lines)) + 1",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TEXTS",
        "kind": 5,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "DEFAULT_TEXTS = {\n    'hermetic': [\n        \"As above, so below; as below, so above.\",\n        \"All is mind; the universe is mental.\",\n        \"Nothing rests; everything moves; everything vibrates.\",\n        \"Everything is dual; everything has poles.\",\n        \"Everything flows, out and in; everything has its tides.\",\n    ],\n    'alchemical': [\n        \"Solve et Coagula\",",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "kind": 6,
        "importPath": "src.word_manifold.automata.system",
        "description": "src.word_manifold.automata.system",
        "peekOfCode": "class EvolutionPattern(Enum):\n    \"\"\"Patterns of evolution that the automata system can follow.\"\"\"\n    LINEAR = auto()      # Sequential application of rules\n    CYCLIC = auto()      # Repeated application of rules in a cycle\n    SPIRAL = auto()      # Cyclic with increasing intensity\n    CHAOTIC = auto()     # Random selection of rules\n    THELEMIC = auto()    # Rules selected based on True Will principle\n    KABBALISTIC = auto() # Rules follow Tree of Life pattern\n@dataclass\nclass SystemState:",
        "detail": "src.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "SystemState",
        "kind": 6,
        "importPath": "src.word_manifold.automata.system",
        "description": "src.word_manifold.automata.system",
        "peekOfCode": "class SystemState:\n    \"\"\"State of the automata system at a point in time.\"\"\"\n    generation: int                # Current generation number\n    active_rules: List[str]        # Names of rules currently active\n    manifold_state: Dict[str, Any] # State snapshot of the manifold\n    timestamp: float               # Unix timestamp when state was captured\n    metrics: Dict[str, float]      # Metrics about the system's state\nclass AutomataSystem:\n    \"\"\"\n    A system that orchestrates the application of cellular automata rules",
        "detail": "src.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "kind": 6,
        "importPath": "src.word_manifold.automata.system",
        "description": "src.word_manifold.automata.system",
        "peekOfCode": "class AutomataSystem:\n    \"\"\"\n    A system that orchestrates the application of cellular automata rules\n    to a word vector manifold according to hermetic principles.\n    This class manages the evolution of the manifold through generations,\n    applying rules according to specified patterns and tracking the system's\n    state over time.\n    \"\"\"\n    def __init__(\n        self,",
        "detail": "src.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.automata.system",
        "description": "src.word_manifold.automata.system",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass EvolutionPattern(Enum):\n    \"\"\"Patterns of evolution that the automata system can follow.\"\"\"\n    LINEAR = auto()      # Sequential application of rules\n    CYCLIC = auto()      # Repeated application of rules in a cycle\n    SPIRAL = auto()      # Cyclic with increasing intensity\n    CHAOTIC = auto()     # Random selection of rules\n    THELEMIC = auto()    # Rules selected based on True Will principle\n    KABBALISTIC = auto() # Rules follow Tree of Life pattern\n@dataclass",
        "detail": "src.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "magic",
        "kind": 2,
        "importPath": "src.word_manifold.cli.commands.magic",
        "description": "src.word_manifold.cli.commands.magic",
        "peekOfCode": "def magic(\n    dimension: int,\n    size: int,\n    terms: List[str],\n    output_dir: str,\n    interactive: bool,\n    show_values: bool,\n    show_connections: bool,\n    color_scheme: str,\n    semantic_weighting: bool,",
        "detail": "src.word_manifold.cli.commands.magic",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.cli.commands.magic",
        "description": "src.word_manifold.cli.commands.magic",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@click.command()\n@click.option(\n    '--dimension', '-d',\n    type=int,\n    default=2,\n    help='Number of dimensions for the magic structure (default: 2)'\n)\n@click.option(\n    '--size', '-s',",
        "detail": "src.word_manifold.cli.commands.magic",
        "documentation": {}
    },
    {
        "label": "coro",
        "kind": 2,
        "importPath": "src.word_manifold.cli.commands.ray_cluster",
        "description": "src.word_manifold.cli.commands.ray_cluster",
        "peekOfCode": "def coro(f):\n    \"\"\"Decorator to run async functions in click commands.\"\"\"\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        return asyncio.run(f(*args, **kwargs))\n    return wrapper\n@click.group()\ndef cli():\n    \"\"\"Ray cluster management commands.\"\"\"\n    pass",
        "detail": "src.word_manifold.cli.commands.ray_cluster",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 2,
        "importPath": "src.word_manifold.cli.commands.ray_cluster",
        "description": "src.word_manifold.cli.commands.ray_cluster",
        "peekOfCode": "def cli():\n    \"\"\"Ray cluster management commands.\"\"\"\n    pass\n@cli.command()\n@click.option('--mode', type=click.Choice(['auto', 'head', 'worker']), default='auto',\n              help='Node mode (auto detects if not specified)')\n@click.option('--port', default=6379, help='Port for Ray head node')\n@click.option('--dashboard-port', default=8265, help='Port for Ray dashboard')\n@click.option('--log-dir', type=click.Path(), help='Directory for logs')\n@click.option('--resources', type=str, help='JSON string of resource specifications')",
        "detail": "src.word_manifold.cli.commands.ray_cluster",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "src.word_manifold.cli.commands.ray_cluster",
        "description": "src.word_manifold.cli.commands.ray_cluster",
        "peekOfCode": "def run():\n    \"\"\"Entry point for the CLI.\"\"\"\n    try:\n        cli()\n    except KeyboardInterrupt:\n        console.print(\"\\n[yellow]Operation cancelled by user[/yellow]\")\n    except Exception as e:\n        logger.error(f\"Unexpected error: {e}\")\n        raise click.ClickException(str(e))\nif __name__ == '__main__':",
        "detail": "src.word_manifold.cli.commands.ray_cluster",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "src.word_manifold.cli.commands.ray_cluster",
        "description": "src.word_manifold.cli.commands.ray_cluster",
        "peekOfCode": "console = Console()\nlogger = logging.getLogger(__name__)\ndef coro(f):\n    \"\"\"Decorator to run async functions in click commands.\"\"\"\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        return asyncio.run(f(*args, **kwargs))\n    return wrapper\n@click.group()\ndef cli():",
        "detail": "src.word_manifold.cli.commands.ray_cluster",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.cli.commands.ray_cluster",
        "description": "src.word_manifold.cli.commands.ray_cluster",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef coro(f):\n    \"\"\"Decorator to run async functions in click commands.\"\"\"\n    @functools.wraps(f)\n    def wrapper(*args, **kwargs):\n        return asyncio.run(f(*args, **kwargs))\n    return wrapper\n@click.group()\ndef cli():\n    \"\"\"Ray cluster management commands.\"\"\"",
        "detail": "src.word_manifold.cli.commands.ray_cluster",
        "documentation": {}
    },
    {
        "label": "ray_cli",
        "kind": 2,
        "importPath": "src.word_manifold.cli.commands.ray_monitor",
        "description": "src.word_manifold.cli.commands.ray_monitor",
        "peekOfCode": "def ray_cli():\n    \"\"\"Ray service management and monitoring commands.\"\"\"\n    pass\n@ray_cli.command()\n@click.option('--dashboard-port', default=8265, help='Port for Ray dashboard')\n@click.option('--log-dir', type=click.Path(), help='Directory for monitoring logs')\n@click.option('--open-browser/--no-open-browser', default=True, help='Open dashboard in browser')\ndef start(dashboard_port: int, log_dir: Optional[str], open_browser: bool):\n    \"\"\"Start Ray monitoring dashboard.\"\"\"\n    try:",
        "detail": "src.word_manifold.cli.commands.ray_monitor",
        "documentation": {}
    },
    {
        "label": "start",
        "kind": 2,
        "importPath": "src.word_manifold.cli.commands.ray_monitor",
        "description": "src.word_manifold.cli.commands.ray_monitor",
        "peekOfCode": "def start(dashboard_port: int, log_dir: Optional[str], open_browser: bool):\n    \"\"\"Start Ray monitoring dashboard.\"\"\"\n    try:\n        monitor = RayDebugMonitor(\n            dashboard_port=dashboard_port,\n            log_dir=Path(log_dir) if log_dir else None\n        )\n        monitor.start()\n        if open_browser:\n            webbrowser.open(f\"http://localhost:{dashboard_port}\")",
        "detail": "src.word_manifold.cli.commands.ray_monitor",
        "documentation": {}
    },
    {
        "label": "status",
        "kind": 2,
        "importPath": "src.word_manifold.cli.commands.ray_monitor",
        "description": "src.word_manifold.cli.commands.ray_monitor",
        "peekOfCode": "def status(service: Optional[str], log_dir: Optional[str]):\n    \"\"\"Show detailed status of Ray services.\"\"\"\n    try:\n        monitor = RayDebugMonitor(\n            log_dir=Path(log_dir) if log_dir else None\n        )\n        if service:\n            # Show detailed info for specific service\n            service_info = monitor.get_service_info(service)\n            if service_info:",
        "detail": "src.word_manifold.cli.commands.ray_monitor",
        "documentation": {}
    },
    {
        "label": "stop",
        "kind": 2,
        "importPath": "src.word_manifold.cli.commands.ray_monitor",
        "description": "src.word_manifold.cli.commands.ray_monitor",
        "peekOfCode": "def stop(service: str):\n    \"\"\"Stop a Ray service.\"\"\"\n    try:\n        monitor = RayDebugMonitor()\n        service_info = monitor.get_service_info(service)\n        if service_info:\n            monitor.unregister_service(service)\n            console.print(f\"[green]Successfully stopped service {service}[/green]\")\n        else:\n            console.print(f\"[red]Service {service} not found[/red]\")",
        "detail": "src.word_manifold.cli.commands.ray_monitor",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "src.word_manifold.cli.commands.ray_monitor",
        "description": "src.word_manifold.cli.commands.ray_monitor",
        "peekOfCode": "console = Console()\nlogger = logging.getLogger(__name__)\n@click.group()\ndef ray_cli():\n    \"\"\"Ray service management and monitoring commands.\"\"\"\n    pass\n@ray_cli.command()\n@click.option('--dashboard-port', default=8265, help='Port for Ray dashboard')\n@click.option('--log-dir', type=click.Path(), help='Directory for monitoring logs')\n@click.option('--open-browser/--no-open-browser', default=True, help='Open dashboard in browser')",
        "detail": "src.word_manifold.cli.commands.ray_monitor",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.cli.commands.ray_monitor",
        "description": "src.word_manifold.cli.commands.ray_monitor",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@click.group()\ndef ray_cli():\n    \"\"\"Ray service management and monitoring commands.\"\"\"\n    pass\n@ray_cli.command()\n@click.option('--dashboard-port', default=8265, help='Port for Ray dashboard')\n@click.option('--log-dir', type=click.Path(), help='Directory for monitoring logs')\n@click.option('--open-browser/--no-open-browser', default=True, help='Open dashboard in browser')\ndef start(dashboard_port: int, log_dir: Optional[str], open_browser: bool):",
        "detail": "src.word_manifold.cli.commands.ray_monitor",
        "documentation": {}
    },
    {
        "label": "RayCloudManager",
        "kind": 6,
        "importPath": "src.word_manifold.cloud.ray_cloud",
        "description": "src.word_manifold.cloud.ray_cloud",
        "peekOfCode": "class RayCloudManager:\n    \"\"\"Manages Ray Cloud deployment and scaling.\"\"\"\n    def __init__(\n        self,\n        config_path: Optional[str] = None,\n        project_id: Optional[str] = None,\n        cluster_name: str = \"wordmanifold-cluster\"\n    ):\n        self.config_path = config_path or \"ray_config.yaml\"\n        self.project_id = project_id or os.getenv(\"RAY_PROJECT_ID\")",
        "detail": "src.word_manifold.cloud.ray_cloud",
        "documentation": {}
    },
    {
        "label": "init_ray_cloud",
        "kind": 2,
        "importPath": "src.word_manifold.cloud.ray_cloud",
        "description": "src.word_manifold.cloud.ray_cloud",
        "peekOfCode": "def init_ray_cloud(config_path: Optional[str] = None) -> RayCloudManager:\n    \"\"\"Initialize Ray Cloud deployment.\"\"\"\n    manager = RayCloudManager(config_path=config_path)\n    if manager.setup_cloud_cluster():\n        if manager.setup_cloud_monitoring():\n            return manager\n    raise RuntimeError(\"Failed to initialize Ray Cloud\")",
        "detail": "src.word_manifold.cloud.ray_cloud",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.cloud.ray_cloud",
        "description": "src.word_manifold.cloud.ray_cloud",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass RayCloudManager:\n    \"\"\"Manages Ray Cloud deployment and scaling.\"\"\"\n    def __init__(\n        self,\n        config_path: Optional[str] = None,\n        project_id: Optional[str] = None,\n        cluster_name: str = \"wordmanifold-cluster\"\n    ):\n        self.config_path = config_path or \"ray_config.yaml\"",
        "detail": "src.word_manifold.cloud.ray_cloud",
        "documentation": {}
    },
    {
        "label": "LoggingSettings",
        "kind": 6,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "class LoggingSettings(BaseSettings):\n    \"\"\"Logging configuration settings.\"\"\"\n    level: str = \"INFO\"\n    format: str = \"%(asctime)s - %(name)s - [%(levelname)s] - %(message)s\"\n    file: Optional[Path] = None\n    max_size: str = \"10MB\"\n    backup_count: int = 5\n    class Config:\n        env_prefix = \"WM_LOG_\"\nclass SecuritySettings(BaseSettings):",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "SecuritySettings",
        "kind": 6,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "class SecuritySettings(BaseSettings):\n    \"\"\"Security and authentication settings.\"\"\"\n    enable_cors: bool = True\n    allowed_origins: List[str] = [\"*\"]\n    require_auth: bool = False\n    api_key: Optional[str] = None\n    jwt_secret: Optional[str] = None\n    jwt_algorithm: str = \"HS256\"\n    class Config:\n        env_prefix = \"WM_SECURITY_\"",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "ServerSettings",
        "kind": 6,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "class ServerSettings(BaseSettings):\n    \"\"\"Server configuration settings.\"\"\"\n    host: str = \"localhost\"\n    port: int = 5000\n    workers: int = 4\n    debug: bool = False\n    timeout: int = 30\n    reload: bool = False\n    class Config:\n        env_prefix = \"WM_SERVER_\"",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "ModelSettings",
        "kind": 6,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "class ModelSettings(BaseSettings):\n    \"\"\"ML model configuration settings.\"\"\"\n    embedding_model: str = \"sentence-transformers/all-MiniLM-L6-v2\"\n    emotion_model: str = \"j-hartmann/emotion-english-distilroberta-base\"\n    spacy_model: str = \"en_core_web_lg\"\n    device: str = Field(default_factory=lambda: \"cuda\" if torch.cuda.is_available() else \"cpu\")\n    batch_size: int = 32\n    max_sequence_length: int = 512\n    cache_dir: Optional[Path] = None\n    class Config:",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "CacheSettings",
        "kind": 6,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "class CacheSettings(BaseSettings):\n    \"\"\"Cache configuration settings.\"\"\"\n    enable: bool = True\n    type: str = \"memory\"  # memory, redis, filesystem\n    max_size: int = 10000\n    ttl: int = 3600  # seconds\n    redis_url: Optional[str] = None\n    filesystem_path: Optional[Path] = None\n    class Config:\n        env_prefix = \"WM_CACHE_\"",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "Settings",
        "kind": 6,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "class Settings(BaseSettings):\n    \"\"\"Main configuration settings.\"\"\"\n    app_name: str = \"word-manifold\"\n    version: str = \"0.1.0\"\n    debug: bool = False\n    environment: str = \"development\"\n    # Nested configurations\n    logging: LoggingSettings = LoggingSettings()\n    security: SecuritySettings = SecuritySettings()\n    server: ServerSettings = ServerSettings()",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "settings = Settings()",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "EmbeddingMetadata",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class EmbeddingMetadata:\n    \"\"\"Metadata for an embedding.\"\"\"\n    model_name: str\n    dimensions: int\n    created_at: float\n    version: str = \"1.0.0\"\n@dataclass\nclass EmbeddingResult(Generic[T_co]):\n    \"\"\"Result of an embedding operation.\"\"\"\n    vector: EmbeddingVector",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "EmbeddingResult",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class EmbeddingResult(Generic[T_co]):\n    \"\"\"Result of an embedding operation.\"\"\"\n    vector: EmbeddingVector\n    metadata: EmbeddingMetadata\n    extra: Optional[T_co] = None\nclass EmbeddingError(Exception):\n    \"\"\"Base class for embedding-related errors.\"\"\"\n    pass\nclass ModelLoadError(EmbeddingError):\n    \"\"\"Error loading embedding model.\"\"\"",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "EmbeddingError",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class EmbeddingError(Exception):\n    \"\"\"Base class for embedding-related errors.\"\"\"\n    pass\nclass ModelLoadError(EmbeddingError):\n    \"\"\"Error loading embedding model.\"\"\"\n    pass\nclass EmbeddingProvider(Protocol):\n    \"\"\"Protocol defining the interface for embedding providers.\"\"\"\n    @property\n    def dimensions(self) -> int:",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "ModelLoadError",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class ModelLoadError(EmbeddingError):\n    \"\"\"Error loading embedding model.\"\"\"\n    pass\nclass EmbeddingProvider(Protocol):\n    \"\"\"Protocol defining the interface for embedding providers.\"\"\"\n    @property\n    def dimensions(self) -> int:\n        \"\"\"Get the dimensionality of the embeddings.\"\"\"\n        ...\n    @property",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "EmbeddingProvider",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class EmbeddingProvider(Protocol):\n    \"\"\"Protocol defining the interface for embedding providers.\"\"\"\n    @property\n    def dimensions(self) -> int:\n        \"\"\"Get the dimensionality of the embeddings.\"\"\"\n        ...\n    @property\n    def model_name(self) -> str:\n        \"\"\"Get the name of the embedding model.\"\"\"\n        ...",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "BaseEmbeddingProvider",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class BaseEmbeddingProvider(ABC):\n    \"\"\"Abstract base class for embedding providers.\"\"\"\n    def __init__(\n        self,\n        model_name: str,\n        device: Optional[torch.device] = None,\n        cache_dir: Optional[Path] = None,\n        **kwargs: Any\n    ):\n        self.model_name = model_name",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "CachedEmbeddingProvider",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class CachedEmbeddingProvider:\n    \"\"\"Decorator class for adding caching to embedding providers.\"\"\"\n    def __init__(\n        self,\n        provider: EmbeddingProvider,\n        cache_size: int = 10000,\n        ttl: Optional[int] = None\n    ):\n        self.provider = provider\n        self.cache: Dict[str, tuple[float, EmbeddingResult]] = {}",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "T_co",
        "kind": 5,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "T_co = TypeVar(\"T_co\", covariant=True)\nEmbeddingVector = npt.NDArray[np.float32]\n@dataclass\nclass EmbeddingMetadata:\n    \"\"\"Metadata for an embedding.\"\"\"\n    model_name: str\n    dimensions: int\n    created_at: float\n    version: str = \"1.0.0\"\n@dataclass",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "EmbeddingVector",
        "kind": 5,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "EmbeddingVector = npt.NDArray[np.float32]\n@dataclass\nclass EmbeddingMetadata:\n    \"\"\"Metadata for an embedding.\"\"\"\n    model_name: str\n    dimensions: int\n    created_at: float\n    version: str = \"1.0.0\"\n@dataclass\nclass EmbeddingResult(Generic[T_co]):",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "TransformerEmbeddingProvider",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.transformers",
        "description": "src.word_manifold.core.embeddings.transformers",
        "peekOfCode": "class TransformerEmbeddingProvider(BaseEmbeddingProvider):\n    \"\"\"Embedding provider using sentence-transformers models.\"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",\n        device: Optional[torch.device] = None,\n        cache_dir: Optional[Path] = None,\n        max_seq_length: int = 512,\n        normalize_embeddings: bool = True,\n        **kwargs: Any",
        "detail": "src.word_manifold.core.embeddings.transformers",
        "documentation": {}
    },
    {
        "label": "InstructEmbeddingProvider",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.transformers",
        "description": "src.word_manifold.core.embeddings.transformers",
        "peekOfCode": "class InstructEmbeddingProvider(TransformerEmbeddingProvider):\n    \"\"\"Embedding provider with instruction tuning support.\"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",\n        instruction: str = \"Represent this text for retrieval:\",\n        **kwargs: Any\n    ):\n        \"\"\"Initialize the instruction-tuned embedding provider.\n        Args:",
        "detail": "src.word_manifold.core.embeddings.transformers",
        "documentation": {}
    },
    {
        "label": "MultilingualEmbeddingProvider",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.transformers",
        "description": "src.word_manifold.core.embeddings.transformers",
        "peekOfCode": "class MultilingualEmbeddingProvider(TransformerEmbeddingProvider):\n    \"\"\"Embedding provider with multilingual support.\"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2\",\n        **kwargs: Any\n    ):\n        \"\"\"Initialize the multilingual embedding provider.\"\"\"\n        super().__init__(model_name=model_name, **kwargs)\n    async def translate_and_embed(self, text: str, source_lang: str) -> EmbeddingResult:",
        "detail": "src.word_manifold.core.embeddings.transformers",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.core.embeddings.transformers",
        "description": "src.word_manifold.core.embeddings.transformers",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass TransformerEmbeddingProvider(BaseEmbeddingProvider):\n    \"\"\"Embedding provider using sentence-transformers models.\"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",\n        device: Optional[torch.device] = None,\n        cache_dir: Optional[Path] = None,\n        max_seq_length: int = 512,\n        normalize_embeddings: bool = True,",
        "detail": "src.word_manifold.core.embeddings.transformers",
        "documentation": {}
    },
    {
        "label": "WaveShape",
        "kind": 6,
        "importPath": "src.word_manifold.core.audio",
        "description": "src.word_manifold.core.audio",
        "peekOfCode": "class WaveShape(Enum):\n    \"\"\"Different wave shapes for audio generation.\"\"\"\n    SINE = \"sine\"\n    TRIANGLE = \"triangle\"\n    SQUARE = \"square\"\n    SAWTOOTH = \"sawtooth\"\n    PULSE = \"pulse\"\nclass ModulationType(Enum):\n    \"\"\"Types of modulation to apply.\"\"\"\n    AMPLITUDE = \"amplitude\"",
        "detail": "src.word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "ModulationType",
        "kind": 6,
        "importPath": "src.word_manifold.core.audio",
        "description": "src.word_manifold.core.audio",
        "peekOfCode": "class ModulationType(Enum):\n    \"\"\"Types of modulation to apply.\"\"\"\n    AMPLITUDE = \"amplitude\"\n    FREQUENCY = \"frequency\"\n    PHASE = \"phase\"\n    RING = \"ring\"\n@dataclass\nclass AudioParams:\n    sample_rate: int = 44100\n    duration: float = 10.0  # seconds",
        "detail": "src.word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "AudioParams",
        "kind": 6,
        "importPath": "src.word_manifold.core.audio",
        "description": "src.word_manifold.core.audio",
        "peekOfCode": "class AudioParams:\n    sample_rate: int = 44100\n    duration: float = 10.0  # seconds\n    base_freq: float = 432.0  # Hz\n    harmonics: List[float] = None\n    ratios: List[float] = None\n    amplitude: float = 0.5\n    fade_duration: float = 0.1  # seconds for fade in/out\n    wave_shape: WaveShape = WaveShape.SINE\n    modulation_type: ModulationType = ModulationType.AMPLITUDE",
        "detail": "src.word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "generate_wave",
        "kind": 2,
        "importPath": "src.word_manifold.core.audio",
        "description": "src.word_manifold.core.audio",
        "peekOfCode": "def generate_wave(t: np.ndarray, freq: float, shape: WaveShape, amplitude: float = 1.0, \n                 pulse_width: float = 0.5, phase: float = 0.0) -> np.ndarray:\n    \"\"\"Generate different wave shapes.\"\"\"\n    phase_term = 2 * np.pi * freq * t + phase\n    if shape == WaveShape.SINE:\n        return amplitude * np.sin(phase_term)\n    elif shape == WaveShape.TRIANGLE:\n        return amplitude * (2/np.pi) * np.arcsin(np.sin(phase_term))\n    elif shape == WaveShape.SQUARE:\n        return amplitude * np.sign(np.sin(phase_term))",
        "detail": "src.word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "generate_sacred_audio",
        "kind": 2,
        "importPath": "src.word_manifold.core.audio",
        "description": "src.word_manifold.core.audio",
        "peekOfCode": "def generate_sacred_audio(params: AudioParams) -> Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Generate audio based on sacred geometry principles.\n    Args:\n        params: AudioParams object containing generation parameters\n    Returns:\n        Tuple of (time_array, audio_data)\n    \"\"\"\n    # Create time array\n    t = np.linspace(0, params.duration, int(params.sample_rate * params.duration))",
        "detail": "src.word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "get_audio_features",
        "kind": 2,
        "importPath": "src.word_manifold.core.audio",
        "description": "src.word_manifold.core.audio",
        "peekOfCode": "def get_audio_features(audio_data: np.ndarray, sample_rate: int, window_size: int = 2048) -> dict:\n    \"\"\"\n    Extract audio features from a segment of audio data.\n    Args:\n        audio_data: Audio signal array\n        sample_rate: Sample rate in Hz\n        window_size: Size of the FFT window\n    Returns:\n        Dictionary containing audio features:\n        - amplitude: RMS amplitude",
        "detail": "src.word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "save_audio",
        "kind": 2,
        "importPath": "src.word_manifold.core.audio",
        "description": "src.word_manifold.core.audio",
        "peekOfCode": "def save_audio(audio_data: np.ndarray, sample_rate: int, filename: str):\n    \"\"\"\n    Save audio data to a WAV file.\n    Args:\n        audio_data: Audio signal array\n        sample_rate: Sample rate in Hz\n        filename: Output filename\n    \"\"\"\n    import soundfile as sf\n    sf.write(filename, audio_data, sample_rate)",
        "detail": "src.word_manifold.core.audio",
        "documentation": {}
    },
    {
        "label": "ModelWorker",
        "kind": 6,
        "importPath": "src.word_manifold.core.model_host",
        "description": "src.word_manifold.core.model_host",
        "peekOfCode": "class ModelWorker:\n    \"\"\"Ray worker for hosting models.\"\"\"\n    def __init__(self, model_name: str, device: Optional[str] = None):\n        \"\"\"Initialize model worker.\"\"\"\n        self.model_name = model_name\n        self.device = device or (\"cuda\" if torch.cuda.is_available() else \"cpu\")\n        self.model = None\n        self._load_model()\n    def _load_model(self) -> None:\n        \"\"\"Load the model.\"\"\"",
        "detail": "src.word_manifold.core.model_host",
        "documentation": {}
    },
    {
        "label": "ModelHost",
        "kind": 6,
        "importPath": "src.word_manifold.core.model_host",
        "description": "src.word_manifold.core.model_host",
        "peekOfCode": "class ModelHost:\n    \"\"\"Manages distributed model workers.\"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",\n        num_workers: int = 2,\n        ray_address: Optional[str] = None\n    ):\n        \"\"\"Initialize model host.\"\"\"\n        self.model_name = model_name",
        "detail": "src.word_manifold.core.model_host",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.core.model_host",
        "description": "src.word_manifold.core.model_host",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@ray.remote(num_gpus=1 if torch.cuda.is_available() else 0)\nclass ModelWorker:\n    \"\"\"Ray worker for hosting models.\"\"\"\n    def __init__(self, model_name: str, device: Optional[str] = None):\n        \"\"\"Initialize model worker.\"\"\"\n        self.model_name = model_name\n        self.device = device or (\"cuda\" if torch.cuda.is_available() else \"cpu\")\n        self.model = None\n        self._load_model()",
        "detail": "src.word_manifold.core.model_host",
        "documentation": {}
    },
    {
        "label": "ResonanceNode",
        "kind": 6,
        "importPath": "src.word_manifold.discovery.resonance_network",
        "description": "src.word_manifold.discovery.resonance_network",
        "peekOfCode": "class ResonanceNode:\n    \"\"\"Information about a resonance network node.\"\"\"\n    node_id: str\n    host: str\n    port: int\n    active_fields: Set[ResonanceField]\n    field_strength: float\n    last_evolution: datetime\n    metadata: Dict[str, Any]\nclass ResonanceDiscovery:",
        "detail": "src.word_manifold.discovery.resonance_network",
        "documentation": {}
    },
    {
        "label": "ResonanceDiscovery",
        "kind": 6,
        "importPath": "src.word_manifold.discovery.resonance_network",
        "description": "src.word_manifold.discovery.resonance_network",
        "peekOfCode": "class ResonanceDiscovery:\n    \"\"\"Discovers and tracks resonant mandala nodes.\"\"\"\n    SERVICE_TYPE = \"_mandala-resonance._tcp.local.\"\n    def __init__(self, node_id: Optional[str] = None):\n        self.node_id = node_id or socket.gethostname()\n        self.zeroconf = Zeroconf()\n        self.nodes: Dict[str, ResonanceNode] = {}\n        self.browser = None\n        self.info = None\n        self._lock = threading.Lock()",
        "detail": "src.word_manifold.discovery.resonance_network",
        "documentation": {}
    },
    {
        "label": "ResonanceNetworkManager",
        "kind": 6,
        "importPath": "src.word_manifold.discovery.resonance_network",
        "description": "src.word_manifold.discovery.resonance_network",
        "peekOfCode": "class ResonanceNetworkManager:\n    \"\"\"Manages resonance network across Ray cluster.\"\"\"\n    def __init__(self, discovery: ResonanceDiscovery):\n        self.discovery = discovery\n        self.field_registry: Dict[ResonanceField, Set[str]] = {\n            field: set() for field in ResonanceField\n        }\n        # Set service info for monitoring\n        self.service_info = {\n            'name': f'resonance_manager_{discovery.node_id}',",
        "detail": "src.word_manifold.discovery.resonance_network",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.discovery.resonance_network",
        "description": "src.word_manifold.discovery.resonance_network",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Initialize Ray manager\nray_manager = get_ray_manager(dashboard_port=8265)\n@dataclass\nclass ResonanceNode:\n    \"\"\"Information about a resonance network node.\"\"\"\n    node_id: str\n    host: str\n    port: int\n    active_fields: Set[ResonanceField]",
        "detail": "src.word_manifold.discovery.resonance_network",
        "documentation": {}
    },
    {
        "label": "ray_manager",
        "kind": 5,
        "importPath": "src.word_manifold.discovery.resonance_network",
        "description": "src.word_manifold.discovery.resonance_network",
        "peekOfCode": "ray_manager = get_ray_manager(dashboard_port=8265)\n@dataclass\nclass ResonanceNode:\n    \"\"\"Information about a resonance network node.\"\"\"\n    node_id: str\n    host: str\n    port: int\n    active_fields: Set[ResonanceField]\n    field_strength: float\n    last_evolution: datetime",
        "detail": "src.word_manifold.discovery.resonance_network",
        "documentation": {}
    },
    {
        "label": "TermWorker",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.distributed_term_manager",
        "description": "src.word_manifold.embeddings.distributed_term_manager",
        "peekOfCode": "class TermWorker:\n    \"\"\"Worker for processing terms in parallel.\"\"\"\n    def __init__(self, model_name: str):\n        self.model = SentenceTransformer(model_name)\n        if torch.cuda.is_available():\n            self.model.to(torch.device(\"cuda\"))\n    def process_batch(self, terms: List[str]) -> Dict[str, np.ndarray]:\n        \"\"\"Process a batch of terms to get embeddings.\"\"\"\n        try:\n            embeddings = self.model.encode(terms, convert_to_numpy=True)",
        "detail": "src.word_manifold.embeddings.distributed_term_manager",
        "documentation": {}
    },
    {
        "label": "DistributedTermManager",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.distributed_term_manager",
        "description": "src.word_manifold.embeddings.distributed_term_manager",
        "peekOfCode": "class DistributedTermManager:\n    \"\"\"\n    Distributed term manager using Ray for parallel processing.\n    Coordinates multiple workers across machines for term embedding.\n    \"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",\n        cache_size: int = 10000,\n        batch_size: int = 32,",
        "detail": "src.word_manifold.embeddings.distributed_term_manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.distributed_term_manager",
        "description": "src.word_manifold.embeddings.distributed_term_manager",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@ray.remote\nclass TermWorker:\n    \"\"\"Worker for processing terms in parallel.\"\"\"\n    def __init__(self, model_name: str):\n        self.model = SentenceTransformer(model_name)\n        if torch.cuda.is_available():\n            self.model.to(torch.device(\"cuda\"))\n    def process_batch(self, terms: List[str]) -> Dict[str, np.ndarray]:\n        \"\"\"Process a batch of terms to get embeddings.\"\"\"",
        "detail": "src.word_manifold.embeddings.distributed_term_manager",
        "documentation": {}
    },
    {
        "label": "PhraseEmbedding",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "class PhraseEmbedding:\n    \"\"\"\n    A class representing the embedding of a phrase or sentence,\n    including both its semantic content and structural shape.\n    \"\"\"\n    def __init__(self, text: str, embedding: np.ndarray, shape_params: Dict):\n        self.text = text\n        self.embedding = embedding\n        self.shape_params = shape_params\n    def __repr__(self) -> str:",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "PhraseEmbedder",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "class PhraseEmbedder:\n    \"\"\"\n    A class for embedding phrases and sentences into a semantic manifold,\n    extracting both meaning and structural patterns.\n    \"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L12-v2\",  # Using smaller default model\n        emotion_model_name: str = \"j-hartmann/emotion-english-distilroberta-base\",  # Smaller emotion model\n        cache_size: int = 500,  # Reduced cache size",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "get_spacy_model",
        "kind": 2,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "def get_spacy_model(model_name: str = 'en_core_web_lg') -> spacy.language.Language:\n    \"\"\"Load spaCy model with fallback options.\"\"\"\n    global _spacy_model\n    if _spacy_model is None:\n        try:\n            logger.info(f\"Loading spaCy model '{model_name}'\")\n            _spacy_model = spacy.load(model_name)\n        except OSError:\n            logger.warning(f\"spaCy model '{model_name}' not found, downloading...\")\n            try:",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "get_emotion_vector",
        "kind": 2,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "def get_emotion_vector(emotion: str) -> np.ndarray:\n    \"\"\"Get cached emotion vector for a category.\"\"\"\n    words = EMOTION_CATEGORIES[emotion]\n    vectors = []\n    nlp = get_spacy_model()\n    # Try each word in the category\n    for word in words:\n        token = nlp(word)[0]\n        if token.has_vector:\n            vectors.append(token.vector)",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "get_emotion_anchors",
        "kind": 2,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "def get_emotion_anchors():\n    \"\"\"Get emotion anchors, initializing them if needed.\"\"\"\n    global _EMOTION_ANCHORS\n    if _EMOTION_ANCHORS is None:\n        _EMOTION_ANCHORS = {}\n        for emotion in EMOTION_CATEGORIES:\n            vector = get_emotion_vector(emotion)\n            if np.any(vector):  # Only add emotions with non-zero vectors\n                _EMOTION_ANCHORS[emotion] = vector\n    return _EMOTION_ANCHORS",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "BACKUP_MODEL",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "BACKUP_MODEL = \"sentence-transformers/all-MiniLM-L6-v2\"  # Using smaller model as backup\n# Configure module logger\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n# Create formatters and handlers if they don't exist\nif not logger.handlers:\n    # Create console handler with formatting\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    console_formatter = logging.Formatter(",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n# Create formatters and handlers if they don't exist\nif not logger.handlers:\n    # Create console handler with formatting\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    console_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - [%(levelname)s] - %(message)s'\n    )",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "_spacy_model",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "_spacy_model = None\ndef get_spacy_model(model_name: str = 'en_core_web_lg') -> spacy.language.Language:\n    \"\"\"Load spaCy model with fallback options.\"\"\"\n    global _spacy_model\n    if _spacy_model is None:\n        try:\n            logger.info(f\"Loading spaCy model '{model_name}'\")\n            _spacy_model = spacy.load(model_name)\n        except OSError:\n            logger.warning(f\"spaCy model '{model_name}' not found, downloading...\")",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "EMOTION_CATEGORIES",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "EMOTION_CATEGORIES = {\n    'joy': ['happy', 'joyful', 'delighted', 'elated', 'ecstatic', 'content', 'pleased'],\n    'sadness': ['sad', 'depressed', 'gloomy', 'melancholy', 'heartbroken', 'grieving', 'unhappy'],\n    'anger': ['angry', 'furious', 'enraged', 'hostile', 'irritated', 'outraged', 'mad'],\n    'fear': ['afraid', 'scared', 'terrified', 'anxious', 'panicked', 'worried', 'frightened'],\n    'surprise': ['surprised', 'amazed', 'astonished', 'shocked', 'startled', 'stunned', 'unexpected'],\n    'disgust': ['disgusted', 'repulsed', 'revolted', 'appalled', 'nauseated', 'offended', 'gross'],\n    'trust': ['trusting', 'confident', 'secure', 'reliable', 'faithful', 'assured', 'believing'],\n    'anticipation': ['expectant', 'eager', 'excited', 'hopeful', 'optimistic', 'ready', 'awaiting']\n}",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "_EMOTION_ANCHORS",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "_EMOTION_ANCHORS = None\ndef get_emotion_anchors():\n    \"\"\"Get emotion anchors, initializing them if needed.\"\"\"\n    global _EMOTION_ANCHORS\n    if _EMOTION_ANCHORS is None:\n        _EMOTION_ANCHORS = {}\n        for emotion in EMOTION_CATEGORIES:\n            vector = get_emotion_vector(emotion)\n            if np.any(vector):  # Only add emotions with non-zero vectors\n                _EMOTION_ANCHORS[emotion] = vector",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "TermManagerProcess",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.term_manager",
        "description": "src.word_manifold.embeddings.term_manager",
        "peekOfCode": "class TermManagerProcess(mp.Process):\n    \"\"\"Separate process for term management to avoid pickling issues.\"\"\"\n    def __init__(self, model_name: str, task_queue: mp.Queue, result_queue: mp.Queue):\n        super().__init__(daemon=True)\n        self.model_name = model_name\n        self.task_queue = task_queue\n        self.result_queue = result_queue\n        self.running = True\n    def run(self):\n        \"\"\"Run the term management process.\"\"\"",
        "detail": "src.word_manifold.embeddings.term_manager",
        "documentation": {}
    },
    {
        "label": "TermManager",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.term_manager",
        "description": "src.word_manifold.embeddings.term_manager",
        "peekOfCode": "class TermManager:\n    \"\"\"\n    Manages terms and their embeddings in a background process.\n    Provides caching and asynchronous processing capabilities with proper synchronization.\n    \"\"\"\n    def __init__(self, model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\", **kwargs):\n        \"\"\"\n        Initialize the TermManager.\n        Args:\n            model_name: Name of the transformer model to use",
        "detail": "src.word_manifold.embeddings.term_manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.term_manager",
        "description": "src.word_manifold.embeddings.term_manager",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Global registry of active managers\n_active_managers = weakref.WeakSet()\ndef _cleanup_managers():\n    \"\"\"Clean up all active managers during interpreter shutdown.\"\"\"\n    for manager in _active_managers:\n        try:\n            manager.shutdown()\n        except:\n            pass",
        "detail": "src.word_manifold.embeddings.term_manager",
        "documentation": {}
    },
    {
        "label": "_active_managers",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.term_manager",
        "description": "src.word_manifold.embeddings.term_manager",
        "peekOfCode": "_active_managers = weakref.WeakSet()\ndef _cleanup_managers():\n    \"\"\"Clean up all active managers during interpreter shutdown.\"\"\"\n    for manager in _active_managers:\n        try:\n            manager.shutdown()\n        except:\n            pass\n# Register cleanup function\natexit.register(_cleanup_managers)",
        "detail": "src.word_manifold.embeddings.term_manager",
        "documentation": {}
    },
    {
        "label": "EmbeddingMode",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.word_embeddings",
        "description": "src.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "class EmbeddingMode(Enum):\n    \"\"\"Mode for embedding operations.\"\"\"\n    LOCAL = \"local\"\n    REMOTE = \"remote\"\n    REPLICATE = \"replicate\"\nclass WordEmbeddings:\n    \"\"\"Manages word embeddings with distributed computation support.\"\"\"\n    DEFAULT_MODEL = DEFAULT_MODEL\n    BACKUP_MODEL = BACKUP_MODEL\n    # Default terms for initialization",
        "detail": "src.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.word_embeddings",
        "description": "src.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "class WordEmbeddings:\n    \"\"\"Manages word embeddings with distributed computation support.\"\"\"\n    DEFAULT_MODEL = DEFAULT_MODEL\n    BACKUP_MODEL = BACKUP_MODEL\n    # Default terms for initialization\n    DEFAULT_TERMS = [\n        # Core concepts\n        \"wisdom\", \"understanding\", \"knowledge\", \"truth\",\n        \"beauty\", \"harmony\", \"balance\", \"unity\",\n        # Fundamental pairs",
        "detail": "src.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "os.environ[\"TOKENIZERS_PARALLELISM\"]",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.word_embeddings",
        "description": "src.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "os.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"\n# Configure logging\nlogging.basicConfig(level=logging.INFO,\n                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n# Default models - using smaller models by default\nDEFAULT_MODEL = 'sentence-transformers/all-MiniLM-L6-v2'  # Much smaller model\nBACKUP_MODEL = 'sentence-transformers/paraphrase-MiniLM-L3-v2'  # Even smaller backup\nclass EmbeddingMode(Enum):\n    \"\"\"Mode for embedding operations.\"\"\"",
        "detail": "src.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.word_embeddings",
        "description": "src.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Default models - using smaller models by default\nDEFAULT_MODEL = 'sentence-transformers/all-MiniLM-L6-v2'  # Much smaller model\nBACKUP_MODEL = 'sentence-transformers/paraphrase-MiniLM-L3-v2'  # Even smaller backup\nclass EmbeddingMode(Enum):\n    \"\"\"Mode for embedding operations.\"\"\"\n    LOCAL = \"local\"\n    REMOTE = \"remote\"\n    REPLICATE = \"replicate\"\nclass WordEmbeddings:",
        "detail": "src.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MODEL",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.word_embeddings",
        "description": "src.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "DEFAULT_MODEL = 'sentence-transformers/all-MiniLM-L6-v2'  # Much smaller model\nBACKUP_MODEL = 'sentence-transformers/paraphrase-MiniLM-L3-v2'  # Even smaller backup\nclass EmbeddingMode(Enum):\n    \"\"\"Mode for embedding operations.\"\"\"\n    LOCAL = \"local\"\n    REMOTE = \"remote\"\n    REPLICATE = \"replicate\"\nclass WordEmbeddings:\n    \"\"\"Manages word embeddings with distributed computation support.\"\"\"\n    DEFAULT_MODEL = DEFAULT_MODEL",
        "detail": "src.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "BACKUP_MODEL",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.word_embeddings",
        "description": "src.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "BACKUP_MODEL = 'sentence-transformers/paraphrase-MiniLM-L3-v2'  # Even smaller backup\nclass EmbeddingMode(Enum):\n    \"\"\"Mode for embedding operations.\"\"\"\n    LOCAL = \"local\"\n    REMOTE = \"remote\"\n    REPLICATE = \"replicate\"\nclass WordEmbeddings:\n    \"\"\"Manages word embeddings with distributed computation support.\"\"\"\n    DEFAULT_MODEL = DEFAULT_MODEL\n    BACKUP_MODEL = BACKUP_MODEL",
        "detail": "src.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "ForceFieldDemo",
        "kind": 6,
        "importPath": "src.word_manifold.examples.force_field_demo",
        "description": "src.word_manifold.examples.force_field_demo",
        "peekOfCode": "class ForceFieldDemo:\n    def __init__(self, n_dimensions=3):\n        \"\"\"Initialize the force field demonstration.\n        Args:\n            n_dimensions (int): Number of dimensions for the semantic space\n        \"\"\"\n        self.n_dimensions = n_dimensions\n        self.embeddings = None\n        self.manifold = None\n        self.visualizer = None",
        "detail": "src.word_manifold.examples.force_field_demo",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.word_manifold.examples.force_field_demo",
        "description": "src.word_manifold.examples.force_field_demo",
        "peekOfCode": "def main():\n    \"\"\"Run the force field visualization demo.\"\"\"\n    # Create and run simulation\n    demo = ForceFieldDemo(n_dimensions=3)\n    demo.prepare_components()\n    viz_path = demo.simulate_force_field()\n    logger.info(f\"\"\"\n    Force field visualization complete!\n    This demonstration shows how concepts move through a semantic force field:\n    - Red points are attractors (positive concepts)",
        "detail": "src.word_manifold.examples.force_field_demo",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.examples.force_field_demo",
        "description": "src.word_manifold.examples.force_field_demo",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ForceFieldDemo:\n    def __init__(self, n_dimensions=3):\n        \"\"\"Initialize the force field demonstration.\n        Args:\n            n_dimensions (int): Number of dimensions for the semantic space\n        \"\"\"\n        self.n_dimensions = n_dimensions\n        self.embeddings = None\n        self.manifold = None",
        "detail": "src.word_manifold.examples.force_field_demo",
        "documentation": {}
    },
    {
        "label": "HyperdimensionalRitual",
        "kind": 6,
        "importPath": "src.word_manifold.examples.hyperdimensional_ritual",
        "description": "src.word_manifold.examples.hyperdimensional_ritual",
        "peekOfCode": "class HyperdimensionalRitual:\n    \"\"\"\n    A class demonstrating hyperdimensional visualization of Thelemic rituals.\n    \"\"\"\n    def __init__(\n        self,\n        n_dimensions: int = 5,  # We'll use 5D for richer semantic representation\n        output_dir: str = \"visualizations/hyperdimensional\"\n    ):\n        self.n_dimensions = n_dimensions",
        "detail": "src.word_manifold.examples.hyperdimensional_ritual",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.word_manifold.examples.hyperdimensional_ritual",
        "description": "src.word_manifold.examples.hyperdimensional_ritual",
        "peekOfCode": "def main():\n    \"\"\"Run the hyperdimensional ritual visualization example.\"\"\"\n    # Create and prepare the ritual\n    ritual = HyperdimensionalRitual(n_dimensions=5)\n    ritual.prepare_components()\n    # Create visualization\n    viz_path = ritual.visualize_ritual_transformation()\n    logger.info(f\"\"\"\n    Hyperdimensional ritual visualization complete!\n    The visualization shows the evolution of Thelemic concepts through a 5-dimensional",
        "detail": "src.word_manifold.examples.hyperdimensional_ritual",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.examples.hyperdimensional_ritual",
        "description": "src.word_manifold.examples.hyperdimensional_ritual",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HyperdimensionalRitual:\n    \"\"\"\n    A class demonstrating hyperdimensional visualization of Thelemic rituals.\n    \"\"\"\n    def __init__(\n        self,\n        n_dimensions: int = 5,  # We'll use 5D for richer semantic representation\n        output_dir: str = \"visualizations/hyperdimensional\"\n    ):",
        "detail": "src.word_manifold.examples.hyperdimensional_ritual",
        "documentation": {}
    },
    {
        "label": "RitualWorking",
        "kind": 6,
        "importPath": "src.word_manifold.examples.ritual_evolution",
        "description": "src.word_manifold.examples.ritual_evolution",
        "peekOfCode": "class RitualWorking:\n    \"\"\"\n    A class that implements a complete magical working in word vector space.\n    \"\"\"\n    def _create_evolution_animation(self, key_terms):\n        \"\"\"\n        Create an animation of the evolution of machinic desires using fluid visual transformations and emergent patterns.\n        Args:\n            key_terms: List of key terms to highlight in the animation description\n        Returns:",
        "detail": "src.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "memoize",
        "kind": 2,
        "importPath": "src.word_manifold.examples.ritual_evolution",
        "description": "src.word_manifold.examples.ritual_evolution",
        "peekOfCode": "def memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.\n    Results are cached in memory and on disk for persistence between runs.\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # Create a unique key based on function name and arguments\n        key_parts = [func.__name__]\n        # Add class name if it's a method",
        "detail": "src.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.word_manifold.examples.ritual_evolution",
        "description": "src.word_manifold.examples.ritual_evolution",
        "peekOfCode": "def main():\n    \"\"\" Demonstrate the ritual evolution process. \"\"\"\n    ritual = RitualWorking(\n        ritual_name=\"True Will Discovery\",\n        ritual_intent=\"To discover and align with one's True Will through semantic transformation\"\n    )\n    # Prepare components\n    ritual.prepare_components()\n    # Perform the ritual\n    ritual.perform_ritual()",
        "detail": "src.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.examples.ritual_evolution",
        "description": "src.word_manifold.examples.ritual_evolution",
        "peekOfCode": "logger = logging.getLogger(\"ritual_evolution\")\n# Directory for saving outputs\nOUTPUT_DIR = Path(\"ritual_outputs\")\nCACHE_DIR = Path(\".ritual_cache\")\n# Create cache directory if it doesn't exist\nCACHE_DIR.mkdir(exist_ok=True)\n# Function cache decorator with key based on function arguments\ndef memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.",
        "detail": "src.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "OUTPUT_DIR",
        "kind": 5,
        "importPath": "src.word_manifold.examples.ritual_evolution",
        "description": "src.word_manifold.examples.ritual_evolution",
        "peekOfCode": "OUTPUT_DIR = Path(\"ritual_outputs\")\nCACHE_DIR = Path(\".ritual_cache\")\n# Create cache directory if it doesn't exist\nCACHE_DIR.mkdir(exist_ok=True)\n# Function cache decorator with key based on function arguments\ndef memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.\n    Results are cached in memory and on disk for persistence between runs.\n    \"\"\"",
        "detail": "src.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "CACHE_DIR",
        "kind": 5,
        "importPath": "src.word_manifold.examples.ritual_evolution",
        "description": "src.word_manifold.examples.ritual_evolution",
        "peekOfCode": "CACHE_DIR = Path(\".ritual_cache\")\n# Create cache directory if it doesn't exist\nCACHE_DIR.mkdir(exist_ok=True)\n# Function cache decorator with key based on function arguments\ndef memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.\n    Results are cached in memory and on disk for persistence between runs.\n    \"\"\"\n    @functools.wraps(func)",
        "detail": "src.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "ReadingStep",
        "kind": 6,
        "importPath": "src.word_manifold.examples.semantic_crystallization",
        "description": "src.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "class ReadingStep:\n    \"\"\"Represents a single step in the reading sequence.\"\"\"\n    card: str  # The card or concept being integrated\n    keywords: List[str]  # Associated keywords/meanings\n    position: str  # Position or aspect in the reading (e.g., \"past\", \"present\", \"future\")\n    influence: float = 1.0  # Relative influence of this step (0-1)\nterms=[\n                # Major Arcana\n                \"fool\", \"magician\", \"priestess\", \"empress\", \"emperor\",\n                \"hierophant\", \"lovers\", \"chariot\", \"strength\", \"hermit\",",
        "detail": "src.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "SemanticCrystallization",
        "kind": 6,
        "importPath": "src.word_manifold.examples.semantic_crystallization",
        "description": "src.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "class SemanticCrystallization:\n    \"\"\"\n    Visualizes the crystallization of meaning during a reading sequence.\n    This class tracks how semantic space transforms as each new card or concept\n    is integrated, showing the accumulation and crystallization of meaning over time.\n    \"\"\"\n    def __init__(\n        self,\n        n_dimensions: int = 5,\n        output_dir: str = \"visualizations/crystallization\",",
        "detail": "src.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.word_manifold.examples.semantic_crystallization",
        "description": "src.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "def main():\n    \"\"\"Run the semantic crystallization example.\"\"\"\n    # Create and prepare crystallization viewer\n    crystal = SemanticCrystallization(n_dimensions=5)\n    crystal.prepare_components()\n    # Example Celtic Cross reading sequence\n    reading_sequence = [\n        # Central cross\n        (\"present\", \"tower\", [\"disruption\", \"awakening\", \"revelation\"]),\n        (\"challenge\", \"death\", [\"transformation\", \"ending\", \"rebirth\"]),",
        "detail": "src.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.examples.semantic_crystallization",
        "description": "src.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass ReadingStep:\n    \"\"\"Represents a single step in the reading sequence.\"\"\"\n    card: str  # The card or concept being integrated\n    keywords: List[str]  # Associated keywords/meanings\n    position: str  # Position or aspect in the reading (e.g., \"past\", \"present\", \"future\")\n    influence: float = 1.0  # Relative influence of this step (0-1)\nterms=[\n                # Major Arcana",
        "detail": "src.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "ThelemaMetrics",
        "kind": 6,
        "importPath": "src.word_manifold.examples.thelemic_evolution",
        "description": "src.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "class ThelemaMetrics:\n    \"\"\"\n    A class to calculate and track metrics for the Thelemic evolution of a word manifold.\n    Metrics include:\n    - Semantic entropy: Measure of semantic diversity\n    - Numerological alignment: Correspondence between numerological values\n    - Will manifestation: How closely the system follows its \"True Will\"\n    - Transmutation index: Degree of alchemical transformation\n    \"\"\"\n    def __init__(self):",
        "detail": "src.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "BasicVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.examples.thelemic_evolution",
        "description": "src.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "class BasicVisualizer:\n    \"\"\"\n    A basic visualization class for when the full visualizer is not available.\n    This creates simple 2D plots of the manifold's reduced representation.\n    \"\"\"\n    def __init__(self, manifold: VectorManifold, save_path: str):\n        \"\"\"\n        Initialize the basic visualizer.\n        Args:\n            manifold: The vector manifold to visualize",
        "detail": "src.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "run_thelemic_evolution",
        "kind": 2,
        "importPath": "src.word_manifold.examples.thelemic_evolution",
        "description": "src.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "def run_thelemic_evolution(\n    generations: int = 22,  # One for each Major Arcana\n    save_path: str = None,\n    model_name: str = \"bert-base-uncased\",\n    n_cells: int = 22,\n    random_state: int = 93  # Significant in Thelema/Crowley's work\n):\n    \"\"\"\n    Run the Thelemic evolution of the word manifold.\n    Args:",
        "detail": "src.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.examples.thelemic_evolution",
        "description": "src.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Add the project root to the Python path if running as a script\nif __name__ == \"__main__\":\n    project_root = str(Path(__file__).resolve().parents[3])\n    sys.path.insert(0, project_root)\n# Import Word Manifold components\nfrom word_manifold.embeddings.word_embeddings import WordEmbeddings\nfrom word_manifold.manifold.vector_manifold import VectorManifold, CellType\nfrom word_manifold.automata.cellular_rules import create_predefined_rules\nfrom word_manifold.automata.system import AutomataSystem, EvolutionPattern, SystemState",
        "detail": "src.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "RecursiveReducer",
        "kind": 6,
        "importPath": "src.word_manifold.manifold.reduction",
        "description": "src.word_manifold.manifold.reduction",
        "peekOfCode": "class RecursiveReducer:\n    \"\"\"Handles recursive dimensionality reduction with fractal patterns.\"\"\"\n    def __init__(\n        self,\n        manifold,\n        depth: int = 3,\n        min_cluster_size: int = 5,\n        coherence_threshold: float = 0.8,\n        scale_factor: float = 0.5,\n        rotation_symmetry: int = 5",
        "detail": "src.word_manifold.manifold.reduction",
        "documentation": {}
    },
    {
        "label": "ShapePoint",
        "kind": 6,
        "importPath": "src.word_manifold.manifold.semantic_shape",
        "description": "src.word_manifold.manifold.semantic_shape",
        "peekOfCode": "class ShapePoint:\n    \"\"\"A point in the semantic shape with its associated properties.\"\"\"\n    position: np.ndarray\n    intensity: float  # Emotional/semantic intensity\n    direction: np.ndarray  # Flow direction\n    properties: Dict  # Additional shape properties\nclass SemanticShape:\n    \"\"\"\n    A class representing the shape of meaning in semantic space.\n    This captures both the geometric form and the dynamic properties",
        "detail": "src.word_manifold.manifold.semantic_shape",
        "documentation": {}
    },
    {
        "label": "SemanticShape",
        "kind": 6,
        "importPath": "src.word_manifold.manifold.semantic_shape",
        "description": "src.word_manifold.manifold.semantic_shape",
        "peekOfCode": "class SemanticShape:\n    \"\"\"\n    A class representing the shape of meaning in semantic space.\n    This captures both the geometric form and the dynamic properties\n    of a semantic expression (phrase, sentence, or text chunk).\n    \"\"\"\n    def __init__(\n        self,\n        phrase_embedding: PhraseEmbedding,\n        n_control_points: int = 10",
        "detail": "src.word_manifold.manifold.semantic_shape",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.manifold.semantic_shape",
        "description": "src.word_manifold.manifold.semantic_shape",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass ShapePoint:\n    \"\"\"A point in the semantic shape with its associated properties.\"\"\"\n    position: np.ndarray\n    intensity: float  # Emotional/semantic intensity\n    direction: np.ndarray  # Flow direction\n    properties: Dict  # Additional shape properties\nclass SemanticShape:\n    \"\"\"",
        "detail": "src.word_manifold.manifold.semantic_shape",
        "documentation": {}
    },
    {
        "label": "ManifoldReducedState",
        "kind": 6,
        "importPath": "src.word_manifold.manifold.vector_manifold",
        "description": "src.word_manifold.manifold.vector_manifold",
        "peekOfCode": "class ManifoldReducedState(NamedTuple):\n    \"\"\"Represents the reduced state of a manifold for visualization.\"\"\"\n    points: np.ndarray  # Reduced point coordinates\n    labels: List[str]   # Point labels\n    edges: List[tuple]  # Edge connections between points\n    metadata: Dict      # Additional visualization metadata\n@dataclass\nclass Cell:\n    \"\"\"A cell in the manifold representing a region in the vector space.\"\"\"\n    id: int",
        "detail": "src.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "Cell",
        "kind": 6,
        "importPath": "src.word_manifold.manifold.vector_manifold",
        "description": "src.word_manifold.manifold.vector_manifold",
        "peekOfCode": "class Cell:\n    \"\"\"A cell in the manifold representing a region in the vector space.\"\"\"\n    id: int\n    terms: Set[str]  # Words that belong to this cell\n    centroid: np.ndarray  # Center point of the cell\n    type: CellType = CellType.STANDARD  # Type of cell\n    def __post_init__(self):\n        \"\"\"Validate cell data after initialization.\"\"\"\n        if not isinstance(self.terms, set):\n            self.terms = set(self.terms)",
        "detail": "src.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "kind": 6,
        "importPath": "src.word_manifold.manifold.vector_manifold",
        "description": "src.word_manifold.manifold.vector_manifold",
        "peekOfCode": "class VectorManifold:\n    \"\"\"\n    A simplified manifold in vector space for word embeddings.\n    Handles basic clustering and neighborhood relationships.\n    \"\"\"\n    def __init__(\n        self,\n        embeddings: WordEmbeddings,\n        n_cells: int = 10,\n        random_state: int = 42",
        "detail": "src.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.manifold.vector_manifold",
        "description": "src.word_manifold.manifold.vector_manifold",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ManifoldReducedState(NamedTuple):\n    \"\"\"Represents the reduced state of a manifold for visualization.\"\"\"\n    points: np.ndarray  # Reduced point coordinates\n    labels: List[str]   # Point labels\n    edges: List[tuple]  # Edge connections between points\n    metadata: Dict      # Additional visualization metadata\n@dataclass\nclass Cell:\n    \"\"\"A cell in the manifold representing a region in the vector space.\"\"\"",
        "detail": "src.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "SystemMetrics",
        "kind": 6,
        "importPath": "src.word_manifold.monitoring.metrics",
        "description": "src.word_manifold.monitoring.metrics",
        "peekOfCode": "class SystemMetrics:\n    \"\"\"System-level metrics.\"\"\"\n    cpu_percent: float\n    memory_percent: float\n    disk_usage_percent: float\n    network_io_counters: Dict[str, int]\n    timestamp: datetime\n@ray.remote\nclass MetricsCollector:\n    \"\"\"Collects and aggregates metrics from all system components.\"\"\"",
        "detail": "src.word_manifold.monitoring.metrics",
        "documentation": {}
    },
    {
        "label": "MetricsCollector",
        "kind": 6,
        "importPath": "src.word_manifold.monitoring.metrics",
        "description": "src.word_manifold.monitoring.metrics",
        "peekOfCode": "class MetricsCollector:\n    \"\"\"Collects and aggregates metrics from all system components.\"\"\"\n    def __init__(self):\n        # Register metrics with Ray\n        self.visualization_requests = metrics.Counter(\n            \"visualization_requests_total\",\n            description=\"Total number of visualization requests\"\n        )\n        self.visualization_errors = metrics.Counter(\n            \"visualization_errors_total\",",
        "detail": "src.word_manifold.monitoring.metrics",
        "documentation": {}
    },
    {
        "label": "MetricsExporter",
        "kind": 6,
        "importPath": "src.word_manifold.monitoring.metrics",
        "description": "src.word_manifold.monitoring.metrics",
        "peekOfCode": "class MetricsExporter:\n    \"\"\"Exports metrics to various backends (Prometheus, CloudWatch, etc.).\"\"\"\n    def __init__(self, collector: ray.ObjectRef, export_interval: int = 60):\n        self.collector = collector\n        self.export_interval = export_interval\n        self.running = False\n        # Initialize Prometheus client if available\n        try:\n            from prometheus_client import start_http_server, Gauge, Counter, Histogram\n            self.prometheus_enabled = True",
        "detail": "src.word_manifold.monitoring.metrics",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.monitoring.metrics",
        "description": "src.word_manifold.monitoring.metrics",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass SystemMetrics:\n    \"\"\"System-level metrics.\"\"\"\n    cpu_percent: float\n    memory_percent: float\n    disk_usage_percent: float\n    network_io_counters: Dict[str, int]\n    timestamp: datetime\n@ray.remote",
        "detail": "src.word_manifold.monitoring.metrics",
        "documentation": {}
    },
    {
        "label": "CellType",
        "kind": 6,
        "importPath": "src.word_manifold.types.cell_types",
        "description": "src.word_manifold.types.cell_types",
        "peekOfCode": "class CellType(Enum):\n    \"\"\"Basic cell types for vector manifold classification.\"\"\"\n    STANDARD = auto()  # Standard cell type\n    BOUNDARY = auto()  # Cell on manifold boundary\n    CORE = auto()      # Core/central cell\n    BRIDGE = auto()    # Cell connecting different regions\n    OTHER = auto()     # Unclassified/other type",
        "detail": "src.word_manifold.types.cell_types",
        "documentation": {}
    },
    {
        "label": "DistanceType",
        "kind": 6,
        "importPath": "src.word_manifold.types.distance_types",
        "description": "src.word_manifold.types.distance_types",
        "peekOfCode": "class DistanceType(Enum):\n    \"\"\"Types of distance metrics used in the system.\"\"\"\n    EUCLIDEAN = auto()\n    COSINE = auto()\n    MANHATTAN = auto()\n    HAMMING = auto()\n    SEMANTIC = auto()  # For semantic-based distance calculations",
        "detail": "src.word_manifold.types.distance_types",
        "documentation": {}
    },
    {
        "label": "Pattern",
        "kind": 6,
        "importPath": "src.word_manifold.types.patterns",
        "description": "src.word_manifold.types.patterns",
        "peekOfCode": "class Pattern:\n    \"\"\"Base pattern class with minimal required attributes.\"\"\"\n    data: np.ndarray  # 2D array of characters\n    symbols: str      # Available symbols for the pattern\n    @property\n    def width(self) -> int:\n        return self.data.shape[1]\n    @property\n    def height(self) -> int:\n        return self.data.shape[0]",
        "detail": "src.word_manifold.types.patterns",
        "documentation": {}
    },
    {
        "label": "ASCIIPattern",
        "kind": 6,
        "importPath": "src.word_manifold.types.patterns",
        "description": "src.word_manifold.types.patterns",
        "peekOfCode": "class ASCIIPattern(Pattern):\n    \"\"\"ASCII art pattern with additional metadata.\"\"\"\n    metadata: Dict[str, Any] = None\n    frame_index: int = 0\n    @classmethod\n    def create(cls, width: int, height: int, symbols: str = ' .:-=+*#%@', metadata: Optional[Dict[str, Any]] = None) -> 'ASCIIPattern':\n        \"\"\"Create a new ASCII pattern.\"\"\"\n        return cls(\n            data=np.full((height, width), ' ', dtype=str),\n            symbols=symbols,",
        "detail": "src.word_manifold.types.patterns",
        "documentation": {}
    },
    {
        "label": "Mandala",
        "kind": 6,
        "importPath": "src.word_manifold.types.patterns",
        "description": "src.word_manifold.types.patterns",
        "peekOfCode": "class Mandala(Pattern):\n    \"\"\"Circular pattern with radius and rotation.\"\"\"\n    radius: int\n    rotation: float = 0.0\n    @classmethod\n    def create(cls, radius: int, symbols: str = ' .:-=+*#%@', rotation: float = 0.0) -> 'Mandala':\n        \"\"\"Create a new mandala pattern.\"\"\"\n        size = 2 * radius + 1\n        return cls(\n            data=np.full((size, size), ' ', dtype=str),",
        "detail": "src.word_manifold.types.patterns",
        "documentation": {}
    },
    {
        "label": "Field",
        "kind": 6,
        "importPath": "src.word_manifold.types.patterns",
        "description": "src.word_manifold.types.patterns",
        "peekOfCode": "class Field(Pattern):\n    \"\"\"Field pattern with density control.\"\"\"\n    density: float = 0.7\n    @classmethod\n    def create(cls, width: int, height: int, symbols: str = '', density: float = 0.7) -> 'Field':\n        \"\"\"Create a new field pattern.\"\"\"\n        return cls(\n            data=np.full((height, width), ' ', dtype=str),\n            symbols=symbols,\n            density=density",
        "detail": "src.word_manifold.types.patterns",
        "documentation": {}
    },
    {
        "label": "AsyncTaskManager",
        "kind": 6,
        "importPath": "src.word_manifold.utils.debug",
        "description": "src.word_manifold.utils.debug",
        "peekOfCode": "class AsyncTaskManager:\n    \"\"\"Manages asynchronous task execution with thread pooling.\"\"\"\n    def __init__(self, max_workers: int = None):\n        \"\"\"Initialize task manager.\n        Args:\n            max_workers: Maximum number of worker threads\n        \"\"\"\n        self.executor = ThreadPoolExecutor(max_workers=max_workers)\n        self.tasks: Dict[str, Future] = {}\n        self._lock = threading.Lock()",
        "detail": "src.word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "DebugContext",
        "kind": 6,
        "importPath": "src.word_manifold.utils.debug",
        "description": "src.word_manifold.utils.debug",
        "peekOfCode": "class DebugContext:\n    \"\"\"Context manager for debugging blocks of code.\"\"\"\n    def __init__(self, name: str, log_level: int = logging.DEBUG):\n        self.name = name\n        self.log_level = log_level\n        self.start_time = None\n    def __enter__(self):\n        self.start_time = time.perf_counter()\n        logger.log(self.log_level, f\"Entering {self.name}\")\n        return self",
        "detail": "src.word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "log_errors",
        "kind": 2,
        "importPath": "src.word_manifold.utils.debug",
        "description": "src.word_manifold.utils.debug",
        "peekOfCode": "def log_errors(func: F) -> F:\n    \"\"\"Decorator to log exceptions with full traceback.\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            logger.error(f\"Error in {func.__name__}:\")\n            logger.error(f\"Args: {args}, Kwargs: {kwargs}\")\n            logger.error(f\"Exception: {e}\")",
        "detail": "src.word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "time_it",
        "kind": 2,
        "importPath": "src.word_manifold.utils.debug",
        "description": "src.word_manifold.utils.debug",
        "peekOfCode": "def time_it(func: F) -> F:\n    \"\"\"Decorator to measure function execution time.\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.perf_counter()\n        result = func(*args, **kwargs)\n        end = time.perf_counter()\n        logger.info(f\"{func.__name__} took {end - start:.2f} seconds\")\n        return result\n    return wrapper",
        "detail": "src.word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "memory_usage",
        "kind": 2,
        "importPath": "src.word_manifold.utils.debug",
        "description": "src.word_manifold.utils.debug",
        "peekOfCode": "def memory_usage() -> Dict[str, float]:\n    \"\"\"Get current memory usage statistics.\"\"\"\n    try:\n        import psutil\n        process = psutil.Process()\n        mem = process.memory_info()\n        return {\n            'rss': mem.rss / 1024 / 1024,  # MB\n            'vms': mem.vms / 1024 / 1024,  # MB\n            'percent': process.memory_percent()",
        "detail": "src.word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "profile_function",
        "kind": 2,
        "importPath": "src.word_manifold.utils.debug",
        "description": "src.word_manifold.utils.debug",
        "peekOfCode": "def profile_function(func: F) -> F:\n    \"\"\"Decorator to profile function execution.\"\"\"\n    try:\n        import cProfile\n        import pstats\n        import io\n    except ImportError:\n        logger.warning(\"cProfile not available, profiling disabled\")\n        return func\n    @wraps(func)",
        "detail": "src.word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.utils.debug",
        "description": "src.word_manifold.utils.debug",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Type variable for generic function type\nF = TypeVar('F', bound=Callable)\ndef log_errors(func: F) -> F:\n    \"\"\"Decorator to log exceptions with full traceback.\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:",
        "detail": "src.word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "F",
        "kind": 5,
        "importPath": "src.word_manifold.utils.debug",
        "description": "src.word_manifold.utils.debug",
        "peekOfCode": "F = TypeVar('F', bound=Callable)\ndef log_errors(func: F) -> F:\n    \"\"\"Decorator to log exceptions with full traceback.\"\"\"\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            logger.error(f\"Error in {func.__name__}:\")\n            logger.error(f\"Args: {args}, Kwargs: {kwargs}\")",
        "detail": "src.word_manifold.utils.debug",
        "documentation": {}
    },
    {
        "label": "RayServiceInfo",
        "kind": 6,
        "importPath": "src.word_manifold.utils.ray_debug",
        "description": "src.word_manifold.utils.ray_debug",
        "peekOfCode": "class RayServiceInfo:\n    \"\"\"Information about a Ray service.\"\"\"\n    name: str\n    status: str\n    host: str\n    port: int\n    pid: int\n    cpu_percent: float\n    memory_percent: float\n    last_heartbeat: datetime",
        "detail": "src.word_manifold.utils.ray_debug",
        "documentation": {}
    },
    {
        "label": "RayDebugMonitor",
        "kind": 6,
        "importPath": "src.word_manifold.utils.ray_debug",
        "description": "src.word_manifold.utils.ray_debug",
        "peekOfCode": "class RayDebugMonitor:\n    \"\"\"Monitors Ray services and provides debugging information.\"\"\"\n    def __init__(self, dashboard_port: int = 8265, log_dir: Optional[Path] = None):\n        self.dashboard_port = dashboard_port\n        self.log_dir = log_dir or Path(\"logs/ray\")\n        self.log_dir.mkdir(parents=True, exist_ok=True)\n        self.services: Dict[str, RayServiceInfo] = {}\n        self._monitor_thread = None\n        self._stop_event = threading.Event()\n        self._metrics_queue = queue.Queue()",
        "detail": "src.word_manifold.utils.ray_debug",
        "documentation": {}
    },
    {
        "label": "with_ray_monitoring",
        "kind": 2,
        "importPath": "src.word_manifold.utils.ray_debug",
        "description": "src.word_manifold.utils.ray_debug",
        "peekOfCode": "def with_ray_monitoring(monitor: RayDebugMonitor):\n    \"\"\"Decorator to add Ray monitoring to a service.\"\"\"\n    def decorator(func: Callable):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            # Get service info from the function\n            service_name = func.__name__\n            if hasattr(func, 'service_info'):\n                service_info = func.service_info\n                monitor.register_service(",
        "detail": "src.word_manifold.utils.ray_debug",
        "documentation": {}
    },
    {
        "label": "my_service",
        "kind": 2,
        "importPath": "src.word_manifold.utils.ray_debug",
        "description": "src.word_manifold.utils.ray_debug",
        "peekOfCode": "def my_service():\n    my_service.service_info = {\n        'name': 'my_service',\n        'host': 'localhost',\n        'port': 8000,\n        'metadata': {'version': '1.0'}\n    }\n    # Service logic here\n# Stop monitoring when done\nmonitor.stop()",
        "detail": "src.word_manifold.utils.ray_debug",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.utils.ray_debug",
        "description": "src.word_manifold.utils.ray_debug",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass RayServiceInfo:\n    \"\"\"Information about a Ray service.\"\"\"\n    name: str\n    status: str\n    host: str\n    port: int\n    pid: int\n    cpu_percent: float",
        "detail": "src.word_manifold.utils.ray_debug",
        "documentation": {}
    },
    {
        "label": "monitor",
        "kind": 5,
        "importPath": "src.word_manifold.utils.ray_debug",
        "description": "src.word_manifold.utils.ray_debug",
        "peekOfCode": "monitor = RayDebugMonitor(dashboard_port=8265)\nmonitor.start()\n@ray.remote\n@with_ray_monitoring(monitor)\ndef my_service():\n    my_service.service_info = {\n        'name': 'my_service',\n        'host': 'localhost',\n        'port': 8000,\n        'metadata': {'version': '1.0'}",
        "detail": "src.word_manifold.utils.ray_debug",
        "documentation": {}
    },
    {
        "label": "RayManager",
        "kind": 6,
        "importPath": "src.word_manifold.utils.ray_manager",
        "description": "src.word_manifold.utils.ray_manager",
        "peekOfCode": "class RayManager:\n    \"\"\"Centralized manager for Ray functionality.\"\"\"\n    def __init__(self,\n                 node_id: Optional[str] = None,\n                 log_dir: Optional[Path] = None,\n                 dashboard_port: int = 8265):\n        \"\"\"Initialize Ray manager.\"\"\"\n        self.monitor = RayDebugMonitor(\n            dashboard_port=dashboard_port,\n            log_dir=log_dir",
        "detail": "src.word_manifold.utils.ray_manager",
        "documentation": {}
    },
    {
        "label": "get_ray_manager",
        "kind": 2,
        "importPath": "src.word_manifold.utils.ray_manager",
        "description": "src.word_manifold.utils.ray_manager",
        "peekOfCode": "def get_ray_manager(\n    node_id: Optional[str] = None,\n    log_dir: Optional[Path] = None,\n    dashboard_port: int = 8265\n) -> RayManager:\n    \"\"\"Get or create global Ray manager instance.\"\"\"\n    global _ray_manager\n    if _ray_manager is None:\n        _ray_manager = RayManager(\n            node_id=node_id,",
        "detail": "src.word_manifold.utils.ray_manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.utils.ray_manager",
        "description": "src.word_manifold.utils.ray_manager",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass RayManager:\n    \"\"\"Centralized manager for Ray functionality.\"\"\"\n    def __init__(self,\n                 node_id: Optional[str] = None,\n                 log_dir: Optional[Path] = None,\n                 dashboard_port: int = 8265):\n        \"\"\"Initialize Ray manager.\"\"\"\n        self.monitor = RayDebugMonitor(\n            dashboard_port=dashboard_port,",
        "detail": "src.word_manifold.utils.ray_manager",
        "documentation": {}
    },
    {
        "label": "RayNodeInfo",
        "kind": 6,
        "importPath": "src.word_manifold.utils.ray_service",
        "description": "src.word_manifold.utils.ray_service",
        "peekOfCode": "class RayNodeInfo:\n    \"\"\"Information about a Ray node.\"\"\"\n    node_id: str\n    host: str\n    port: int\n    is_head: bool\n    redis_port: int\n    dashboard_port: Optional[int]\n    resources: Dict[str, float]\n    last_heartbeat: datetime",
        "detail": "src.word_manifold.utils.ray_service",
        "documentation": {}
    },
    {
        "label": "RayServiceDiscovery",
        "kind": 6,
        "importPath": "src.word_manifold.utils.ray_service",
        "description": "src.word_manifold.utils.ray_service",
        "peekOfCode": "class RayServiceDiscovery:\n    \"\"\"Discovers and connects to Ray clusters using Zeroconf.\"\"\"\n    SERVICE_TYPE = \"_ray-cluster._tcp.local.\"\n    def __init__(self, \n                 node_id: Optional[str] = None,\n                 monitor: Optional[RayDebugMonitor] = None):\n        \"\"\"Initialize Ray service discovery.\"\"\"\n        self.node_id = node_id or socket.gethostname()\n        self.zeroconf = Zeroconf()\n        self.monitor = monitor or RayDebugMonitor()",
        "detail": "src.word_manifold.utils.ray_service",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.utils.ray_service",
        "description": "src.word_manifold.utils.ray_service",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass RayNodeInfo:\n    \"\"\"Information about a Ray node.\"\"\"\n    node_id: str\n    host: str\n    port: int\n    is_head: bool\n    redis_port: int\n    dashboard_port: Optional[int]",
        "detail": "src.word_manifold.utils.ray_service",
        "documentation": {}
    },
    {
        "label": "ASCIIEngine",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.ascii",
        "description": "src.word_manifold.visualization.engines.ascii",
        "peekOfCode": "class ASCIIEngine:\n    \"\"\"Engine for generating ASCII art visualizations.\"\"\"\n    # Extended character sets for different densities and styles\n    DENSITY_CHARS = ' '  # Basic density progression\n    # Rich character sets for different pattern types\n    DOTS = ''\n    BLOCKS = ''\n    SHADES = ' '\n    LINES = ''\n    CURVES = ''",
        "detail": "src.word_manifold.visualization.engines.ascii",
        "documentation": {}
    },
    {
        "label": "ASCIIEngine",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.ascii_engine",
        "description": "src.word_manifold.visualization.engines.ascii_engine",
        "peekOfCode": "class ASCIIEngine:\n    \"\"\"Engine for generating ASCII art visualizations.\"\"\"\n    def __init__(self):\n        # ASCII characters for different densities\n        self.density_chars = ' .:-=+*#%@'\n        self.special_chars = ''\n    def generate_mandala_pattern(\n        self,\n        term: str,\n        radius: int,",
        "detail": "src.word_manifold.visualization.engines.ascii_engine",
        "documentation": {}
    },
    {
        "label": "MandalaStyle",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.mandala",
        "description": "src.word_manifold.visualization.engines.mandala",
        "peekOfCode": "class MandalaStyle(Enum):\n    \"\"\"Available mandala styles.\"\"\"\n    MYSTICAL = \"mystical\"\n    GEOMETRIC = \"geometric\"\n    NATURAL = \"natural\"\n    COSMIC = \"cosmic\"\n    FRACTAL = \"fractal\"\n@dataclass\nclass MandalaConfig:\n    \"\"\"Configuration for mandala generation.\"\"\"",
        "detail": "src.word_manifold.visualization.engines.mandala",
        "documentation": {}
    },
    {
        "label": "MandalaConfig",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.mandala",
        "description": "src.word_manifold.visualization.engines.mandala",
        "peekOfCode": "class MandalaConfig:\n    \"\"\"Configuration for mandala generation.\"\"\"\n    radius: int\n    resolution: Tuple[int, int]  # (width, height)\n    style: MandalaStyle\n    symmetry: int = 8\n    density: float = 0.7\n    complexity: float = 1.0\n    frame_limit: Optional[int] = None\n    frame_interval: float = 0.1  # seconds between frames",
        "detail": "src.word_manifold.visualization.engines.mandala",
        "documentation": {}
    },
    {
        "label": "MandalaEngine",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.mandala",
        "description": "src.word_manifold.visualization.engines.mandala",
        "peekOfCode": "class MandalaEngine:\n    \"\"\"Engine for generating mandala patterns.\"\"\"\n    def __init__(self):\n        self.current_frame = 0\n        self.patterns: Dict[str, np.ndarray] = {}\n    def generate_mandala(\n        self,\n        config: MandalaConfig,\n        seed: Optional[int] = None\n    ) -> np.ndarray:",
        "detail": "src.word_manifold.visualization.engines.mandala",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.engines.mandala",
        "description": "src.word_manifold.visualization.engines.mandala",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass MandalaStyle(Enum):\n    \"\"\"Available mandala styles.\"\"\"\n    MYSTICAL = \"mystical\"\n    GEOMETRIC = \"geometric\"\n    NATURAL = \"natural\"\n    COSMIC = \"cosmic\"\n    FRACTAL = \"fractal\"\n@dataclass\nclass MandalaConfig:",
        "detail": "src.word_manifold.visualization.engines.mandala",
        "documentation": {}
    },
    {
        "label": "ProjectionEngine",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.projection",
        "description": "src.word_manifold.visualization.engines.projection",
        "peekOfCode": "class ProjectionEngine:\n    \"\"\"Engine for projecting high-dimensional data to 3D space.\"\"\"\n    PROJECTION_TYPES = {\n        \"stereographic\": \"Stereographic projection from N-sphere to (N-1)-space\",\n        \"orthographic\": \"Orthographic projection taking first 3 components\",\n        \"pca\": \"Principal Component Analysis to 3D\",\n        \"umap\": \"UMAP dimensionality reduction\",\n        \"tsne\": \"t-SNE embedding\"\n    }\n    def __init__(self, ",
        "detail": "src.word_manifold.visualization.engines.projection",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.engines.projection",
        "description": "src.word_manifold.visualization.engines.projection",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ProjectionEngine:\n    \"\"\"Engine for projecting high-dimensional data to 3D space.\"\"\"\n    PROJECTION_TYPES = {\n        \"stereographic\": \"Stereographic projection from N-sphere to (N-1)-space\",\n        \"orthographic\": \"Orthographic projection taking first 3 components\",\n        \"pca\": \"Principal Component Analysis to 3D\",\n        \"umap\": \"UMAP dimensionality reduction\",\n        \"tsne\": \"t-SNE embedding\"\n    }",
        "detail": "src.word_manifold.visualization.engines.projection",
        "documentation": {}
    },
    {
        "label": "ResonanceField",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.resonant_mandala",
        "description": "src.word_manifold.visualization.engines.resonant_mandala",
        "peekOfCode": "class ResonanceField(Enum):\n    \"\"\"Core resonance fields that mandalas can tap into.\"\"\"\n    COSMIC_MEMORY = \"cosmic_memory\"      # Universal patterns and cosmic archetypes\n    NATURAL_WISDOM = \"natural_wisdom\"    # Earth's living patterns and rhythms\n    ANCESTRAL_ECHO = \"ancestral_echo\"    # Cultural and historical patterns\n    QUANTUM_DREAM = \"quantum_dream\"      # Quantum-level consciousness patterns\n    MYTHIC_CURRENT = \"mythic_current\"    # Mythological and archetypal streams\n    DREAM_LOGIC = \"dream_logic\"          # Non-linear dream-state patterns\n    EMOTIONAL_FIELD = \"emotional_field\"  # Emotional resonance patterns\n    TIME_SPIRAL = \"time_spiral\"          # Temporal pattern dynamics",
        "detail": "src.word_manifold.visualization.engines.resonant_mandala",
        "documentation": {}
    },
    {
        "label": "ResonanceConfig",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.resonant_mandala",
        "description": "src.word_manifold.visualization.engines.resonant_mandala",
        "peekOfCode": "class ResonanceConfig:\n    \"\"\"Configuration for resonance exploration.\"\"\"\n    primary_field: ResonanceField\n    secondary_fields: Set[ResonanceField]\n    intensity: float = 0.7  # How strongly to tap into the field\n    evolution_rate: float = 0.3  # How quickly patterns evolve\n    narrative_coherence: float = 0.5  # How strongly to maintain story threads\n    meditation_depth: int = 3  # Levels of recursive exploration\n    collective_resonance: bool = False  # Whether to participate in network resonance\n@dataclass",
        "detail": "src.word_manifold.visualization.engines.resonant_mandala",
        "documentation": {}
    },
    {
        "label": "CollectiveState",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.resonant_mandala",
        "description": "src.word_manifold.visualization.engines.resonant_mandala",
        "peekOfCode": "class CollectiveState:\n    \"\"\"State information for collective resonance.\"\"\"\n    participating_nodes: Set[str]\n    field_strengths: Dict[ResonanceField, float]\n    shared_patterns: Dict[str, np.ndarray]\n    collective_coherence: float\n    last_update: datetime\n@ray.remote\nclass ResonanceWorker:\n    \"\"\"Distributed worker for exploring resonance patterns.\"\"\"",
        "detail": "src.word_manifold.visualization.engines.resonant_mandala",
        "documentation": {}
    },
    {
        "label": "ResonanceWorker",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.resonant_mandala",
        "description": "src.word_manifold.visualization.engines.resonant_mandala",
        "peekOfCode": "class ResonanceWorker:\n    \"\"\"Distributed worker for exploring resonance patterns.\"\"\"\n    def __init__(self, field: ResonanceField):\n        self.field = field\n        self.patterns = {}\n        self.current_evolution = 0\n        self.collective_state: Optional[CollectiveState] = None\n    def explore_pattern(\n        self,\n        seed_pattern: np.ndarray,",
        "detail": "src.word_manifold.visualization.engines.resonant_mandala",
        "documentation": {}
    },
    {
        "label": "ResonantMandalaEngine",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.resonant_mandala",
        "description": "src.word_manifold.visualization.engines.resonant_mandala",
        "peekOfCode": "class ResonantMandalaEngine:\n    \"\"\"Engine for generating resonant mandalas that tell stories.\"\"\"\n    def __init__(self):\n        self.workers = {\n            field: ResonanceWorker.remote(field)\n            for field in ResonanceField\n        }\n        self.evolution_history = []\n    def generate_resonant_mandala(\n        self,",
        "detail": "src.word_manifold.visualization.engines.resonant_mandala",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.engines.resonant_mandala",
        "description": "src.word_manifold.visualization.engines.resonant_mandala",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ResonanceField(Enum):\n    \"\"\"Core resonance fields that mandalas can tap into.\"\"\"\n    COSMIC_MEMORY = \"cosmic_memory\"      # Universal patterns and cosmic archetypes\n    NATURAL_WISDOM = \"natural_wisdom\"    # Earth's living patterns and rhythms\n    ANCESTRAL_ECHO = \"ancestral_echo\"    # Cultural and historical patterns\n    QUANTUM_DREAM = \"quantum_dream\"      # Quantum-level consciousness patterns\n    MYTHIC_CURRENT = \"mythic_current\"    # Mythological and archetypal streams\n    DREAM_LOGIC = \"dream_logic\"          # Non-linear dream-state patterns\n    EMOTIONAL_FIELD = \"emotional_field\"  # Emotional resonance patterns",
        "detail": "src.word_manifold.visualization.engines.resonant_mandala",
        "documentation": {}
    },
    {
        "label": "Shape",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.shape_engine",
        "description": "src.word_manifold.visualization.engines.shape_engine",
        "peekOfCode": "class Shape:\n    \"\"\"Represents a geometric shape with properties.\"\"\"\n    type: str  # circle, square, triangle, etc.\n    center: Tuple[float, float, float]  # Now supports 3D coordinates\n    size: float\n    rotation: Tuple[float, float, float] = (0.0, 0.0, 0.0)  # 3D rotation\n    color: str = 'blue'\n    alpha: float = 0.7\n    properties: Dict[str, Any] = None\n    def to_dict(self) -> Dict[str, Any]:",
        "detail": "src.word_manifold.visualization.engines.shape_engine",
        "documentation": {}
    },
    {
        "label": "ShapeField",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.shape_engine",
        "description": "src.word_manifold.visualization.engines.shape_engine",
        "peekOfCode": "class ShapeField:\n    \"\"\"Represents a field of shapes with semantic properties.\"\"\"\n    def __init__(self, dimensions: int = 3):\n        self.shapes: List[Shape] = []\n        self.dimensions = dimensions\n        self.width: float = 10.0\n        self.height: float = 10.0\n        self.depth: float = 10.0  # Added for 3D support\n        self.properties: Dict[str, Any] = {}\n    def add_shape(self, shape: Shape) -> None:",
        "detail": "src.word_manifold.visualization.engines.shape_engine",
        "documentation": {}
    },
    {
        "label": "ShapeEngine",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.shape_engine",
        "description": "src.word_manifold.visualization.engines.shape_engine",
        "peekOfCode": "class ShapeEngine:\n    \"\"\"Engine for generating geometric shape visualizations.\"\"\"\n    def __init__(self, dimensions: int = 3):\n        self.dimensions = dimensions\n        # Shape type mappings for semantic properties\n        self.semantic_shapes = {\n            'abstract': 'sphere',  # Updated for 3D\n            'concrete': 'cube',\n            'dynamic': 'cone',\n            'static': 'cylinder'",
        "detail": "src.word_manifold.visualization.engines.shape_engine",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.engines.shape_engine",
        "description": "src.word_manifold.visualization.engines.shape_engine",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass Shape:\n    \"\"\"Represents a geometric shape with properties.\"\"\"\n    type: str  # circle, square, triangle, etc.\n    center: Tuple[float, float, float]  # Now supports 3D coordinates\n    size: float\n    rotation: Tuple[float, float, float] = (0.0, 0.0, 0.0)  # 3D rotation\n    color: str = 'blue'\n    alpha: float = 0.7",
        "detail": "src.word_manifold.visualization.engines.shape_engine",
        "documentation": {}
    },
    {
        "label": "PatternType",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.timeseries",
        "description": "src.word_manifold.visualization.engines.timeseries",
        "peekOfCode": "class PatternType(Enum):\n    \"\"\"Types of temporal patterns that can be generated.\"\"\"\n    CYCLIC = \"cyclic\"\n    LINEAR = \"linear\"\n    HARMONIC = \"harmonic\"\n    SPIRAL = \"spiral\"\n    WAVE = \"wave\"\nclass TimeSeriesEngine(VisualizationEngine):\n    \"\"\"Engine for generating time series patterns and analysis.\"\"\"\n    def __init__(",
        "detail": "src.word_manifold.visualization.engines.timeseries",
        "documentation": {}
    },
    {
        "label": "TimeSeriesEngine",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.timeseries",
        "description": "src.word_manifold.visualization.engines.timeseries",
        "peekOfCode": "class TimeSeriesEngine(VisualizationEngine):\n    \"\"\"Engine for generating time series patterns and analysis.\"\"\"\n    def __init__(\n        self,\n        word_embeddings: Optional[WordEmbeddings] = None,\n        pattern_type: str = \"cyclic\",\n        timeframe: str = \"1d\",\n        interval: str = \"1h\"\n    ):\n        \"\"\"",
        "detail": "src.word_manifold.visualization.engines.timeseries",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.engines.timeseries",
        "description": "src.word_manifold.visualization.engines.timeseries",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass PatternType(Enum):\n    \"\"\"Types of temporal patterns that can be generated.\"\"\"\n    CYCLIC = \"cyclic\"\n    LINEAR = \"linear\"\n    HARMONIC = \"harmonic\"\n    SPIRAL = \"spiral\"\n    WAVE = \"wave\"\nclass TimeSeriesEngine(VisualizationEngine):\n    \"\"\"Engine for generating time series patterns and analysis.\"\"\"",
        "detail": "src.word_manifold.visualization.engines.timeseries",
        "documentation": {}
    },
    {
        "label": "ASCIIRenderer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.renderers.ascii",
        "description": "src.word_manifold.visualization.renderers.ascii",
        "peekOfCode": "class ASCIIRenderer:\n    \"\"\"Renderer for ASCII art visualizations.\"\"\"\n    # ANSI color codes\n    COLORS = {\n        # Basic colors\n        'black': '\\033[30m',\n        'red': '\\033[31m',\n        'green': '\\033[32m',\n        'yellow': '\\033[33m',\n        'blue': '\\033[34m',",
        "detail": "src.word_manifold.visualization.renderers.ascii",
        "documentation": {}
    },
    {
        "label": "RenderConfig",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.renderers.ascii_renderer",
        "description": "src.word_manifold.visualization.renderers.ascii_renderer",
        "peekOfCode": "class RenderConfig:\n    \"\"\"Configuration for ASCII rendering.\"\"\"\n    use_external_api: bool = True\n    api_timeout: int = 5\n    max_retries: int = 3\n    font: str = \"standard\"\n    width: int = 80\n    height: int = 40\n    color_support: bool = True\nclass ASCIIRenderer:",
        "detail": "src.word_manifold.visualization.renderers.ascii_renderer",
        "documentation": {}
    },
    {
        "label": "ASCIIRenderer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.renderers.ascii_renderer",
        "description": "src.word_manifold.visualization.renderers.ascii_renderer",
        "peekOfCode": "class ASCIIRenderer:\n    \"\"\"Renderer for ASCII art visualizations with API support.\"\"\"\n    def __init__(self, config: Optional[RenderConfig] = None):\n        \"\"\"Initialize renderer with configuration.\"\"\"\n        self.config = config or RenderConfig()\n        self.supports_color = self._check_color_support()\n        self._cached_patterns: Dict[str, str] = {}\n    def render_pattern(\n        self,\n        pattern: Union[str, Dict],",
        "detail": "src.word_manifold.visualization.renderers.ascii_renderer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.renderers.ascii_renderer",
        "description": "src.word_manifold.visualization.renderers.ascii_renderer",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# API endpoints\nASCII_ART_API = \"https://artii.herokuapp.com/make\"\nTEXT_TO_ASCII_API = \"https://asciified.thelicato.io/api/v2/ascii\"\n@dataclass\nclass RenderConfig:\n    \"\"\"Configuration for ASCII rendering.\"\"\"\n    use_external_api: bool = True\n    api_timeout: int = 5\n    max_retries: int = 3",
        "detail": "src.word_manifold.visualization.renderers.ascii_renderer",
        "documentation": {}
    },
    {
        "label": "ASCII_ART_API",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.renderers.ascii_renderer",
        "description": "src.word_manifold.visualization.renderers.ascii_renderer",
        "peekOfCode": "ASCII_ART_API = \"https://artii.herokuapp.com/make\"\nTEXT_TO_ASCII_API = \"https://asciified.thelicato.io/api/v2/ascii\"\n@dataclass\nclass RenderConfig:\n    \"\"\"Configuration for ASCII rendering.\"\"\"\n    use_external_api: bool = True\n    api_timeout: int = 5\n    max_retries: int = 3\n    font: str = \"standard\"\n    width: int = 80",
        "detail": "src.word_manifold.visualization.renderers.ascii_renderer",
        "documentation": {}
    },
    {
        "label": "TEXT_TO_ASCII_API",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.renderers.ascii_renderer",
        "description": "src.word_manifold.visualization.renderers.ascii_renderer",
        "peekOfCode": "TEXT_TO_ASCII_API = \"https://asciified.thelicato.io/api/v2/ascii\"\n@dataclass\nclass RenderConfig:\n    \"\"\"Configuration for ASCII rendering.\"\"\"\n    use_external_api: bool = True\n    api_timeout: int = 5\n    max_retries: int = 3\n    font: str = \"standard\"\n    width: int = 80\n    height: int = 40",
        "detail": "src.word_manifold.visualization.renderers.ascii_renderer",
        "documentation": {}
    },
    {
        "label": "AudioFeatures",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.renderers.image_renderer",
        "description": "src.word_manifold.visualization.renderers.image_renderer",
        "peekOfCode": "class AudioFeatures:\n    \"\"\"Audio analysis features for reactive visualization.\"\"\"\n    waveform: np.ndarray\n    spectrum: np.ndarray\n    onset_env: np.ndarray\n    tempo: float\n    beat_frames: np.ndarray\n    spectral_centroid: np.ndarray\n    spectral_rolloff: np.ndarray\n    mfcc: np.ndarray",
        "detail": "src.word_manifold.visualization.renderers.image_renderer",
        "documentation": {}
    },
    {
        "label": "SubliminalEffect",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.renderers.image_renderer",
        "description": "src.word_manifold.visualization.renderers.image_renderer",
        "peekOfCode": "class SubliminalEffect:\n    \"\"\"Manages subliminal and superliminal visual effects.\"\"\"\n    def __init__(self, duration_ms: float = 16.7):  # One frame at 60fps\n        self.duration_ms = duration_ms\n        self.symbols = {\n            'protection': '',\n            'wisdom': '',\n            'power': '',\n            'harmony': '',\n            'transformation': '',",
        "detail": "src.word_manifold.visualization.renderers.image_renderer",
        "documentation": {}
    },
    {
        "label": "AudioReactiveRenderer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.renderers.image_renderer",
        "description": "src.word_manifold.visualization.renderers.image_renderer",
        "peekOfCode": "class AudioReactiveRenderer:\n    \"\"\"Handles audio analysis and reactive effects.\"\"\"\n    def __init__(self, sr: int = 44100, hop_length: int = 512):\n        self.sr = sr\n        self.hop_length = hop_length\n        self.current_frame = 0\n        self.features = None\n    def load_audio(self, audio_path: str) -> AudioFeatures:\n        \"\"\"Load and analyze audio file.\"\"\"\n        # Load audio",
        "detail": "src.word_manifold.visualization.renderers.image_renderer",
        "documentation": {}
    },
    {
        "label": "ImageRenderer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.renderers.image_renderer",
        "description": "src.word_manifold.visualization.renderers.image_renderer",
        "peekOfCode": "class ImageRenderer:\n    \"\"\"Renders ASCII patterns as high-quality images with audio reactivity and subliminal effects.\"\"\"\n    def __init__(self, font_size: int = 20, padding: int = 2):\n        \"\"\"Initialize the image renderer.\n        Args:\n            font_size: Base font size for characters\n            padding: Padding between characters\n        \"\"\"\n        self.font_size = font_size\n        self.padding = padding",
        "detail": "src.word_manifold.visualization.renderers.image_renderer",
        "documentation": {}
    },
    {
        "label": "InteractiveRenderer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.renderers.interactive",
        "description": "src.word_manifold.visualization.renderers.interactive",
        "peekOfCode": "class InteractiveRenderer:\n    \"\"\"Renderer for interactive visualizations.\"\"\"\n    def __init__(self):\n        # Default configuration\n        self.config = {\n            'plot_bgcolor': '#111111',\n            'paper_bgcolor': '#111111',\n            'font': {\n                'color': '#ffffff',\n                'family': 'Arial, sans-serif'",
        "detail": "src.word_manifold.visualization.renderers.interactive",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.renderers.interactive",
        "description": "src.word_manifold.visualization.renderers.interactive",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass InteractiveRenderer:\n    \"\"\"Renderer for interactive visualizations.\"\"\"\n    def __init__(self):\n        # Default configuration\n        self.config = {\n            'plot_bgcolor': '#111111',\n            'paper_bgcolor': '#111111',\n            'font': {\n                'color': '#ffffff',",
        "detail": "src.word_manifold.visualization.renderers.interactive",
        "documentation": {}
    },
    {
        "label": "ShapeRenderer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.renderers.shape_renderer",
        "description": "src.word_manifold.visualization.renderers.shape_renderer",
        "peekOfCode": "class ShapeRenderer:\n    \"\"\"Renderer for geometric shape visualizations.\"\"\"\n    def __init__(self):\n        # Default style configuration\n        self.style = {\n            'figure.figsize': (10, 10),\n            'figure.dpi': 100,\n            'figure.facecolor': 'white',\n            'axes.facecolor': '#f0f0f0',\n            'axes.grid': True,",
        "detail": "src.word_manifold.visualization.renderers.shape_renderer",
        "documentation": {}
    },
    {
        "label": "ThreeRenderer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.renderers.three_renderer",
        "description": "src.word_manifold.visualization.renderers.three_renderer",
        "peekOfCode": "class ThreeRenderer:\n    \"\"\"Renderer for 3D visualizations using Three.js.\"\"\"\n    def __init__(self,\n                 template_dir: Optional[str] = None,\n                 port: int = 5000,\n                 background_color: Color = \"#000000\",\n                 ambient_intensity: float = 0.4,\n                 directional_intensity: float = 0.6,\n                 projection_type: str = \"stereographic\"):\n        \"\"\"",
        "detail": "src.word_manifold.visualization.renderers.three_renderer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.renderers.three_renderer",
        "description": "src.word_manifold.visualization.renderers.three_renderer",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Type aliases\nPoint3D = Sequence[float]  # (x, y, z)\nPoint = Sequence[float]    # n-dimensional point\nColor = str               # hex color string\nclass ThreeRenderer:\n    \"\"\"Renderer for 3D visualizations using Three.js.\"\"\"\n    def __init__(self,\n                 template_dir: Optional[str] = None,\n                 port: int = 5000,",
        "detail": "src.word_manifold.visualization.renderers.three_renderer",
        "documentation": {}
    },
    {
        "label": "Point3D",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.renderers.three_renderer",
        "description": "src.word_manifold.visualization.renderers.three_renderer",
        "peekOfCode": "Point3D = Sequence[float]  # (x, y, z)\nPoint = Sequence[float]    # n-dimensional point\nColor = str               # hex color string\nclass ThreeRenderer:\n    \"\"\"Renderer for 3D visualizations using Three.js.\"\"\"\n    def __init__(self,\n                 template_dir: Optional[str] = None,\n                 port: int = 5000,\n                 background_color: Color = \"#000000\",\n                 ambient_intensity: float = 0.4,",
        "detail": "src.word_manifold.visualization.renderers.three_renderer",
        "documentation": {}
    },
    {
        "label": "Point",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.renderers.three_renderer",
        "description": "src.word_manifold.visualization.renderers.three_renderer",
        "peekOfCode": "Point = Sequence[float]    # n-dimensional point\nColor = str               # hex color string\nclass ThreeRenderer:\n    \"\"\"Renderer for 3D visualizations using Three.js.\"\"\"\n    def __init__(self,\n                 template_dir: Optional[str] = None,\n                 port: int = 5000,\n                 background_color: Color = \"#000000\",\n                 ambient_intensity: float = 0.4,\n                 directional_intensity: float = 0.6,",
        "detail": "src.word_manifold.visualization.renderers.three_renderer",
        "documentation": {}
    },
    {
        "label": "Color",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.renderers.three_renderer",
        "description": "src.word_manifold.visualization.renderers.three_renderer",
        "peekOfCode": "Color = str               # hex color string\nclass ThreeRenderer:\n    \"\"\"Renderer for 3D visualizations using Three.js.\"\"\"\n    def __init__(self,\n                 template_dir: Optional[str] = None,\n                 port: int = 5000,\n                 background_color: Color = \"#000000\",\n                 ambient_intensity: float = 0.4,\n                 directional_intensity: float = 0.6,\n                 projection_type: str = \"stereographic\"):",
        "detail": "src.word_manifold.visualization.renderers.three_renderer",
        "documentation": {}
    },
    {
        "label": "TimeSeriesRenderer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.renderers.timeseries",
        "description": "src.word_manifold.visualization.renderers.timeseries",
        "peekOfCode": "class TimeSeriesRenderer(VisualizationRenderer):\n    \"\"\"Renderer for time series visualizations.\"\"\"\n    def __init__(\n        self,\n        cloud_provider: Optional[str] = None,\n        cloud_credentials: Optional[Dict[str, Any]] = None\n    ):\n        \"\"\"Initialize the renderer.\n        Args:\n            cloud_provider: Optional cloud provider for remote visualization",
        "detail": "src.word_manifold.visualization.renderers.timeseries",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.renderers.timeseries",
        "description": "src.word_manifold.visualization.renderers.timeseries",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass TimeSeriesRenderer(VisualizationRenderer):\n    \"\"\"Renderer for time series visualizations.\"\"\"\n    def __init__(\n        self,\n        cloud_provider: Optional[str] = None,\n        cloud_credentials: Optional[Dict[str, Any]] = None\n    ):\n        \"\"\"Initialize the renderer.\n        Args:",
        "detail": "src.word_manifold.visualization.renderers.timeseries",
        "documentation": {}
    },
    {
        "label": "VisualizationData",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.base",
        "description": "src.word_manifold.visualization.base",
        "peekOfCode": "class VisualizationData(Protocol):\n    \"\"\"Protocol for visualization data containers.\"\"\"\n    def to_plot_data(self) -> Dict[str, Any]: ...\n    def get_color_map(self) -> Dict[str, str]: ...\n    def get_labels(self) -> Dict[int, str]: ...\nclass VisualizationEngine(ABC):\n    \"\"\"Abstract base class for visualization engines.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize engine.\"\"\"\n        self._data: Optional[Dict[str, Any]] = None",
        "detail": "src.word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "VisualizationEngine",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.base",
        "description": "src.word_manifold.visualization.base",
        "peekOfCode": "class VisualizationEngine(ABC):\n    \"\"\"Abstract base class for visualization engines.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize engine.\"\"\"\n        self._data: Optional[Dict[str, Any]] = None\n    @abstractmethod\n    def process_data(self, *args, **kwargs) -> Dict[str, Any]:\n        \"\"\"Process input data into visualization-ready format.\"\"\"\n        pass\n    @abstractmethod",
        "detail": "src.word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "VisualizationRenderer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.base",
        "description": "src.word_manifold.visualization.base",
        "peekOfCode": "class VisualizationRenderer(ABC):\n    \"\"\"Abstract base class for visualization renderers.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize renderer.\"\"\"\n        self._figure: Optional[Figure] = None\n    @abstractmethod\n    def render_local(\n        self,\n        data: Dict[str, Any],\n        output_path: Path,",
        "detail": "src.word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "InteractiveVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.base",
        "description": "src.word_manifold.visualization.base",
        "peekOfCode": "class InteractiveVisualizer(VisualizationRenderer):\n    \"\"\"Base class for interactive visualizers.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize interactive visualizer.\"\"\"\n        super().__init__()\n        self._is_interactive = True\n    @abstractmethod\n    def update(self) -> None:\n        \"\"\"Update visualization based on current state.\"\"\"\n        pass",
        "detail": "src.word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "lazy_import",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def lazy_import(module_name: str) -> Callable:\n    \"\"\"Lazily import a module only when needed.\"\"\"\n    def get_module():\n        import importlib\n        try:\n            return importlib.import_module(module_name)\n        except ImportError as e:\n            logger.error(f\"Failed to import {module_name}: {e}\")\n            raise click.ClickException(f\"Required module {module_name} not found. Please install required dependencies.\")\n    return get_module",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "validate_server_config",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def validate_server_config(config: Dict) -> Tuple[bool, List[str]]:\n    \"\"\"Validate server configuration.\"\"\"\n    errors = []\n    # Validate server section\n    server = config.get('server', {})\n    if not isinstance(server.get('port', 0), int) or not 0 < server.get('port', 0) < 65536:\n        errors.append(\"Port must be an integer between 1 and 65535\")\n    if not isinstance(server.get('timeout', 0), (int, float)) or server.get('timeout', 0) <= 0:\n        errors.append(\"Timeout must be a positive number\")\n    # Validate security section",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_server_process",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def get_server_process(port: int) -> Optional['psutil.Process']:\n    \"\"\"Find server process by port.\"\"\"\n    if psutil is None:\n        logger.warning(\"psutil not available, cannot detect server process\")\n        return None\n    try:\n        for proc in psutil.process_iter(['pid', 'name']):\n            try:\n                for conn in proc.net_connections(kind='inet'):\n                    if conn.laddr.port == port and conn.status == 'LISTEN':",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def load_config(config_path: Optional[Path] = None) -> Dict:\n    \"\"\"Load configuration from file or return defaults.\"\"\"\n    if config_path and config_path.exists():\n        with open(config_path) as f:\n            user_config = yaml.safe_load(f)\n            # Merge with defaults\n            return {**DEFAULT_CONFIG, **user_config}\n    return DEFAULT_CONFIG\n# Server configuration\nconfig = load_config(Path('word_manifold.yaml'))",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "handle_server_request",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def handle_server_request(method: str, endpoint: str, data: Dict[str, Any] = None, timeout: int = DEFAULT_TIMEOUTS['server']) -> Dict[str, Any]:\n    \"\"\"Handle server request with proper error handling and retries.\"\"\"\n    try:\n        if method.upper() == 'GET':\n            response = requests.get(f'{SERVER_URL}{endpoint}', timeout=timeout)\n        else:\n            response = requests.post(f'{SERVER_URL}{endpoint}', json=data, timeout=timeout)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.Timeout as exc:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "ensure_server_running",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def ensure_server_running():\n    \"\"\"Start visualization server if not running.\"\"\"\n    try:\n        response = requests.get(f'{SERVER_URL}/health', timeout=DEFAULT_TIMEOUTS['health'])\n        if response.status_code == 200:\n            return\n    except (requests.exceptions.ConnectionError, requests.exceptions.Timeout):\n        logger.info(\"Starting visualization server...\")\n        # Import server module only when needed\n        try:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "with_progress",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def with_progress(desc: str = None):\n    \"\"\"Progress bar decorator for long-running operations.\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            with tqdm(desc=desc or func.__name__, leave=True) as pbar:\n                result = func(*args, **kwargs)\n                pbar.update(1)\n                return result\n        return wrapper",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_retry_decorator",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def get_retry_decorator():\n    \"\"\"Get the appropriate retry decorator based on availability.\"\"\"\n    if not RETRY_ENABLED:\n        return lambda x: x  # No-op decorator\n    return retry(\n        stop=stop_after_attempt(3),\n        wait=wait_exponential(multiplier=1, min=4, max=10),\n        retry=retry_if_exception_type((requests.exceptions.Timeout, requests.exceptions.ConnectionError)),\n        before=before_log(logger, logging.DEBUG),\n        after=before_log(logger, logging.DEBUG),",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def cli(debug, config):\n    \"\"\"Word Manifold visualization and analysis tools.\"\"\"\n    # Print package location to verify we're using local source\n    import word_manifold\n    logger.info(f\"Using word-manifold package from: {Path(word_manifold.__file__).parent}\")\n    # Set logging level based on debug flag\n    logger.setLevel(logging.DEBUG if debug else logging.INFO)\n    # Propagate to other loggers\n    logging.getLogger('word_manifold').setLevel(logging.DEBUG if debug else logging.INFO)\n    # Load configuration if provided",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "server",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def server():\n    \"\"\"Server management commands.\"\"\"\n    pass\n@server.command()\n@click.option('--host', default=DEFAULT_HOST, help='Server host address')\n@click.option('--port', default=DEFAULT_PORT, help='Server port')\n@click.option('--remote/--local', default=False, help='Run in remote or local mode')\n@click.option('--workers', default=1, type=int, help='Number of worker processes')\n@click.option('--daemon/--no-daemon', default=False, help='Run server as daemon process')\n@click.option('--debug/--no-debug', default=False, help='Enable debug mode')",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "start",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def start(host: str, port: int, remote: bool, workers: int, daemon: bool, debug: bool):\n    \"\"\"Start the visualization server.\"\"\"\n    try:\n        # Set logging level based on debug flag\n        if debug:\n            logger.setLevel(logging.DEBUG)\n            logging.getLogger('word_manifold').setLevel(logging.DEBUG)\n            logging.getLogger('flask').setLevel(logging.DEBUG)\n        # Check if server is already running\n        if psutil is not None:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "status",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def status(host: str, port: int, config: Optional[Path]):\n    \"\"\"Check detailed server status.\"\"\"\n    url = f\"http://{host}:{port}\"\n    try:\n        # Check basic connectivity\n        health_response = requests.get(f\"{url}/health\", timeout=DEFAULT_TIMEOUTS['health'])\n        if health_response.status_code != 200:\n            click.echo(click.style(\" Server is not healthy\", fg=\"red\"))\n            return\n        # Get process information",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "stop",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def stop(host: str, port: int, force: bool):\n    \"\"\"Stop the server with graceful shutdown.\"\"\"\n    url = f\"http://{host}:{port}/shutdown\"\n    proc = get_server_process(port)\n    try:\n        if not force:\n            # Try graceful shutdown first\n            response = requests.post(url, timeout=DEFAULT_TIMEOUTS['shutdown'])\n            if response.status_code == 200:\n                click.echo(click.style(\" Server stopped gracefully\", fg=\"green\"))",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "restart",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def restart(host: str, port: int):\n    \"\"\"Restart the server.\"\"\"\n    try:\n        # Stop server\n        click.echo(\"Stopping server...\")\n        stop.callback(host=host, port=port, force=False)\n        # Wait for port to be available\n        max_wait = 10\n        for i in range(max_wait):\n            if not get_server_process(port):",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "visualize",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def visualize(interactive, output_dir, dimensions, model):\n    \"\"\"Create visualizations of the word manifold.\"\"\"\n    try:\n        # Initialize embeddings and manifold\n        embeddings = get_word_embeddings().WordEmbeddings(model_name=model)\n        # Define example terms\n        terms = [\n            \"light\", \"darkness\", \"wisdom\", \"understanding\",\n            \"beauty\", \"strength\", \"mercy\", \"severity\"\n        ]",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "symbolic",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def symbolic(text: str, output_dir: str, width: int, height: int):\n    \"\"\"Create symbolic visualizations of text.\"\"\"\n    try:\n        # Lazy load dependencies\n        WordEmbeddings = get_word_embeddings().WordEmbeddings\n        SymbolicVisualizer = get_symbolic_vis().SymbolicVisualizer\n        embeddings = WordEmbeddings()\n        visualizer = SymbolicVisualizer(embeddings, width=width, height=height)\n        output_path = Path(output_dir)\n        output_path.mkdir(parents=True, exist_ok=True)",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "semantic_tree",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def semantic_tree(text: str, output_dir: str, max_depth: int, branching_factor: int):\n    \"\"\"Generate semantic tree visualization for text.\"\"\"\n    try:\n        embeddings = get_word_embeddings().WordEmbeddings()\n        visualizer = get_semantic_tree().SemanticTreeVisualizer(embeddings)\n        # Find related terms\n        related_terms = []\n        for term in text.split():\n            similar = embeddings.find_similar_terms(term, k=5)\n            related_terms.extend([t for t, _ in similar])",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def shapes(text: str, output_dir: str, chunk_size: int):\n    \"\"\"Generate shape field visualizations for text.\"\"\"\n    try:\n        visualizer = get_shape_vis().ShapeVisualizer()\n        output_path = Path(output_dir)\n        output_path.mkdir(parents=True, exist_ok=True)\n        # Create shape field visualization\n        visualizer.create_shape_field(text, chunk_size=chunk_size)\n        # Move generated files to output directory\n        for file in Path('.').glob('shape_field*.png'):",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "automata",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def automata(text: str, rule: str, output_dir: str, iterations: int):\n    \"\"\"Apply cellular automata rules to transform text.\"\"\"\n    try:\n        embeddings = get_word_embeddings().WordEmbeddings()\n        manifold = get_vector_manifold().VectorManifold(embeddings)\n        rules = get_cellular_rules().create_predefined_rules()\n        # Initialize manifold with text\n        for term in text.split():\n            vector = embeddings.get_embedding(term)\n            if vector is not None:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "manifold",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def manifold(terms: List[str], model: str, dimensions: int, output: str, save_format: str):\n    \"\"\"Generate static manifold visualization for given terms.\"\"\"\n    ensure_server_running()\n    try:\n        # Validate input\n        if not terms:\n            raise click.ClickException(\"Please provide at least one term to visualize\")\n        if dimensions < 2 or dimensions > 3:\n            raise click.ClickException(\"Dimensions must be 2 or 3\")\n        # Create output directory",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "timeseries",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def timeseries(\n    terms: Optional[List[str]],\n    timeframe: str,\n    interval: str,\n    output_dir: str,\n    casting_method: str,\n    local: bool,\n    server_url: Optional[str],\n    pattern_type: str,\n    cloud_provider: Optional[str],",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "hexagrams",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def hexagrams(text: Optional[str], output_dir: str, casting_method: str):\n    \"\"\"Generate hexagram-based visualizations for text transformations. If no text is provided, casts the oracle bones.\"\"\"\n    try:\n        # Import required modules\n        from word_manifold.automata.hexagram_rules import (\n            create_hexagram_rules, cast_hexagram, get_default_text,\n            CastingMethod\n        )\n        from word_manifold.visualization.hexagram_visualizer import HexagramVisualizer\n        from word_manifold.embeddings.word_embeddings import WordEmbeddings",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "ascii",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def ascii(\n    pattern_type: str,\n    width: int,\n    height: int,\n    radius: int,\n    complexity: float,\n    density: float,\n    style: str,\n    field_type: str,\n    wave_type: str,",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef lazy_import(module_name: str) -> Callable:\n    \"\"\"Lazily import a module only when needed.\"\"\"\n    def get_module():\n        import importlib\n        try:\n            return importlib.import_module(module_name)\n        except ImportError as e:\n            logger.error(f\"Failed to import {module_name}: {e}\")\n            raise click.ClickException(f\"Required module {module_name} not found. Please install required dependencies.\")",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_word_embeddings",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_word_embeddings = lazy_import('word_manifold.embeddings.word_embeddings')\nget_vector_manifold = lazy_import('word_manifold.manifold.vector_manifold')\nget_hypertools = lazy_import('word_manifold.visualization.hypertools_visualizer')\nget_shape_vis = lazy_import('word_manifold.visualization.shape_visualizer')\nget_symbolic_vis = lazy_import('word_manifold.visualization.symbolic_visualizer')\nget_semantic_tree = lazy_import('word_manifold.visualization.semantic_tree_visualizer')\nget_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_vector_manifold",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_vector_manifold = lazy_import('word_manifold.manifold.vector_manifold')\nget_hypertools = lazy_import('word_manifold.visualization.hypertools_visualizer')\nget_shape_vis = lazy_import('word_manifold.visualization.shape_visualizer')\nget_symbolic_vis = lazy_import('word_manifold.visualization.symbolic_visualizer')\nget_semantic_tree = lazy_import('word_manifold.visualization.semantic_tree_visualizer')\nget_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_hypertools",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_hypertools = lazy_import('word_manifold.visualization.hypertools_visualizer')\nget_shape_vis = lazy_import('word_manifold.visualization.shape_visualizer')\nget_symbolic_vis = lazy_import('word_manifold.visualization.symbolic_visualizer')\nget_semantic_tree = lazy_import('word_manifold.visualization.semantic_tree_visualizer')\nget_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\nget_ascii_engine = lazy_import('word_manifold.visualization.engines.ascii')",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_shape_vis",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_shape_vis = lazy_import('word_manifold.visualization.shape_visualizer')\nget_symbolic_vis = lazy_import('word_manifold.visualization.symbolic_visualizer')\nget_semantic_tree = lazy_import('word_manifold.visualization.semantic_tree_visualizer')\nget_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\nget_ascii_engine = lazy_import('word_manifold.visualization.engines.ascii')\nget_ascii_renderer = lazy_import('word_manifold.visualization.renderers.ascii')",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_symbolic_vis",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_symbolic_vis = lazy_import('word_manifold.visualization.symbolic_visualizer')\nget_semantic_tree = lazy_import('word_manifold.visualization.semantic_tree_visualizer')\nget_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\nget_ascii_engine = lazy_import('word_manifold.visualization.engines.ascii')\nget_ascii_renderer = lazy_import('word_manifold.visualization.renderers.ascii')\n# Progress bar support (lightweight)",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_semantic_tree",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_semantic_tree = lazy_import('word_manifold.visualization.semantic_tree_visualizer')\nget_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\nget_ascii_engine = lazy_import('word_manifold.visualization.engines.ascii')\nget_ascii_renderer = lazy_import('word_manifold.visualization.renderers.ascii')\n# Progress bar support (lightweight)\ntry:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_manifold_vis",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\nget_ascii_engine = lazy_import('word_manifold.visualization.engines.ascii')\nget_ascii_renderer = lazy_import('word_manifold.visualization.renderers.ascii')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_interactive_vis",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\nget_ascii_engine = lazy_import('word_manifold.visualization.engines.ascii')\nget_ascii_renderer = lazy_import('word_manifold.visualization.renderers.ascii')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm\nexcept ImportError:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_cellular_rules",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\nget_ascii_engine = lazy_import('word_manifold.visualization.engines.ascii')\nget_ascii_renderer = lazy_import('word_manifold.visualization.renderers.ascii')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm\nexcept ImportError:\n    # Fallback progress bar if tqdm not available",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_server",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\nget_ascii_engine = lazy_import('word_manifold.visualization.engines.ascii')\nget_ascii_renderer = lazy_import('word_manifold.visualization.renderers.ascii')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm\nexcept ImportError:\n    # Fallback progress bar if tqdm not available\n    class tqdm:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_remote_server",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_remote_server = lazy_import('word_manifold.visualization.remote_server')\nget_ascii_engine = lazy_import('word_manifold.visualization.engines.ascii')\nget_ascii_renderer = lazy_import('word_manifold.visualization.renderers.ascii')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm\nexcept ImportError:\n    # Fallback progress bar if tqdm not available\n    class tqdm:\n        def __init__(self, *args, **kwargs):",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_ascii_engine",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_ascii_engine = lazy_import('word_manifold.visualization.engines.ascii')\nget_ascii_renderer = lazy_import('word_manifold.visualization.renderers.ascii')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm\nexcept ImportError:\n    # Fallback progress bar if tqdm not available\n    class tqdm:\n        def __init__(self, *args, **kwargs):\n            pass",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_ascii_renderer",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_ascii_renderer = lazy_import('word_manifold.visualization.renderers.ascii')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm\nexcept ImportError:\n    # Fallback progress bar if tqdm not available\n    class tqdm:\n        def __init__(self, *args, **kwargs):\n            pass\n        def __enter__(self):",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "DEFAULT_HOST",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "DEFAULT_HOST = 'localhost'\nDEFAULT_PORT = 5000\nDEFAULT_TIMEOUTS = {\n    'server': 15,      # Default server request timeout\n    'health': 5,       # Health check timeout\n    'shutdown': 10,    # Graceful shutdown timeout\n    'startup': 30,     # Server startup timeout\n    'process': 5,      # Process operation timeout\n}\nSERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PORT",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "DEFAULT_PORT = 5000\nDEFAULT_TIMEOUTS = {\n    'server': 15,      # Default server request timeout\n    'health': 5,       # Health check timeout\n    'shutdown': 10,    # Graceful shutdown timeout\n    'startup': 30,     # Server startup timeout\n    'process': 5,      # Process operation timeout\n}\nSERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n# Default configuration",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TIMEOUTS",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "DEFAULT_TIMEOUTS = {\n    'server': 15,      # Default server request timeout\n    'health': 5,       # Health check timeout\n    'shutdown': 10,    # Graceful shutdown timeout\n    'startup': 30,     # Server startup timeout\n    'process': 5,      # Process operation timeout\n}\nSERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n# Default configuration\nDEFAULT_CONFIG = {",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "SERVER_URL",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "SERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n# Default configuration\nDEFAULT_CONFIG = {\n    'server': {\n        'host': DEFAULT_HOST,\n        'port': DEFAULT_PORT,\n        'timeout': DEFAULT_TIMEOUTS['server'],\n        'max_workers': 4,\n        'request_queue_size': 100,\n        'max_connections': 1000,",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONFIG",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "DEFAULT_CONFIG = {\n    'server': {\n        'host': DEFAULT_HOST,\n        'port': DEFAULT_PORT,\n        'timeout': DEFAULT_TIMEOUTS['server'],\n        'max_workers': 4,\n        'request_queue_size': 100,\n        'max_connections': 1000,\n        'shutdown_timeout': DEFAULT_TIMEOUTS['shutdown'],\n    },",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "config = load_config(Path('word_manifold.yaml'))\nDEFAULT_HOST = config['server']['host']\nDEFAULT_PORT = config['server']['port']\nSERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=4, max=10),\n    retry=retry_if_exception_type((requests.exceptions.Timeout, requests.exceptions.ConnectionError))\n)\ndef handle_server_request(method: str, endpoint: str, data: Dict[str, Any] = None, timeout: int = DEFAULT_TIMEOUTS['server']) -> Dict[str, Any]:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "DEFAULT_HOST",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "DEFAULT_HOST = config['server']['host']\nDEFAULT_PORT = config['server']['port']\nSERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=4, max=10),\n    retry=retry_if_exception_type((requests.exceptions.Timeout, requests.exceptions.ConnectionError))\n)\ndef handle_server_request(method: str, endpoint: str, data: Dict[str, Any] = None, timeout: int = DEFAULT_TIMEOUTS['server']) -> Dict[str, Any]:\n    \"\"\"Handle server request with proper error handling and retries.\"\"\"",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PORT",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "DEFAULT_PORT = config['server']['port']\nSERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=4, max=10),\n    retry=retry_if_exception_type((requests.exceptions.Timeout, requests.exceptions.ConnectionError))\n)\ndef handle_server_request(method: str, endpoint: str, data: Dict[str, Any] = None, timeout: int = DEFAULT_TIMEOUTS['server']) -> Dict[str, Any]:\n    \"\"\"Handle server request with proper error handling and retries.\"\"\"\n    try:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "SERVER_URL",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "SERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=4, max=10),\n    retry=retry_if_exception_type((requests.exceptions.Timeout, requests.exceptions.ConnectionError))\n)\ndef handle_server_request(method: str, endpoint: str, data: Dict[str, Any] = None, timeout: int = DEFAULT_TIMEOUTS['server']) -> Dict[str, Any]:\n    \"\"\"Handle server request with proper error handling and retries.\"\"\"\n    try:\n        if method.upper() == 'GET':",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "CloudStorageProvider",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.cloud_services",
        "description": "src.word_manifold.visualization.cloud_services",
        "peekOfCode": "class CloudStorageProvider:\n    \"\"\"Base class for cloud storage providers.\"\"\"\n    def __init__(self, credentials: Optional[Dict[str, Any]] = None):\n        self.credentials = credentials or {}\n    def upload(self, file_path: Path, remote_path: str) -> str:\n        \"\"\"Upload a file to cloud storage.\n        Args:\n            file_path: Local path to file\n            remote_path: Remote path/key for storage\n        Returns:",
        "detail": "src.word_manifold.visualization.cloud_services",
        "documentation": {}
    },
    {
        "label": "S3Provider",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.cloud_services",
        "description": "src.word_manifold.visualization.cloud_services",
        "peekOfCode": "class S3Provider(CloudStorageProvider):\n    \"\"\"AWS S3 storage provider.\"\"\"\n    def __init__(self, credentials: Optional[Dict[str, Any]] = None):\n        super().__init__(credentials)\n        if 'boto3' not in CLOUD_MODULES:\n            raise ImportError(\"AWS S3 support requires boto3 package\")\n        self.s3 = CLOUD_MODULES['boto3'].client(\n            's3',\n            aws_access_key_id=credentials.get('aws_access_key_id'),\n            aws_secret_access_key=credentials.get('aws_secret_access_key'),",
        "detail": "src.word_manifold.visualization.cloud_services",
        "documentation": {}
    },
    {
        "label": "GCSProvider",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.cloud_services",
        "description": "src.word_manifold.visualization.cloud_services",
        "peekOfCode": "class GCSProvider(CloudStorageProvider):\n    \"\"\"Google Cloud Storage provider.\"\"\"\n    def __init__(self, credentials: Optional[Dict[str, Any]] = None):\n        super().__init__(credentials)\n        if 'gcs' not in CLOUD_MODULES:\n            raise ImportError(\"Google Cloud Storage support requires google-cloud-storage package\")\n        self.storage_client = CLOUD_MODULES['gcs'].Client.from_service_account_info(credentials)\n        self.bucket = self.storage_client.bucket(credentials.get('bucket_name'))\n    def upload(self, file_path: Path, remote_path: str) -> str:\n        try:",
        "detail": "src.word_manifold.visualization.cloud_services",
        "documentation": {}
    },
    {
        "label": "AzureProvider",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.cloud_services",
        "description": "src.word_manifold.visualization.cloud_services",
        "peekOfCode": "class AzureProvider(CloudStorageProvider):\n    \"\"\"Azure Blob Storage provider.\"\"\"\n    def __init__(self, credentials: Optional[Dict[str, Any]] = None):\n        super().__init__(credentials)\n        if 'azure' not in CLOUD_MODULES:\n            raise ImportError(\"Azure Blob Storage support requires azure-storage-blob package\")\n        self.blob_service = CLOUD_MODULES['azure'].BlobServiceClient(\n            account_url=f\"https://{credentials.get('account_name')}.blob.core.windows.net\",\n            credential=credentials.get('account_key')\n        )",
        "detail": "src.word_manifold.visualization.cloud_services",
        "documentation": {}
    },
    {
        "label": "HuggingFaceProvider",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.cloud_services",
        "description": "src.word_manifold.visualization.cloud_services",
        "peekOfCode": "class HuggingFaceProvider(CloudStorageProvider):\n    \"\"\"HuggingFace Spaces provider.\"\"\"\n    def __init__(self, credentials: Optional[Dict[str, Any]] = None):\n        super().__init__(credentials)\n        if 'huggingface_hub' not in CLOUD_MODULES:\n            raise ImportError(\"HuggingFace support requires huggingface-hub package\")\n        self.api = CLOUD_MODULES['huggingface_hub'].HfApi()\n        self.token = credentials.get('token')\n        self.space_id = credentials.get('space_id')\n    def upload(self, file_path: Path, remote_path: str) -> str:",
        "detail": "src.word_manifold.visualization.cloud_services",
        "documentation": {}
    },
    {
        "label": "CloudVisualizationService",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.cloud_services",
        "description": "src.word_manifold.visualization.cloud_services",
        "peekOfCode": "class CloudVisualizationService:\n    \"\"\"Service for managing cloud-based visualizations.\"\"\"\n    PROVIDERS = {\n        's3': S3Provider,\n        'gcs': GCSProvider,\n        'azure': AzureProvider,\n        'huggingface': HuggingFaceProvider\n    }\n    def __init__(self, provider: str = 'huggingface', credentials: Optional[Dict[str, Any]] = None):\n        \"\"\"Initialize the cloud visualization service.",
        "detail": "src.word_manifold.visualization.cloud_services",
        "documentation": {}
    },
    {
        "label": "import_cloud_modules",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cloud_services",
        "description": "src.word_manifold.visualization.cloud_services",
        "peekOfCode": "def import_cloud_modules():\n    modules = {}\n    try:\n        modules['boto3'] = importlib.import_module('boto3')\n    except ImportError:\n        logger.debug(\"AWS S3 support not available - boto3 not installed\")\n    try:\n        modules['gcs'] = importlib.import_module('google.cloud.storage')\n    except ImportError:\n        logger.debug(\"Google Cloud Storage support not available - google-cloud-storage not installed\")",
        "detail": "src.word_manifold.visualization.cloud_services",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cloud_services",
        "description": "src.word_manifold.visualization.cloud_services",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Optional imports for cloud providers\ndef import_cloud_modules():\n    modules = {}\n    try:\n        modules['boto3'] = importlib.import_module('boto3')\n    except ImportError:\n        logger.debug(\"AWS S3 support not available - boto3 not installed\")\n    try:\n        modules['gcs'] = importlib.import_module('google.cloud.storage')",
        "detail": "src.word_manifold.visualization.cloud_services",
        "documentation": {}
    },
    {
        "label": "CLOUD_MODULES",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cloud_services",
        "description": "src.word_manifold.visualization.cloud_services",
        "peekOfCode": "CLOUD_MODULES = import_cloud_modules()\nclass CloudStorageProvider:\n    \"\"\"Base class for cloud storage providers.\"\"\"\n    def __init__(self, credentials: Optional[Dict[str, Any]] = None):\n        self.credentials = credentials or {}\n    def upload(self, file_path: Path, remote_path: str) -> str:\n        \"\"\"Upload a file to cloud storage.\n        Args:\n            file_path: Local path to file\n            remote_path: Remote path/key for storage",
        "detail": "src.word_manifold.visualization.cloud_services",
        "documentation": {}
    },
    {
        "label": "HexagramVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.hexagram_visualizer",
        "description": "src.word_manifold.visualization.hexagram_visualizer",
        "peekOfCode": "class HexagramVisualizer:\n    \"\"\"Visualizer for hexagram-based transformations.\"\"\"\n    # Visual constants\n    LINE_LENGTH = 1.0\n    LINE_SPACING = 0.3\n    YIN_GAP = 0.2\n    LINE_THICKNESS = 0.1\n    # Colors for different aspects\n    COLORS = {\n        'yang': '#E74C3C',  # Red for yang energy",
        "detail": "src.word_manifold.visualization.hexagram_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.hexagram_visualizer",
        "description": "src.word_manifold.visualization.hexagram_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HexagramVisualizer:\n    \"\"\"Visualizer for hexagram-based transformations.\"\"\"\n    # Visual constants\n    LINE_LENGTH = 1.0\n    LINE_SPACING = 0.3\n    YIN_GAP = 0.2\n    LINE_THICKNESS = 0.1\n    # Colors for different aspects\n    COLORS = {",
        "detail": "src.word_manifold.visualization.hexagram_visualizer",
        "documentation": {}
    },
    {
        "label": "VisualizationLayer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.hypertools_visualizer",
        "description": "src.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "class VisualizationLayer:\n    \"\"\"A layer in the visualization stack.\"\"\"\n    def __init__(self, name: str, visible: bool = True):\n        self.name = name\n        self.visible = visible\n        self.data = {}\n        self.style = {}\n    def update(self, data: Dict[str, Any]) -> None:\n        \"\"\"Update layer data.\"\"\"\n        self.data.update(data)",
        "detail": "src.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.hypertools_visualizer",
        "description": "src.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "class HyperToolsVisualizer:\n    \"\"\"Visualizer for high-dimensional data using HyperTools.\"\"\"\n    def __init__(self, \n                 word_embeddings: WordEmbeddings,\n                 output_dir: str = \"visualizations/hypertools\",\n                 interactive: bool = False,\n                 n_dimensions: int = 3,\n                 reduction_method: str = \"UMAP\",\n                 enable_sacred_geometry: bool = True,\n                 enable_audio: bool = False):",
        "detail": "src.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.hypertools_visualizer",
        "description": "src.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Filter specific warnings\nwarnings.filterwarnings('ignore', category=FutureWarning, module='sklearn')\nwarnings.filterwarnings('ignore', category=UserWarning, module='umap')\nclass VisualizationLayer:\n    \"\"\"A layer in the visualization stack.\"\"\"\n    def __init__(self, name: str, visible: bool = True):\n        self.name = name\n        self.visible = visible\n        self.data = {}",
        "detail": "src.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "InteractiveManifoldVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.interactive",
        "description": "src.word_manifold.visualization.interactive",
        "peekOfCode": "class InteractiveManifoldVisualizer(InteractiveVisualizer):\n    \"\"\"Interactive visualizer for manifold structures with parameter controls.\"\"\"\n    def __init__(self, embeddings: np.ndarray, terms: List[List[str]]):\n        \"\"\"Initialize interactive visualizer.\n        Args:\n            embeddings: Matrix of embeddings\n            terms: List of term lists for each embedding\n        \"\"\"\n        super().__init__()\n        self.embeddings = embeddings",
        "detail": "src.word_manifold.visualization.interactive",
        "documentation": {}
    },
    {
        "label": "MagicStructure",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.magic_visualizer",
        "description": "src.word_manifold.visualization.magic_visualizer",
        "peekOfCode": "class MagicStructure:\n    \"\"\"Represents a magic structure of arbitrary dimension.\"\"\"\n    dimension: int  # Number of dimensions\n    size: int      # Size in each dimension\n    values: np.ndarray  # n-dimensional array of values\n    terms: Optional[List[str]] = None  # Associated terms\n    semantic_weights: Optional[np.ndarray] = None  # Semantic influence weights\n    @property\n    def magic_constant(self) -> float:\n        \"\"\"Calculate the magic constant for this structure.\"\"\"",
        "detail": "src.word_manifold.visualization.magic_visualizer",
        "documentation": {}
    },
    {
        "label": "MagicVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.magic_visualizer",
        "description": "src.word_manifold.visualization.magic_visualizer",
        "peekOfCode": "class MagicVisualizer:\n    \"\"\"Visualizer for magic squares, cubes, and higher-dimensional structures.\"\"\"\n    def __init__(\n        self,\n        word_embeddings: Optional[WordEmbeddings] = None,\n        output_dir: str = \"visualizations/magic\",\n        enable_semantic_weighting: bool = True,\n        color_scheme: str = \"viridis\"\n    ):\n        \"\"\"",
        "detail": "src.word_manifold.visualization.magic_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.magic_visualizer",
        "description": "src.word_manifold.visualization.magic_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass MagicStructure:\n    \"\"\"Represents a magic structure of arbitrary dimension.\"\"\"\n    dimension: int  # Number of dimensions\n    size: int      # Size in each dimension\n    values: np.ndarray  # n-dimensional array of values\n    terms: Optional[List[str]] = None  # Associated terms\n    semantic_weights: Optional[np.ndarray] = None  # Semantic influence weights\n    @property",
        "detail": "src.word_manifold.visualization.magic_visualizer",
        "documentation": {}
    },
    {
        "label": "ManifoldPlotData",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.manifold_vis",
        "description": "src.word_manifold.visualization.manifold_vis",
        "peekOfCode": "class ManifoldPlotData:\n    \"\"\"Container for manifold visualization data.\"\"\"\n    points: np.ndarray\n    embeddings: np.ndarray\n    terms: List[List[str]]\n    coherence: Optional[np.ndarray] = None\n    def to_plot_data(self) -> Dict[str, Any]:\n        \"\"\"Convert to plottable format.\"\"\"\n        return {\n            'points': self.points,",
        "detail": "src.word_manifold.visualization.manifold_vis",
        "documentation": {}
    },
    {
        "label": "ManifoldVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.manifold_vis",
        "description": "src.word_manifold.visualization.manifold_vis",
        "peekOfCode": "class ManifoldVisualizer(Visualizer):\n    \"\"\"Visualizer for manifold structures.\"\"\"\n    def __init__(self, embeddings: np.ndarray, terms: List[List[str]], n_components: int = 2):\n        \"\"\"Initialize visualizer.\n        Args:\n            embeddings: Matrix of embeddings\n            terms: List of term lists for each embedding\n            n_components: Number of visualization dimensions (2 or 3)\n        \"\"\"\n        super().__init__()",
        "detail": "src.word_manifold.visualization.manifold_vis",
        "documentation": {}
    },
    {
        "label": "RitualPhase",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.ritual_visualizer",
        "description": "src.word_manifold.visualization.ritual_visualizer",
        "peekOfCode": "class RitualPhase(Enum):\n    \"\"\"Phases of ritual transformation.\"\"\"\n    PREPARATION = auto()\n    INVOCATION = auto()\n    TRANSFORMATION = auto()\n    INTEGRATION = auto()\n    COMPLETION = auto()\n@dataclass\nclass RitualState:\n    \"\"\"Represents the current state of a ritual transformation.\"\"\"",
        "detail": "src.word_manifold.visualization.ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "RitualState",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.ritual_visualizer",
        "description": "src.word_manifold.visualization.ritual_visualizer",
        "peekOfCode": "class RitualState:\n    \"\"\"Represents the current state of a ritual transformation.\"\"\"\n    phase: RitualPhase\n    active_terms: Set[str]\n    transformed_terms: Set[str]\n    energy_level: float\n    resonance_pattern: Dict[HermeticPrinciple, float]\n    dominant_principle: HermeticPrinciple\n    timestamp: datetime\nclass RitualVisualizer:",
        "detail": "src.word_manifold.visualization.ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "RitualVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.ritual_visualizer",
        "description": "src.word_manifold.visualization.ritual_visualizer",
        "peekOfCode": "class RitualVisualizer:\n    \"\"\"\n    Visualizes ritual transformations by combining semantic, geometric,\n    and energetic aspects into cohesive visual representations.\n    \"\"\"\n    def __init__(\n        self,\n        word_embeddings: WordEmbeddings,\n        output_dir: str = \"visualizations/rituals\",\n        n_dims: int = 3,",
        "detail": "src.word_manifold.visualization.ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "SemanticNode",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.semantic_tree_visualizer",
        "description": "src.word_manifold.visualization.semantic_tree_visualizer",
        "peekOfCode": "class SemanticNode:\n    \"\"\"Represents a node in the semantic tree with hierarchical relationships.\"\"\"\n    def __init__(self, text: str, embedding: np.ndarray):\n        \"\"\"\n        Initialize a semantic node.\n        Args:\n            text: The text content of the node\n            embedding: The vector embedding of the text\n        \"\"\"\n        self.text = text",
        "detail": "src.word_manifold.visualization.semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "SemanticTreeVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.semantic_tree_visualizer",
        "description": "src.word_manifold.visualization.semantic_tree_visualizer",
        "peekOfCode": "class SemanticTreeVisualizer:\n    \"\"\"Visualizer for semantic trees with customizable appearance and layout.\"\"\"\n    def __init__(\n        self,\n        output_dir: str = \"visualizations/semantic_trees\",\n        model_name: str = \"sentence-transformers/all-mpnet-base-v2\",\n        color_scheme: str = \"viridis\",\n        node_size_base: int = 1000,\n        min_similarity: float = 0.3\n    ):",
        "detail": "src.word_manifold.visualization.semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.semantic_tree_visualizer",
        "description": "src.word_manifold.visualization.semantic_tree_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass SemanticNode:\n    \"\"\"Represents a node in the semantic tree with hierarchical relationships.\"\"\"\n    def __init__(self, text: str, embedding: np.ndarray):\n        \"\"\"\n        Initialize a semantic node.\n        Args:\n            text: The text content of the node\n            embedding: The vector embedding of the text\n        \"\"\"",
        "detail": "src.word_manifold.visualization.semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "VisualizationServer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "class VisualizationServer:\n    \"\"\"Manages the visualization server with Ray integration.\"\"\"\n    def __init__(\n        self,\n        host: str = 'localhost',\n        port: int = 5000,\n        num_workers: int = 4,\n        ray_address: Optional[str] = None,\n        use_cloud: bool = False,\n        config_path: Optional[str] = None",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "run_server",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "def run_server(\n    host: str = 'localhost',\n    port: int = 5000,\n    debug: bool = False,\n    use_cloud: bool = False,\n    config_path: Optional[str] = None\n):\n    \"\"\"Run the visualization server.\"\"\"\n    server = VisualizationServer(\n        host=host,",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass VisualizationServer:\n    \"\"\"Manages the visualization server with Ray integration.\"\"\"\n    def __init__(\n        self,\n        host: str = 'localhost',\n        port: int = 5000,\n        num_workers: int = 4,\n        ray_address: Optional[str] = None,\n        use_cloud: bool = False,",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "ExportConfig",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.shape_visualizer",
        "description": "src.word_manifold.visualization.shape_visualizer",
        "peekOfCode": "class ExportConfig:\n    \"\"\"Configuration for exporting visualizations.\"\"\"\n    def __init__(\n        self,\n        format: str = \"mp4\",\n        dpi: int = 300,\n        fps: int = 60,\n        bitrate: int = 2000,\n        save_frames: bool = True,\n        output_dir: Optional[str] = None",
        "detail": "src.word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "ShapeVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.shape_visualizer",
        "description": "src.word_manifold.visualization.shape_visualizer",
        "peekOfCode": "class ShapeVisualizer:\n    \"\"\"\n    Advanced visualization class for semantic shapes with enhanced visual encoding.\n    \"\"\"\n    def __init__(\n        self,\n        color_scheme: str = \"semantic\",\n        use_textures: bool = True,\n        export_config: Optional[ExportConfig] = None\n    ):",
        "detail": "src.word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.shape_visualizer",
        "description": "src.word_manifold.visualization.shape_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)  # Default to INFO level\n# Create formatters and handlers if they don't exist\nif not logger.handlers:\n    # Create console handler with formatting\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    console_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - [%(levelname)s] - %(message)s'\n    )",
        "detail": "src.word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "SymbolicPattern",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.symbolic_visualizer",
        "description": "src.word_manifold.visualization.symbolic_visualizer",
        "peekOfCode": "class SymbolicPattern:\n    \"\"\"A pattern of symbols that can transform.\"\"\"\n    base_symbols: str  # Core symbols that make up the pattern\n    transformations: List[str]  # Sequence of transformation states\n    meaning: str  # Semantic meaning of the pattern\n    energy: float  # Current energy level (affects transformation rate)\n    resonance: Set[str]  # Terms that resonate with this pattern\n    def __repr__(self) -> str:\n        \"\"\"String representation of the pattern.\"\"\"\n        return f\"SymbolicPattern(meaning='{self.meaning}', energy={self.energy:.2f}, n_transforms={len(self.transformations)})\"",
        "detail": "src.word_manifold.visualization.symbolic_visualizer",
        "documentation": {}
    },
    {
        "label": "SymbolicVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.symbolic_visualizer",
        "description": "src.word_manifold.visualization.symbolic_visualizer",
        "peekOfCode": "class SymbolicVisualizer:\n    \"\"\"Creates living ASCII mandalas from semantic spaces.\"\"\"\n    # Symbol sets for different semantic qualities\n    ABSTRACT_SYMBOLS: str = \"\"  # Abstract concepts\n    ORGANIC_SYMBOLS: str = \"~\"    # Natural/flowing concepts\n    TECH_SYMBOLS: str = \"\"       # Technological concepts\n    SACRED_SYMBOLS: str = \"\"      # Spiritual concepts\n    EMOTIONAL_SYMBOLS: str = \"\"    # Emotional concepts\n    def __init__(\n        self, ",
        "detail": "src.word_manifold.visualization.symbolic_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.symbolic_visualizer",
        "description": "src.word_manifold.visualization.symbolic_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass SymbolicPattern:\n    \"\"\"A pattern of symbols that can transform.\"\"\"\n    base_symbols: str  # Core symbols that make up the pattern\n    transformations: List[str]  # Sequence of transformation states\n    meaning: str  # Semantic meaning of the pattern\n    energy: float  # Current energy level (affects transformation rate)\n    resonance: Set[str]  # Terms that resonate with this pattern\n    def __repr__(self) -> str:",
        "detail": "src.word_manifold.visualization.symbolic_visualizer",
        "documentation": {}
    },
    {
        "label": "create_color_gradient",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.utils",
        "description": "src.word_manifold.visualization.utils",
        "peekOfCode": "def create_color_gradient(n_colors: int, start_color: str = '#1f77b4', end_color: str = '#ff7f0e') -> Colormap:\n    \"\"\"Create a continuous color gradient between two colors.\n    Args:\n        n_colors: Number of colors in gradient\n        start_color: Starting hex color code\n        end_color: Ending hex color code\n    Returns:\n        matplotlib colormap\n    \"\"\"\n    return LinearSegmentedColormap.from_list('custom', [start_color, end_color], N=n_colors)",
        "detail": "src.word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "scale_coordinates",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.utils",
        "description": "src.word_manifold.visualization.utils",
        "peekOfCode": "def scale_coordinates(coords: np.ndarray, scale: float = 1.0) -> np.ndarray:\n    \"\"\"Scale coordinates to specified range while preserving relative distances.\n    Args:\n        coords: Array of coordinates to scale\n        scale: Scale factor to apply\n    Returns:\n        Scaled coordinates array\n    \"\"\"\n    scaler = MinMaxScaler(feature_range=(-scale, scale))\n    return scaler.fit_transform(coords)",
        "detail": "src.word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "calculate_marker_sizes",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.utils",
        "description": "src.word_manifold.visualization.utils",
        "peekOfCode": "def calculate_marker_sizes(\n    values: np.ndarray,\n    min_size: float = 20.0,\n    max_size: float = 200.0\n) -> np.ndarray:\n    \"\"\"Calculate marker sizes based on values.\n    Args:\n        values: Array of values to map to sizes\n        min_size: Minimum marker size\n        max_size: Maximum marker size",
        "detail": "src.word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "create_subplot_grid",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.utils",
        "description": "src.word_manifold.visualization.utils",
        "peekOfCode": "def create_subplot_grid(\n    n_plots: int,\n    max_cols: int = 3\n) -> Tuple[plt.Figure, np.ndarray]:\n    \"\"\"Create a grid of subplots.\n    Args:\n        n_plots: Number of plots needed\n        max_cols: Maximum number of columns\n    Returns:\n        Figure and array of axes",
        "detail": "src.word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "add_colorbar",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.utils",
        "description": "src.word_manifold.visualization.utils",
        "peekOfCode": "def add_colorbar(\n    fig: plt.Figure,\n    mappable: Any,\n    label: str,\n    orientation: str = 'vertical'\n) -> None:\n    \"\"\"Add a colorbar to the figure.\n    Args:\n        fig: Figure to add colorbar to\n        mappable: The mappable object to create colorbar from",
        "detail": "src.word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "create_legend",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.utils",
        "description": "src.word_manifold.visualization.utils",
        "peekOfCode": "def create_legend(\n    ax: plt.Axes,\n    labels: Dict[Any, str],\n    markers: Optional[Dict[Any, str]] = None,\n    colors: Optional[Dict[Any, str]] = None,\n    title: Optional[str] = None\n) -> None:\n    \"\"\"Add a legend to the axes.\n    Args:\n        ax: Axes to add legend to",
        "detail": "src.word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "CellType",
        "kind": 6,
        "importPath": "src.word_manifold.types",
        "description": "src.word_manifold.types",
        "peekOfCode": "class CellType(Enum):\n    \"\"\"Types of cells with occult correspondences.\"\"\"\n    ELEMENTAL = auto()   # Corresponds to the four elements\n    PLANETARY = auto()   # Corresponds to planetary influences\n    ZODIACAL = auto()    # Corresponds to zodiac signs\n    TAROT = auto()       # Corresponds to tarot archetypes\n    SEPHIROTIC = auto()  # Corresponds to Kabbalistic sephiroth\n    OTHER = auto()       # Default/unclassified\nclass DistanceType(Enum):\n    \"\"\"Types of distance metrics for cell relationships.\"\"\"",
        "detail": "src.word_manifold.types",
        "documentation": {}
    },
    {
        "label": "DistanceType",
        "kind": 6,
        "importPath": "src.word_manifold.types",
        "description": "src.word_manifold.types",
        "peekOfCode": "class DistanceType(Enum):\n    \"\"\"Types of distance metrics for cell relationships.\"\"\"\n    EUCLIDEAN = auto()      # Standard Euclidean distance\n    COSINE = auto()         # Cosine distance (semantic similarity)\n    NUMEROLOGICAL = auto()  # Distance weighted by numerological values\n    HYBRID = auto()         # Combination of semantic and numerological",
        "detail": "src.word_manifold.types",
        "documentation": {}
    },
    {
        "label": "mock_manifold",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def mock_manifold():\n    \"\"\"Create a mock manifold for testing automata systems.\"\"\"\n    mock = Mock()\n    # Mock the cells attribute with some test data\n    mock.cells = {\n        0: Mock(centroid=np.zeros(10)),\n        1: Mock(centroid=np.zeros(10))\n    }\n    # Mock transform to return the same vectors\n    mock.transform = MagicMock(return_value=np.zeros((2, 10)))",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "base_embeddings",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def base_embeddings():\n    \"\"\"Create a WordEmbeddings instance with test terms.\"\"\"\n    embeddings = WordEmbeddings()\n    test_terms = {\n        \"thelema\", \"will\", \"love\", \"magick\", \"ritual\",\n        \"knowledge\", \"wisdom\", \"power\", \"light\", \"dark\"\n    }\n    embeddings.load_terms(test_terms)\n    return embeddings\n@pytest.fixture",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "base_system",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def base_system(mock_manifold):\n    \"\"\"Create a base AutomataSystem for testing.\"\"\"\n    from word_manifold.automata.cellular_rules import create_predefined_rules\n    rules = create_predefined_rules()\n    return AutomataSystem(\n        manifold=mock_manifold,\n        rules_dict=rules,\n        sequences_dict={},\n        evolution_pattern=EvolutionPattern.THELEMIC,\n        save_path=\"test_outputs\"",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "TestAutomataSystem",
        "kind": 6,
        "importPath": "tests.test_automata",
        "description": "tests.test_automata",
        "peekOfCode": "class TestAutomataSystem:\n    \"\"\"Tests for the AutomataSystem class.\"\"\"\n    def test_initialization(self, base_system, mock_manifold):\n        \"\"\"Test system initialization and basic properties.\"\"\"\n        assert base_system.manifold == mock_manifold\n        assert len(base_system.rules) > 0\n        assert base_system.generation == 0\n        assert base_system.evolution_pattern == EvolutionPattern.THELEMIC\n    def test_evolution_state(self, base_system):\n        \"\"\"Test evolution state management.\"\"\"",
        "detail": "tests.test_automata",
        "documentation": {}
    },
    {
        "label": "TestCellularRules",
        "kind": 6,
        "importPath": "tests.test_automata",
        "description": "tests.test_automata",
        "peekOfCode": "class TestCellularRules:\n    \"\"\"Tests for cellular automata rules.\"\"\"\n    def test_predefined_rules(self):\n        \"\"\"Test creation and properties of predefined rules.\"\"\"\n        rules = create_predefined_rules()\n        # Check basic rule properties\n        assert len(rules) > 0\n        for name, rule in rules.items():\n            assert isinstance(rule, CellularRule)\n            # assert rule.name in str(name).lower().replace(' ', '_')  # More flexible name matching",
        "detail": "tests.test_automata",
        "documentation": {}
    },
    {
        "label": "mock_manifold",
        "kind": 2,
        "importPath": "tests.test_automata",
        "description": "tests.test_automata",
        "peekOfCode": "def mock_manifold():\n    mock = Mock()\n    # Mock the cells attribute with some test data\n    mock.cells = {\n        0: Mock(centroid=np.zeros(10)),\n        1: Mock(centroid=np.zeros(10))\n    }\n    # Mock transform to return the same vectors\n    mock.transform = MagicMock(return_value=np.zeros((2, 10)))\n    # Mock get_manifold_state to return a valid state",
        "detail": "tests.test_automata",
        "documentation": {}
    },
    {
        "label": "base_system",
        "kind": 2,
        "importPath": "tests.test_automata",
        "description": "tests.test_automata",
        "peekOfCode": "def base_system(mock_manifold):\n    rules = create_predefined_rules()\n    return AutomataSystem(\n        manifold=mock_manifold,\n        rules_dict=rules,\n        sequences_dict={},\n        evolution_pattern=EvolutionPattern.THELEMIC,\n        save_path=\"test_outputs\"\n    )\nclass TestAutomataSystem:",
        "detail": "tests.test_automata",
        "documentation": {}
    },
    {
        "label": "TestCell",
        "kind": 6,
        "importPath": "tests.test_core_components",
        "description": "tests.test_core_components",
        "peekOfCode": "class TestCell:\n    \"\"\"Tests for the Cell data structure.\"\"\"\n    def test_cell_creation(self):\n        \"\"\"Test Cell dataclass creation and basic properties.\"\"\"\n        cell = Cell(\n            id=1,\n            terms=[\"thelema\", \"will\"],\n            centroid=np.array([0.1, 0.2, 0.3]),\n            type=CellType.TAROT,\n            numerological_value=93",
        "detail": "tests.test_core_components",
        "documentation": {}
    },
    {
        "label": "TestVectorManifold",
        "kind": 6,
        "importPath": "tests.test_core_components",
        "description": "tests.test_core_components",
        "peekOfCode": "class TestVectorManifold:\n    \"\"\"Tests for the VectorManifold class.\"\"\"\n    def test_initialization(self, base_embeddings):\n        \"\"\"Test VectorManifold initialization and basic properties.\"\"\"\n        manifold = VectorManifold(base_embeddings)\n        # Check basic properties\n        assert manifold.term_to_index is not None\n        assert len(manifold.term_to_index) == len(base_embeddings.terms)\n        assert manifold.n_cells == 22  # Default value\n        assert manifold.reduction_dims == 3  # Default value",
        "detail": "tests.test_core_components",
        "documentation": {}
    },
    {
        "label": "TestWordEmbeddings",
        "kind": 6,
        "importPath": "tests.test_core_components",
        "description": "tests.test_core_components",
        "peekOfCode": "class TestWordEmbeddings:\n    \"\"\"Tests for the WordEmbeddings class.\"\"\"\n    def test_initialization(self):\n        \"\"\"Test WordEmbeddings initialization.\"\"\"\n        embeddings = WordEmbeddings()\n        assert embeddings.model is not None\n        assert embeddings.tokenizer is not None\n        assert len(embeddings.terms) == 0\n    def test_term_loading(self, base_embeddings):\n        \"\"\"Test loading terms and computing embeddings.\"\"\"",
        "detail": "tests.test_core_components",
        "documentation": {}
    },
    {
        "label": "word_embeddings",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def word_embeddings():\n    \"\"\"Create a WordEmbeddings instance for testing.\"\"\"\n    embeddings = WordEmbeddings(model_name=\"all-MiniLM-L6-v2\")\n    test_terms = [\"light\", \"wisdom\", \"truth\", \"love\", \"power\"]\n    embeddings.load_terms(test_terms)\n    return embeddings\n@pytest.fixture\ndef test_output_dir(tmp_path):\n    \"\"\"Create a temporary directory for test outputs.\"\"\"\n    output_dir = tmp_path / \"test_ritual_viz\"",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_output_dir",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_output_dir(tmp_path):\n    \"\"\"Create a temporary directory for test outputs.\"\"\"\n    output_dir = tmp_path / \"test_ritual_viz\"\n    output_dir.mkdir(exist_ok=True)\n    return str(output_dir)\n@pytest.fixture\ndef ritual_visualizer(word_embeddings, test_output_dir):\n    \"\"\"Create a RitualVisualizer instance for testing.\"\"\"\n    return RitualVisualizer(\n        word_embeddings=word_embeddings,",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "ritual_visualizer",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def ritual_visualizer(word_embeddings, test_output_dir):\n    \"\"\"Create a RitualVisualizer instance for testing.\"\"\"\n    return RitualVisualizer(\n        word_embeddings=word_embeddings,\n        output_dir=test_output_dir,\n        n_dims=3,\n        frame_duration=100,  # Faster for testing\n        energy_threshold=0.7,\n        resonance_threshold=0.8\n    )",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_initialization",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_initialization(ritual_visualizer, test_output_dir):\n    \"\"\"Test proper initialization of RitualVisualizer.\"\"\"\n    assert ritual_visualizer.output_dir == test_output_dir\n    assert ritual_visualizer.n_dims == 3\n    assert ritual_visualizer.frame_duration == 100\n    assert ritual_visualizer.energy_threshold == 0.7\n    assert ritual_visualizer.resonance_threshold == 0.8\n    assert os.path.exists(test_output_dir)\n    assert isinstance(ritual_visualizer.states, list)\n    assert isinstance(ritual_visualizer.term_evolution, dict)",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_process_transformation",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_process_transformation(ritual_visualizer):\n    \"\"\"Test processing of term transformations.\"\"\"\n    initial_terms = {\"light\", \"wisdom\"}\n    transformed_terms = {\"illumination\", \"understanding\"}\n    ritual_visualizer.process_transformation(\n        initial_terms,\n        transformed_terms,\n        RitualPhase.TRANSFORMATION\n    )\n    assert len(ritual_visualizer.states) == 1",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_calculate_energy_levels",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_calculate_energy_levels(ritual_visualizer):\n    \"\"\"Test energy level calculations.\"\"\"\n    terms = {\"light\", \"wisdom\", \"truth\"}\n    energy = ritual_visualizer._calculate_energy_level(terms)\n    assert isinstance(energy, float)\n    assert 0 <= energy <= 1\ndef test_determine_resonance(ritual_visualizer):\n    \"\"\"Test resonance pattern determination.\"\"\"\n    terms = {\"light\", \"wisdom\", \"truth\"}\n    resonance = ritual_visualizer._determine_resonance_pattern(terms)",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_determine_resonance",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_determine_resonance(ritual_visualizer):\n    \"\"\"Test resonance pattern determination.\"\"\"\n    terms = {\"light\", \"wisdom\", \"truth\"}\n    resonance = ritual_visualizer._determine_resonance_pattern(terms)\n    assert isinstance(resonance, dict)\n    assert all(isinstance(k, HermeticPrinciple) for k in resonance.keys())\n    assert all(isinstance(v, float) for v in resonance.values())\n    assert all(0 <= v <= 1 for v in resonance.values())\ndef test_identify_dominant_principle(ritual_visualizer):\n    \"\"\"Test dominant principle identification.\"\"\"",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_identify_dominant_principle",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_identify_dominant_principle(ritual_visualizer):\n    \"\"\"Test dominant principle identification.\"\"\"\n    terms = {\"light\", \"wisdom\", \"truth\"}\n    principle = ritual_visualizer._identify_dominant_principle(terms)\n    assert isinstance(principle, HermeticPrinciple)\ndef test_generate_visualization(ritual_visualizer, test_output_dir):\n    \"\"\"Test visualization generation.\"\"\"\n    # Process a few transformations\n    initial = {\"light\", \"wisdom\"}\n    transformed = {\"illumination\", \"understanding\"}",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_generate_visualization",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_generate_visualization(ritual_visualizer, test_output_dir):\n    \"\"\"Test visualization generation.\"\"\"\n    # Process a few transformations\n    initial = {\"light\", \"wisdom\"}\n    transformed = {\"illumination\", \"understanding\"}\n    final = {\"enlightenment\", \"knowledge\"}\n    ritual_visualizer.process_transformation(initial, transformed, RitualPhase.PREPARATION)\n    ritual_visualizer.process_transformation(transformed, final, RitualPhase.TRANSFORMATION)\n    # Generate visualization\n    output_path = ritual_visualizer.generate_visualization()",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_error_handling",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_error_handling(ritual_visualizer):\n    \"\"\"Test error handling for invalid inputs.\"\"\"\n    # Empty term sets\n    with pytest.raises(ValueError):\n        ritual_visualizer.process_transformation(set(), {\"light\"}, RitualPhase.PREPARATION)\n    with pytest.raises(ValueError):\n        ritual_visualizer.process_transformation({\"light\"}, set(), RitualPhase.PREPARATION)\n    # Invalid terms\n    with pytest.raises(ValueError):\n        ritual_visualizer.process_transformation(",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_state_tracking",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_state_tracking(ritual_visualizer):\n    \"\"\"Test proper tracking of ritual state history.\"\"\"\n    transformations = [\n        ({\"light\"}, {\"illumination\"}, RitualPhase.PREPARATION),\n        ({\"illumination\"}, {\"enlightenment\"}, RitualPhase.TRANSFORMATION),\n        ({\"enlightenment\"}, {\"wisdom\"}, RitualPhase.INTEGRATION)\n    ]\n    for initial, transformed, phase in transformations:\n        ritual_visualizer.process_transformation(initial, transformed, phase)\n    assert len(ritual_visualizer.states) == len(transformations)",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "visualizer",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def visualizer():\n    \"\"\"Create a test visualizer instance.\"\"\"\n    return SemanticTreeVisualizer(\n        output_dir=\"test_outputs/semantic_trees\",\n        color_scheme=\"viridis\",\n        node_size_base=800,\n        min_similarity=0.3\n    )\n@pytest.fixture\ndef sample_embedding():",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "sample_embedding",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def sample_embedding():\n    \"\"\"Create a sample embedding vector.\"\"\"\n    return np.random.rand(768)  # Common embedding dimension\ndef test_semantic_node_creation(sample_embedding):\n    \"\"\"Test creation of semantic nodes.\"\"\"\n    node = SemanticNode(\"test\", sample_embedding)\n    assert node.text == \"test\"\n    assert node.level == 0\n    assert node.parent is None\n    assert len(node.children) == 0",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_semantic_node_creation",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_semantic_node_creation(sample_embedding):\n    \"\"\"Test creation of semantic nodes.\"\"\"\n    node = SemanticNode(\"test\", sample_embedding)\n    assert node.text == \"test\"\n    assert node.level == 0\n    assert node.parent is None\n    assert len(node.children) == 0\n    assert node.similarity_to_parent == 1.0\n    assert node.semantic_weight == 1.0\ndef test_semantic_node_child_addition(sample_embedding):",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_semantic_node_child_addition",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_semantic_node_child_addition(sample_embedding):\n    \"\"\"Test adding child nodes.\"\"\"\n    parent = SemanticNode(\"parent\", sample_embedding)\n    child = SemanticNode(\"child\", sample_embedding)\n    parent.add_child(child, similarity=0.8)\n    assert len(parent.children) == 1\n    assert child.parent == parent\n    assert child.level == 1\n    assert child.similarity_to_parent == 0.8\ndef test_semantic_weight_calculation(sample_embedding):",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_semantic_weight_calculation",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_semantic_weight_calculation(sample_embedding):\n    \"\"\"Test semantic weight calculation.\"\"\"\n    root = SemanticNode(\"root\", sample_embedding)\n    child = SemanticNode(\"child\", sample_embedding)\n    grandchild = SemanticNode(\"grandchild\", sample_embedding)\n    root.add_child(child, similarity=0.8)\n    child.add_child(grandchild, similarity=0.7)\n    assert root.calculate_semantic_weight() == 1.0\n    assert abs(child.calculate_semantic_weight() - 0.8 * 0.8) < 1e-6\n    assert abs(grandchild.calculate_semantic_weight() - 0.8 * 0.7 * 0.8 * 0.8) < 1e-6",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_visualizer_initialization",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_visualizer_initialization(visualizer):\n    \"\"\"Test visualizer initialization.\"\"\"\n    assert os.path.exists(visualizer.output_dir)\n    assert visualizer.color_scheme == \"viridis\"\n    assert visualizer.node_size_base == 800\n    assert visualizer.min_similarity == 0.3\ndef test_tree_building(visualizer):\n    \"\"\"Test building a semantic tree.\"\"\"\n    root = visualizer.build_semantic_tree(\n        root_text=\"machine learning\",",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_tree_building",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_tree_building(visualizer):\n    \"\"\"Test building a semantic tree.\"\"\"\n    root = visualizer.build_semantic_tree(\n        root_text=\"machine learning\",\n        related_terms=[\n            \"neural networks\",\n            \"deep learning\",\n            \"artificial intelligence\",\n            \"data science\"\n        ],",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_tree_visualization",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_tree_visualization(visualizer):\n    \"\"\"Test tree visualization.\"\"\"\n    root = visualizer.build_semantic_tree(\n        root_text=\"python\",\n        related_terms=[\n            \"programming\",\n            \"coding\",\n            \"software\",\n            \"development\"\n        ],",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_minimum_similarity_threshold",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_minimum_similarity_threshold(visualizer):\n    \"\"\"Test minimum similarity threshold.\"\"\"\n    visualizer.min_similarity = 0.9  # Set very high threshold\n    root = visualizer.build_semantic_tree(\n        root_text=\"test\",\n        related_terms=[\"unrelated1\", \"unrelated2\"],\n        max_depth=2,\n        branching_factor=2\n    )\n    # Should have no children due to high similarity threshold",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_invalid_terms_handling",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_invalid_terms_handling(visualizer):\n    \"\"\"Test handling of invalid terms.\"\"\"\n    root = visualizer.build_semantic_tree(\n        root_text=\"test\",\n        related_terms=[\"\", \"   \", None],  # Invalid terms\n        max_depth=2,\n        branching_factor=2\n    )\n    # Should create root node without children\n    assert root.text == \"test\"",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "MockVisualizationData",
        "kind": 6,
        "importPath": "tests.test_visualization",
        "description": "tests.test_visualization",
        "peekOfCode": "class MockVisualizationData:\n    \"\"\"Mock visualization data for testing.\"\"\"\n    def __init__(self, points, labels, colors):\n        self.points = points\n        self.labels = labels\n        self.colors = colors\n    def to_plot_data(self):\n        return {'points': self.points}\n    def get_color_map(self):\n        return self.colors",
        "detail": "tests.test_visualization",
        "documentation": {}
    },
    {
        "label": "MockVisualizer",
        "kind": 6,
        "importPath": "tests.test_visualization",
        "description": "tests.test_visualization",
        "peekOfCode": "class MockVisualizer(Visualizer):\n    \"\"\"Mock visualizer for testing.\"\"\"\n    def prepare_data(self):\n        points = np.array([[1, 2], [3, 4]])\n        labels = {0: 'A', 1: 'B'}\n        colors = {'A': 'red', 'B': 'blue'}\n        return MockVisualizationData(points, labels, colors)\n    def plot(self, data):\n        fig = Figure()\n        ax = fig.add_subplot(111)",
        "detail": "tests.test_visualization",
        "documentation": {}
    },
    {
        "label": "test_visualizer_base",
        "kind": 2,
        "importPath": "tests.test_visualization",
        "description": "tests.test_visualization",
        "peekOfCode": "def test_visualizer_base():\n    \"\"\"Test base visualizer functionality.\"\"\"\n    vis = MockVisualizer()\n    # Test data preparation\n    data = vis.prepare_data()\n    assert isinstance(data, VisualizationData)\n    assert 'points' in data.to_plot_data()\n    # Test plotting\n    fig = vis.plot(data)\n    assert isinstance(fig, Figure)",
        "detail": "tests.test_visualization",
        "documentation": {}
    },
    {
        "label": "test_manifold_visualizer",
        "kind": 2,
        "importPath": "tests.test_visualization",
        "description": "tests.test_visualization",
        "peekOfCode": "def test_manifold_visualizer():\n    \"\"\"Test manifold visualizer functionality.\"\"\"\n    # Create test data\n    embeddings = np.random.randn(10, 5)\n    terms = [['cat', 'feline'], ['dog', 'canine'], ['bird', 'avian']] * 3 + ['fish']\n    vis = ManifoldVisualizer(embeddings, terms)\n    # Test data preparation\n    data = vis.prepare_data()\n    assert isinstance(data, ManifoldPlotData)\n    plot_data = data.to_plot_data()",
        "detail": "tests.test_visualization",
        "documentation": {}
    },
    {
        "label": "test_interactive_visualizer",
        "kind": 2,
        "importPath": "tests.test_visualization",
        "description": "tests.test_visualization",
        "peekOfCode": "def test_interactive_visualizer():\n    \"\"\"Test interactive visualizer functionality.\"\"\"\n    embeddings = np.random.randn(5, 3)\n    terms = [['term1'], ['term2'], ['term3'], ['term4'], ['term5']]\n    vis = InteractiveManifoldVisualizer(embeddings, terms)\n    # Test data preparation\n    data = vis.prepare_data()\n    assert isinstance(data, ManifoldPlotData)\n    # Test initial state\n    state = vis.get_state()",
        "detail": "tests.test_visualization",
        "documentation": {}
    },
    {
        "label": "test_visualization_utils",
        "kind": 2,
        "importPath": "tests.test_visualization",
        "description": "tests.test_visualization",
        "peekOfCode": "def test_visualization_utils():\n    \"\"\"Test visualization utility functions.\"\"\"\n    # Test color gradient\n    cmap = create_color_gradient(10)\n    assert len(cmap.colors) == 10\n    # Test coordinate scaling\n    coords = np.random.randn(10, 2)\n    scaled = scale_coordinates(coords)\n    assert np.all(scaled >= -1) and np.all(scaled <= 1)\n    # Test marker size calculation",
        "detail": "tests.test_visualization",
        "documentation": {}
    },
    {
        "label": "MockTermManager",
        "kind": 6,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "class MockTermManager:\n    \"\"\"Mock TermManager for testing.\"\"\"\n    def __init__(self, model_name=None):\n        self.embeddings = {term: TEST_EMBEDDING for term in TEST_TERMS}\n        self.running = True\n    def get_embedding(self, term):\n        return TEST_EMBEDDING\n    def shutdown(self):\n        self.running = False\n@pytest.fixture(scope=\"function\")",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "mock_term_manager",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def mock_term_manager():\n    \"\"\"Mock TermManager to avoid multiprocessing issues in tests.\"\"\"\n    with patch(\"word_manifold.embeddings.term_manager.TermManager\", MockTermManager):\n        yield\n@pytest.fixture(scope=\"function\")\ndef mock_replicate():\n    \"\"\"Mock Replicate API responses.\"\"\"\n    with patch(\"replicate.models.get\") as mock_get:\n        mock_model = Mock()\n        mock_model.predict.return_value = MOCK_REPLICATE_RESPONSE",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "mock_replicate",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def mock_replicate():\n    \"\"\"Mock Replicate API responses.\"\"\"\n    with patch(\"replicate.models.get\") as mock_get:\n        mock_model = Mock()\n        mock_model.predict.return_value = MOCK_REPLICATE_RESPONSE\n        mock_get.return_value = mock_model\n        yield mock_get\n@pytest.fixture(scope=\"function\")\ndef mock_server():\n    \"\"\"Mock remote server responses.\"\"\"",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "mock_server",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def mock_server():\n    \"\"\"Mock remote server responses.\"\"\"\n    with patch(\"requests.get\") as mock_get, patch(\"requests.post\") as mock_post:\n        mock_get.return_value.status_code = 200\n        mock_post.return_value.status_code = 200\n        mock_post.return_value.json.return_value = {\n            \"terms\": {term: TEST_EMBEDDING.tolist() for term in TEST_TERMS},\n            \"similar_terms\": [(\"related_term\", 0.8) for _ in range(5)]\n        }\n        yield (mock_get, mock_post)",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "temp_cache_dir",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def temp_cache_dir():\n    \"\"\"Create temporary cache directory.\"\"\"\n    with tempfile.TemporaryDirectory() as tmpdir:\n        yield Path(tmpdir)\n@pytest.mark.parallel\ndef test_init_replicate_mode(mock_replicate, mock_term_manager):\n    \"\"\"Test initialization in Replicate mode.\"\"\"\n    # Test successful initialization\n    embeddings = WordEmbeddings(\n        mode=\"replicate\",",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_init_replicate_mode",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_init_replicate_mode(mock_replicate, mock_term_manager):\n    \"\"\"Test initialization in Replicate mode.\"\"\"\n    # Test successful initialization\n    embeddings = WordEmbeddings(\n        mode=\"replicate\",\n        replicate_api_token=\"test_token\",\n        replicate_model=\"test/model:v1\"\n    )\n    assert embeddings.mode == EmbeddingMode.REPLICATE\n    # Test missing API token",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_init_remote_mode",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_init_remote_mode(mock_server, mock_term_manager):\n    \"\"\"Test initialization in remote mode.\"\"\"\n    mock_get, _ = mock_server\n    # Test successful initialization\n    embeddings = WordEmbeddings(\n        mode=\"remote\",\n        server_url=\"http://test-server\"\n    )\n    assert embeddings.mode == EmbeddingMode.REMOTE\n    assert embeddings.is_remote",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_load_terms_replicate",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_load_terms_replicate(mock_replicate, mock_term_manager):\n    \"\"\"Test loading terms using Replicate.\"\"\"\n    embeddings = WordEmbeddings(\n        mode=\"replicate\",\n        replicate_api_token=\"test_token\"\n    )\n    # Test batch loading\n    embeddings.load_terms(TEST_TERMS)\n    assert all(term in embeddings.terms for term in TEST_TERMS)\n    assert all(isinstance(emb, np.ndarray) for emb in embeddings.terms.values())",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_load_terms_remote",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_load_terms_remote(mock_server, mock_term_manager):\n    \"\"\"Test loading terms from remote server.\"\"\"\n    _, mock_post = mock_server\n    embeddings = WordEmbeddings(\n        mode=\"remote\",\n        server_url=\"http://test-server\"\n    )\n    # Test successful loading\n    embeddings.load_terms(TEST_TERMS)\n    assert all(term in embeddings.terms for term in TEST_TERMS)",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_load_terms_local",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_load_terms_local(tmp_path):\n    \"\"\"Test loading terms in local mode.\"\"\"\n    # Create embeddings instance with local cache\n    embeddings = WordEmbeddings(\n        mode=EmbeddingMode.LOCAL,\n        cache_dir=tmp_path\n    )\n    # Test terms to load\n    test_terms = [\"test\", \"example\", \"word\"]\n    # Load terms",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_caching",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_caching(temp_cache_dir, mock_replicate, mock_term_manager):\n    \"\"\"Test embedding caching functionality.\"\"\"\n    embeddings = WordEmbeddings(\n        mode=\"replicate\",\n        replicate_api_token=\"test_token\",\n        cache_dir=temp_cache_dir\n    )\n    # Test cache creation\n    embeddings.load_terms(TEST_TERMS)\n    cache_file = temp_cache_dir / \"embeddings.json\"",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_find_similar_terms_replicate",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_find_similar_terms_replicate(mock_replicate, mock_term_manager):\n    \"\"\"Test finding similar terms using Replicate.\"\"\"\n    embeddings = WordEmbeddings(\n        mode=\"replicate\",\n        replicate_api_token=\"test_token\"\n    )\n    # Test with term\n    similar = embeddings.find_similar_terms(\"wisdom\", k=5)\n    assert len(similar) == 5\n    assert all(isinstance(s, tuple) and len(s) == 2 for s in similar)",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_find_similar_terms_remote",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_find_similar_terms_remote(mock_server, mock_term_manager):\n    \"\"\"Test finding similar terms from remote server.\"\"\"\n    embeddings = WordEmbeddings(\n        mode=\"remote\",\n        server_url=\"http://test-server\"\n    )\n    # Test successful search\n    similar = embeddings.find_similar_terms(\"wisdom\", k=5)\n    assert len(similar) == 5\n    # Test with embedding",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_find_similar_terms_local",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_find_similar_terms_local(mock_term_manager):\n    \"\"\"Test finding similar terms locally.\"\"\"\n    embeddings = WordEmbeddings(mode=\"local\")\n    embeddings.load_terms(TEST_TERMS)\n    # Test local similarity search\n    similar = embeddings.find_similar_terms(TEST_TERMS[0], k=2)\n    assert len(similar) == 2\n    assert all(isinstance(s, tuple) and len(s) == 2 for s in similar)\n@pytest.mark.parallel\ndef test_cleanup(mock_term_manager):",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_cleanup",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_cleanup(mock_term_manager):\n    \"\"\"Test resource cleanup.\"\"\"\n    embeddings = WordEmbeddings(mode=\"local\")\n    embeddings.load_terms(TEST_TERMS)\n    # Test term manager cleanup\n    assert hasattr(embeddings, 'term_manager')\n    assert embeddings.term_manager.running\n    del embeddings\n    # Cleanup is handled by the mock\n@pytest.mark.parallel",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_error_handling",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_error_handling(mock_term_manager):\n    \"\"\"Test error handling and logging.\"\"\"\n    # Test invalid mode\n    with pytest.raises(ValueError):\n        WordEmbeddings(mode=\"invalid\")\n    # Test missing dependencies\n    with patch.dict('sys.modules', {'replicate': None}):\n        with pytest.raises(ImportError):\n            embeddings = WordEmbeddings(mode=\"replicate\")\n    # Test invalid server URL",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def pytest_configure(config):\n    \"\"\"Register parallel marker.\"\"\"\n    config.addinivalue_line(\n        \"markers\",\n        \"parallel: mark test to run in parallel\"\n    )\nif __name__ == \"__main__\":\n    pytest.main([\"-n\", \"auto\", \"--dist=loadfile\", __file__, \"-v\", \"--tb=short\"])",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Test data\nTEST_TERMS = [\"wisdom\", \"understanding\", \"beauty\", \"strength\"]\nTEST_EMBEDDING = np.random.rand(384)  # Common embedding size\nMOCK_REPLICATE_RESPONSE = {\n    \"embeddings\": [TEST_EMBEDDING.tolist() for _ in range(len(TEST_TERMS))],\n    \"similar_terms\": [(\"related_term\", 0.8) for _ in range(5)]\n}\nclass MockTermManager:\n    \"\"\"Mock TermManager for testing.\"\"\"",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "TEST_TERMS",
        "kind": 5,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "TEST_TERMS = [\"wisdom\", \"understanding\", \"beauty\", \"strength\"]\nTEST_EMBEDDING = np.random.rand(384)  # Common embedding size\nMOCK_REPLICATE_RESPONSE = {\n    \"embeddings\": [TEST_EMBEDDING.tolist() for _ in range(len(TEST_TERMS))],\n    \"similar_terms\": [(\"related_term\", 0.8) for _ in range(5)]\n}\nclass MockTermManager:\n    \"\"\"Mock TermManager for testing.\"\"\"\n    def __init__(self, model_name=None):\n        self.embeddings = {term: TEST_EMBEDDING for term in TEST_TERMS}",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "TEST_EMBEDDING",
        "kind": 5,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "TEST_EMBEDDING = np.random.rand(384)  # Common embedding size\nMOCK_REPLICATE_RESPONSE = {\n    \"embeddings\": [TEST_EMBEDDING.tolist() for _ in range(len(TEST_TERMS))],\n    \"similar_terms\": [(\"related_term\", 0.8) for _ in range(5)]\n}\nclass MockTermManager:\n    \"\"\"Mock TermManager for testing.\"\"\"\n    def __init__(self, model_name=None):\n        self.embeddings = {term: TEST_EMBEDDING for term in TEST_TERMS}\n        self.running = True",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "MOCK_REPLICATE_RESPONSE",
        "kind": 5,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "MOCK_REPLICATE_RESPONSE = {\n    \"embeddings\": [TEST_EMBEDDING.tolist() for _ in range(len(TEST_TERMS))],\n    \"similar_terms\": [(\"related_term\", 0.8) for _ in range(5)]\n}\nclass MockTermManager:\n    \"\"\"Mock TermManager for testing.\"\"\"\n    def __init__(self, model_name=None):\n        self.embeddings = {term: TEST_EMBEDDING for term in TEST_TERMS}\n        self.running = True\n    def get_embedding(self, term):",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "CodeChangeHandler",
        "kind": 6,
        "importPath": "dev_watch",
        "description": "dev_watch",
        "peekOfCode": "class CodeChangeHandler(FileSystemEventHandler):\n    \"\"\"Handle file system change events.\"\"\"\n    def __init__(self):\n        self.last_run = 0\n        self.debounce_seconds = 2.0  # Minimum seconds between runs\n    def on_modified(self, event):\n        if event.is_directory:\n            return\n        # Only process Python files\n        if not event.src_path.endswith('.py'):",
        "detail": "dev_watch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "dev_watch",
        "description": "dev_watch",
        "peekOfCode": "def main():\n    \"\"\"Run the development watch script.\"\"\"\n    # Create an observer and event handler\n    observer = Observer()\n    handler = CodeChangeHandler()\n    # Watch both src and tests directories\n    paths_to_watch = [\"src\", \"tests\"]\n    for path in paths_to_watch:\n        observer.schedule(handler, path, recursive=True)\n    # Start the observer",
        "detail": "dev_watch",
        "documentation": {}
    },
    {
        "label": "Predictor",
        "kind": 6,
        "importPath": "predict",
        "description": "predict",
        "peekOfCode": "class Predictor(BasePredictor):\n    def setup(self):\n        \"\"\"Load the model into memory to make running multiple predictions efficient.\"\"\"\n        self.embeddings = WordEmbeddings()\n        self.client = WordManifoldClient()\n    def predict(\n        self,\n        task: str = Input(\n            description=\"Task to perform\",\n            choices=[\"embed\", \"timeseries\", \"magic\", \"similarity\"],",
        "detail": "predict",
        "documentation": {}
    }
]