[
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TYPE_CHECKING",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Generic",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "euclidean_distances",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "cosine_distances",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "euclidean_distances",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "cosine_similarity",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "euclidean_distances",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "cosine_distances",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "euclidean_distances",
        "importPath": "sklearn.metrics.pairwise",
        "description": "sklearn.metrics.pairwise",
        "isExtraImport": true,
        "detail": "sklearn.metrics.pairwise",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "DistanceType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "DistanceType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "DistanceType",
        "importPath": "word_manifold.types",
        "description": "word_manifold.types",
        "isExtraImport": true,
        "detail": "word_manifold.types",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "Cell",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "Cell",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "Cell",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "CellType",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "Cell",
        "importPath": "word_manifold.manifold.vector_manifold",
        "description": "word_manifold.manifold.vector_manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "OCCULT_TERMS",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "OCCULT_TERMS",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings.word_embeddings",
        "description": "word_manifold.embeddings.word_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModel",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModel",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModel",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "CLIPProcessor",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "CLIPModel",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModel",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModelForSequenceClassification",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "pipeline",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoTokenizer",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "AutoModel",
        "importPath": "transformers",
        "description": "transformers",
        "isExtraImport": true,
        "detail": "transformers",
        "documentation": {}
    },
    {
        "label": "spacy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "spacy",
        "description": "spacy",
        "detail": "spacy",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "spacy.tokens",
        "description": "spacy.tokens",
        "isExtraImport": true,
        "detail": "spacy.tokens",
        "documentation": {}
    },
    {
        "label": "Token",
        "importPath": "spacy.tokens",
        "description": "spacy.tokens",
        "isExtraImport": true,
        "detail": "spacy.tokens",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings",
        "description": "word_manifold.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings",
        "description": "word_manifold.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings",
        "description": "word_manifold.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "importPath": "word_manifold.embeddings",
        "description": "word_manifold.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "importPath": "word_manifold.visualization.hypertools_visualizer",
        "description": "word_manifold.visualization.hypertools_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "RitualWorking",
        "importPath": "word_manifold.examples.ritual_evolution",
        "description": "word_manifold.examples.ritual_evolution",
        "isExtraImport": true,
        "detail": "word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "RitualWorking",
        "importPath": "word_manifold.examples.ritual_evolution",
        "description": "word_manifold.examples.ritual_evolution",
        "isExtraImport": true,
        "detail": "word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "CellularRule",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleParameterSet",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleSequence",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "HermeticPrinciple",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "ElementalForce",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "VibrationDirection",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_sequences",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "CellularRule",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleParameterSet",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleSequence",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "HermeticPrinciple",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "ElementalForce",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "VibrationDirection",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "CellularRule",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleSequence",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "importPath": "word_manifold.automata.cellular_rules",
        "description": "word_manifold.automata.cellular_rules",
        "isExtraImport": true,
        "detail": "word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "matplotlib.animation",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FFMpegWriter",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FFMpegWriter",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "PillowWriter",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FuncAnimation",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "FFMpegWriter",
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "isExtraImport": true,
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "imageio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "imageio",
        "description": "imageio",
        "detail": "imageio",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "PyPDF2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "PyPDF2",
        "description": "PyPDF2",
        "detail": "PyPDF2",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "BeautifulSoup",
        "importPath": "bs4",
        "description": "bs4",
        "isExtraImport": true,
        "detail": "bs4",
        "documentation": {}
    },
    {
        "label": "nltk",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nltk",
        "description": "nltk",
        "detail": "nltk",
        "documentation": {}
    },
    {
        "label": "word_tokenize",
        "importPath": "nltk.tokenize",
        "description": "nltk.tokenize",
        "isExtraImport": true,
        "detail": "nltk.tokenize",
        "documentation": {}
    },
    {
        "label": "sent_tokenize",
        "importPath": "nltk.tokenize",
        "description": "nltk.tokenize",
        "isExtraImport": true,
        "detail": "nltk.tokenize",
        "documentation": {}
    },
    {
        "label": "word_tokenize",
        "importPath": "nltk.tokenize",
        "description": "nltk.tokenize",
        "isExtraImport": true,
        "detail": "nltk.tokenize",
        "documentation": {}
    },
    {
        "label": "sent_tokenize",
        "importPath": "nltk.tokenize",
        "description": "nltk.tokenize",
        "isExtraImport": true,
        "detail": "nltk.tokenize",
        "documentation": {}
    },
    {
        "label": "stopwords",
        "importPath": "nltk.corpus",
        "description": "nltk.corpus",
        "isExtraImport": true,
        "detail": "nltk.corpus",
        "documentation": {}
    },
    {
        "label": "stopwords",
        "importPath": "nltk.corpus",
        "description": "nltk.corpus",
        "isExtraImport": true,
        "detail": "nltk.corpus",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "cached_property",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "SystemState",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "SystemState",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "importPath": "word_manifold.automata.system",
        "description": "word_manifold.automata.system",
        "isExtraImport": true,
        "detail": "word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold",
        "description": "word_manifold.manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "importPath": "word_manifold.manifold",
        "description": "word_manifold.manifold",
        "isExtraImport": true,
        "detail": "word_manifold.manifold",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "ConvexHull",
        "importPath": "scipy.spatial",
        "description": "scipy.spatial",
        "isExtraImport": true,
        "detail": "scipy.spatial",
        "documentation": {}
    },
    {
        "label": "ConvexHull",
        "importPath": "scipy.spatial",
        "description": "scipy.spatial",
        "isExtraImport": true,
        "detail": "scipy.spatial",
        "documentation": {}
    },
    {
        "label": "Voronoi",
        "importPath": "scipy.spatial",
        "description": "scipy.spatial",
        "isExtraImport": true,
        "detail": "scipy.spatial",
        "documentation": {}
    },
    {
        "label": "ConvexHull",
        "importPath": "scipy.spatial",
        "description": "scipy.spatial",
        "isExtraImport": true,
        "detail": "scipy.spatial",
        "documentation": {}
    },
    {
        "label": "voronoi_plot_2d",
        "importPath": "scipy.spatial",
        "description": "scipy.spatial",
        "isExtraImport": true,
        "detail": "scipy.spatial",
        "documentation": {}
    },
    {
        "label": "splprep",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "splev",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "Rbf",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "splprep",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "splev",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "DBSCAN",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "KMeans",
        "importPath": "sklearn.cluster",
        "description": "sklearn.cluster",
        "isExtraImport": true,
        "detail": "sklearn.cluster",
        "documentation": {}
    },
    {
        "label": "TSNE",
        "importPath": "sklearn.manifold",
        "description": "sklearn.manifold",
        "isExtraImport": true,
        "detail": "sklearn.manifold",
        "documentation": {}
    },
    {
        "label": "umap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "umap",
        "description": "umap",
        "detail": "umap",
        "documentation": {}
    },
    {
        "label": "librosa",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "librosa",
        "description": "librosa",
        "detail": "librosa",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "torch.nn.functional",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "click",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "click",
        "description": "click",
        "detail": "click",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "hypertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hypertools",
        "description": "hypertools",
        "detail": "hypertools",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "matplotlib.colors",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "LinearSegmentedColormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "Colormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "LinearSegmentedColormap",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "Axes3D",
        "importPath": "mpl_toolkits.mplot3d",
        "description": "mpl_toolkits.mplot3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "cdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "cosine",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "euclidean",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "pdist",
        "importPath": "scipy.spatial.distance",
        "description": "scipy.spatial.distance",
        "isExtraImport": true,
        "detail": "scipy.spatial.distance",
        "documentation": {}
    },
    {
        "label": "plotly.graph_objects",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.graph_objects",
        "description": "plotly.graph_objects",
        "detail": "plotly.graph_objects",
        "documentation": {}
    },
    {
        "label": "Dash",
        "importPath": "dash",
        "description": "dash",
        "isExtraImport": true,
        "detail": "dash",
        "documentation": {}
    },
    {
        "label": "html",
        "importPath": "dash",
        "description": "dash",
        "isExtraImport": true,
        "detail": "dash",
        "documentation": {}
    },
    {
        "label": "dcc",
        "importPath": "dash",
        "description": "dash",
        "isExtraImport": true,
        "detail": "dash",
        "documentation": {}
    },
    {
        "label": "Input",
        "importPath": "dash",
        "description": "dash",
        "isExtraImport": true,
        "detail": "dash",
        "documentation": {}
    },
    {
        "label": "Output",
        "importPath": "dash",
        "description": "dash",
        "isExtraImport": true,
        "detail": "dash",
        "documentation": {}
    },
    {
        "label": "State",
        "importPath": "dash",
        "description": "dash",
        "isExtraImport": true,
        "detail": "dash",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "MinMaxScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "send_from_directory",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "render_template",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "PCA",
        "importPath": "sklearn.decomposition",
        "description": "sklearn.decomposition",
        "isExtraImport": true,
        "detail": "sklearn.decomposition",
        "documentation": {}
    },
    {
        "label": "colorsys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "colorsys",
        "description": "colorsys",
        "detail": "colorsys",
        "documentation": {}
    },
    {
        "label": "gaussian_filter1d",
        "importPath": "scipy.ndimage",
        "description": "scipy.ndimage",
        "isExtraImport": true,
        "detail": "scipy.ndimage",
        "documentation": {}
    },
    {
        "label": "gaussian_filter1d",
        "importPath": "scipy.ndimage",
        "description": "scipy.ndimage",
        "isExtraImport": true,
        "detail": "scipy.ndimage",
        "documentation": {}
    },
    {
        "label": "LineCollection",
        "importPath": "matplotlib.collections",
        "description": "matplotlib.collections",
        "isExtraImport": true,
        "detail": "matplotlib.collections",
        "documentation": {}
    },
    {
        "label": "LineCollection",
        "importPath": "matplotlib.collections",
        "description": "matplotlib.collections",
        "isExtraImport": true,
        "detail": "matplotlib.collections",
        "documentation": {}
    },
    {
        "label": "PathPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "PathPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Circle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "PathPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "PathPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "PathPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "matplotlib.path",
        "description": "matplotlib.path",
        "isExtraImport": true,
        "detail": "matplotlib.path",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "matplotlib.path",
        "description": "matplotlib.path",
        "isExtraImport": true,
        "detail": "matplotlib.path",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "matplotlib.path",
        "description": "matplotlib.path",
        "isExtraImport": true,
        "detail": "matplotlib.path",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "matplotlib.path",
        "description": "matplotlib.path",
        "isExtraImport": true,
        "detail": "matplotlib.path",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "matplotlib.path",
        "description": "matplotlib.path",
        "isExtraImport": true,
        "detail": "matplotlib.path",
        "documentation": {}
    },
    {
        "label": "ScalarMappable",
        "importPath": "matplotlib.cm",
        "description": "matplotlib.cm",
        "isExtraImport": true,
        "detail": "matplotlib.cm",
        "documentation": {}
    },
    {
        "label": "make_subplots",
        "importPath": "plotly.subplots",
        "description": "plotly.subplots",
        "isExtraImport": true,
        "detail": "plotly.subplots",
        "documentation": {}
    },
    {
        "label": "make_subplots",
        "importPath": "plotly.subplots",
        "description": "plotly.subplots",
        "isExtraImport": true,
        "detail": "plotly.subplots",
        "documentation": {}
    },
    {
        "label": "networkx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "networkx",
        "description": "networkx",
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "scipy.signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "NullFormatter",
        "importPath": "matplotlib.ticker",
        "description": "matplotlib.ticker",
        "isExtraImport": true,
        "detail": "matplotlib.ticker",
        "documentation": {}
    },
    {
        "label": "manifold",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "datasets",
        "importPath": "sklearn",
        "description": "sklearn",
        "isExtraImport": true,
        "detail": "sklearn",
        "documentation": {}
    },
    {
        "label": "RecursiveReducer",
        "importPath": "word_manifold.manifold.reduction",
        "description": "word_manifold.manifold.reduction",
        "isExtraImport": true,
        "detail": "word_manifold.manifold.reduction",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "ipywidgets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ipywidgets",
        "description": "ipywidgets",
        "detail": "ipywidgets",
        "documentation": {}
    },
    {
        "label": "display",
        "importPath": "IPython.display",
        "description": "IPython.display",
        "isExtraImport": true,
        "detail": "IPython.display",
        "documentation": {}
    },
    {
        "label": "clear_output",
        "importPath": "IPython.display",
        "description": "IPython.display",
        "isExtraImport": true,
        "detail": "IPython.display",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "ShapeVisualizer",
        "importPath": "word_manifold.visualization.shape_visualizer",
        "description": "word_manifold.visualization.shape_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "ExportConfig",
        "importPath": "word_manifold.visualization.shape_visualizer",
        "description": "word_manifold.visualization.shape_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "ShapeVisualizer",
        "importPath": "word_manifold.visualization.shape_visualizer",
        "description": "word_manifold.visualization.shape_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "SymbolicVisualizer",
        "importPath": "word_manifold.visualization.symbolic_visualizer",
        "description": "word_manifold.visualization.symbolic_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.symbolic_visualizer",
        "documentation": {}
    },
    {
        "label": "SemanticTreeVisualizer",
        "importPath": "word_manifold.visualization.semantic_tree_visualizer",
        "description": "word_manifold.visualization.semantic_tree_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "SemanticNode",
        "importPath": "word_manifold.visualization.semantic_tree_visualizer",
        "description": "word_manifold.visualization.semantic_tree_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "SemanticTreeVisualizer",
        "importPath": "word_manifold.visualization.semantic_tree_visualizer",
        "description": "word_manifold.visualization.semantic_tree_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "PhraseEmbedder",
        "importPath": "word_manifold.embeddings.phrase_embeddings",
        "description": "word_manifold.embeddings.phrase_embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "constr",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "APIRouter",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Depends",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "EmbeddingRequest",
        "importPath": "word_manifold.api.models.embeddings",
        "description": "word_manifold.api.models.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "EmbeddingResponse",
        "importPath": "word_manifold.api.models.embeddings",
        "description": "word_manifold.api.models.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "BatchEmbeddingRequest",
        "importPath": "word_manifold.api.models.embeddings",
        "description": "word_manifold.api.models.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "BatchEmbeddingResponse",
        "importPath": "word_manifold.api.models.embeddings",
        "description": "word_manifold.api.models.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "SimilarityRequest",
        "importPath": "word_manifold.api.models.embeddings",
        "description": "word_manifold.api.models.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "SimilarityResponse",
        "importPath": "word_manifold.api.models.embeddings",
        "description": "word_manifold.api.models.embeddings",
        "isExtraImport": true,
        "detail": "word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "TransformerEmbeddingProvider",
        "importPath": "word_manifold.core.embeddings.transformers",
        "description": "word_manifold.core.embeddings.transformers",
        "isExtraImport": true,
        "detail": "word_manifold.core.embeddings.transformers",
        "documentation": {}
    },
    {
        "label": "InstructEmbeddingProvider",
        "importPath": "word_manifold.core.embeddings.transformers",
        "description": "word_manifold.core.embeddings.transformers",
        "isExtraImport": true,
        "detail": "word_manifold.core.embeddings.transformers",
        "documentation": {}
    },
    {
        "label": "BaseSettings",
        "importPath": "pydantic_settings",
        "description": "pydantic_settings",
        "isExtraImport": true,
        "detail": "pydantic_settings",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "numpy.typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy.typing",
        "description": "numpy.typing",
        "detail": "numpy.typing",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "SentenceTransformer",
        "importPath": "sentence_transformers",
        "description": "sentence_transformers",
        "isExtraImport": true,
        "detail": "sentence_transformers",
        "documentation": {}
    },
    {
        "label": "ray",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ray",
        "description": "ray",
        "detail": "ray",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Empty",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "HDBSCAN",
        "importPath": "hdbscan",
        "description": "hdbscan",
        "isExtraImport": true,
        "detail": "hdbscan",
        "documentation": {}
    },
    {
        "label": "HDBSCAN",
        "importPath": "hdbscan",
        "description": "hdbscan",
        "isExtraImport": true,
        "detail": "hdbscan",
        "documentation": {}
    },
    {
        "label": "spearmanr",
        "importPath": "scipy.stats",
        "description": "scipy.stats",
        "isExtraImport": true,
        "detail": "scipy.stats",
        "documentation": {}
    },
    {
        "label": "Figure",
        "importPath": "matplotlib.figure",
        "description": "matplotlib.figure",
        "isExtraImport": true,
        "detail": "matplotlib.figure",
        "documentation": {}
    },
    {
        "label": "Figure",
        "importPath": "matplotlib.figure",
        "description": "matplotlib.figure",
        "isExtraImport": true,
        "detail": "matplotlib.figure",
        "documentation": {}
    },
    {
        "label": "Figure",
        "importPath": "matplotlib.figure",
        "description": "matplotlib.figure",
        "isExtraImport": true,
        "detail": "matplotlib.figure",
        "documentation": {}
    },
    {
        "label": "Figure",
        "importPath": "matplotlib.figure",
        "description": "matplotlib.figure",
        "isExtraImport": true,
        "detail": "matplotlib.figure",
        "documentation": {}
    },
    {
        "label": "webbrowser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "webbrowser",
        "description": "webbrowser",
        "detail": "webbrowser",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "Poly3DCollection",
        "importPath": "mpl_toolkits.mplot3d.art3d",
        "description": "mpl_toolkits.mplot3d.art3d",
        "isExtraImport": true,
        "detail": "mpl_toolkits.mplot3d.art3d",
        "documentation": {}
    },
    {
        "label": "Slider",
        "importPath": "matplotlib.widgets",
        "description": "matplotlib.widgets",
        "isExtraImport": true,
        "detail": "matplotlib.widgets",
        "documentation": {}
    },
    {
        "label": "Button",
        "importPath": "matplotlib.widgets",
        "description": "matplotlib.widgets",
        "isExtraImport": true,
        "detail": "matplotlib.widgets",
        "documentation": {}
    },
    {
        "label": "CheckButtons",
        "importPath": "matplotlib.widgets",
        "description": "matplotlib.widgets",
        "isExtraImport": true,
        "detail": "matplotlib.widgets",
        "documentation": {}
    },
    {
        "label": "CORS",
        "importPath": "flask_cors",
        "description": "flask_cors",
        "isExtraImport": true,
        "detail": "flask_cors",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "Mock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "Mock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "RitualVisualizer",
        "importPath": "word_manifold.visualization.ritual_visualizer",
        "description": "word_manifold.visualization.ritual_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "RitualPhase",
        "importPath": "word_manifold.visualization.ritual_visualizer",
        "description": "word_manifold.visualization.ritual_visualizer",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "HermeticPrinciple",
        "importPath": "word_manifold.automata.hermetic_principles",
        "description": "word_manifold.automata.hermetic_principles",
        "isExtraImport": true,
        "detail": "word_manifold.automata.hermetic_principles",
        "documentation": {}
    },
    {
        "label": "Visualizer",
        "importPath": "word_manifold.visualization.base",
        "description": "word_manifold.visualization.base",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "InteractiveVisualizer",
        "importPath": "word_manifold.visualization.base",
        "description": "word_manifold.visualization.base",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "VisualizationData",
        "importPath": "word_manifold.visualization.base",
        "description": "word_manifold.visualization.base",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "ManifoldVisualizer",
        "importPath": "word_manifold.visualization.manifold_vis",
        "description": "word_manifold.visualization.manifold_vis",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.manifold_vis",
        "documentation": {}
    },
    {
        "label": "ManifoldPlotData",
        "importPath": "word_manifold.visualization.manifold_vis",
        "description": "word_manifold.visualization.manifold_vis",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.manifold_vis",
        "documentation": {}
    },
    {
        "label": "InteractiveManifoldVisualizer",
        "importPath": "word_manifold.visualization.interactive",
        "description": "word_manifold.visualization.interactive",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.interactive",
        "documentation": {}
    },
    {
        "label": "create_color_gradient",
        "importPath": "word_manifold.visualization.utils",
        "description": "word_manifold.visualization.utils",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "scale_coordinates",
        "importPath": "word_manifold.visualization.utils",
        "description": "word_manifold.visualization.utils",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "calculate_marker_sizes",
        "importPath": "word_manifold.visualization.utils",
        "description": "word_manifold.visualization.utils",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "create_subplot_grid",
        "importPath": "word_manifold.visualization.utils",
        "description": "word_manifold.visualization.utils",
        "isExtraImport": true,
        "detail": "word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "Observer",
        "importPath": "watchdog.observers",
        "description": "watchdog.observers",
        "isExtraImport": true,
        "detail": "watchdog.observers",
        "documentation": {}
    },
    {
        "label": "FileSystemEventHandler",
        "importPath": "watchdog.events",
        "description": "watchdog.events",
        "isExtraImport": true,
        "detail": "watchdog.events",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "create_celestial_rules",
        "kind": 2,
        "importPath": "build.lib.word_manifold.automata.additional_rules",
        "description": "build.lib.word_manifold.automata.additional_rules",
        "peekOfCode": "def create_celestial_rules() -> Dict[str, CellularRule]:\n    \"\"\"\n    Create rules based on celestial bodies and higher spiritual archetypes.\n    These rules complement the base rule set by adding transformations\n    related to cosmic forces and stellar/planetary influences.\n    Returns:\n        Dictionary mapping rule names to CellularRule objects\n    \"\"\"\n    rules = {}",
        "detail": "build.lib.word_manifold.automata.additional_rules",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.automata.additional_rules",
        "description": "build.lib.word_manifold.automata.additional_rules",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef create_celestial_rules() -> Dict[str, CellularRule]:\n    \"\"\"\n    Create rules based on celestial bodies and higher spiritual archetypes.\n    These rules complement the base rule set by adding transformations\n    related to cosmic forces and stellar/planetary influences.\n    Returns:\n        Dictionary mapping rule names to CellularRule objects\n    \"\"\"\n    rules = {}",
        "detail": "build.lib.word_manifold.automata.additional_rules",
        "documentation": {}
    },
    {
        "label": "HermeticPrinciple",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "class HermeticPrinciple(Enum):\n    \"\"\"The seven Hermetic principles that govern transformation rules.\"\"\"\n    MENTALISM = auto()         # \"THE ALL is MIND; The Universe is Mental.\"\n    CORRESPONDENCE = auto()    # \"As above, so below; as below, so above.\"\n    VIBRATION = auto()         # \"Nothing rests; everything moves; everything vibrates.\"\n    POLARITY = auto()          # \"Everything is Dual; everything has poles.\"\n    RHYTHM = auto()            # \"Everything flows, out and in; everything has its tides.\"\n    CAUSE_EFFECT = auto()      # \"Every Cause has its Effect; Every Effect has its Cause.\"\n    GENDER = auto()            # \"Gender is in everything; everything has its Masculine and Feminine.\"\nclass ElementalForce(Enum):",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "ElementalForce",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "class ElementalForce(Enum):\n    \"\"\"The four elemental forces that influence transformation.\"\"\"\n    EARTH = auto()  # Stability, materiality, resistance to change\n    AIR = auto()    # Intellect, communication, adaptability\n    FIRE = auto()   # Energy, transformation, creation/destruction\n    WATER = auto()  # Emotion, intuition, connection\nclass VibrationDirection(Enum):\n    \"\"\"Possible directions of vibrational change in the vector space.\"\"\"\n    ASCENDING = auto()  # Moving towards higher vibration (complexity, abstraction)\n    DESCENDING = auto() # Moving towards lower vibration (simplicity, concreteness)",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "VibrationDirection",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "class VibrationDirection(Enum):\n    \"\"\"Possible directions of vibrational change in the vector space.\"\"\"\n    ASCENDING = auto()  # Moving towards higher vibration (complexity, abstraction)\n    DESCENDING = auto() # Moving towards lower vibration (simplicity, concreteness)\n    EXPANDING = auto()  # Increasing in scope or influence\n    CONTRACTING = auto() # Decreasing in scope or influence\n    HARMONIZING = auto() # Moving towards balance with neighbors\n    POLARIZING = auto()  # Moving away from neighbors, increasing distinction\n@dataclass\nclass RuleParameterSet:",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleParameterSet",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "class RuleParameterSet:\n    \"\"\"Parameters that define how a transformation rule behaves.\"\"\"\n    magnitude: float = 1.0                  # Base strength of transformation\n    principle: HermeticPrinciple = HermeticPrinciple.CORRESPONDENCE\n    elemental_influence: Dict[ElementalForce, float] = None  # Influence of each element\n    numerological_weights: Dict[int, float] = None  # Weights by numerological value\n    cell_type_weights: Dict[CellType, float] = None  # Weights by cell type\n    vibration_direction: VibrationDirection = VibrationDirection.HARMONIZING\n    def __init__(self, magnitude=1.0, principle=None, vibration_direction=None,\n                 numerological_weights=None, elemental_influence=None, cell_type_weights=None):",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "CellularRule",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "class CellularRule:\n    \"\"\"\n    A rule that defines how cells transform in the vector space.\n    Each rule embodies one or more hermetic principles and governs \n    the evolution of the cellular automata system.\n    \"\"\"\n    def __init__(\n        self, \n        name: str, \n        description: str,",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleSequence",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "class RuleSequence:\n    \"\"\"\n    A sequence of cellular automata rules to be applied in a specific order.\n    The sequence can be applied in different ways:\n    - Sequentially (default): Rules are applied in order\n    - Conditionally: Rules are applied based on conditions\n    - With branching: Different paths can be taken based on state\n    The sequence also supports:\n    - Dependencies between rules\n    - Conditions for rule application",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "kind": 2,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "def create_predefined_rules() -> Dict[str, CellularRule]:\n    \"\"\"\n    Create a set of predefined cellular automata rules based on\n    hermetic principles and occult correspondences.\n    Returns:\n        Dictionary mapping rule names to CellularRule objects\n    \"\"\"\n    rules = {}\n    # The Great Work Rule - Based on alchemical transformation\n    great_work_params = RuleParameterSet(",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_sequences",
        "kind": 2,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "def create_predefined_sequences() -> Dict[str, RuleSequence]:\n    \"\"\"\n    Create a set of predefined rule sequences based on\n    magical rituals and occult correspondences.\n    Returns:\n        Dictionary mapping sequence names to RuleSequence objects\n    \"\"\"\n    rules = create_predefined_rules()\n    sequences = {}\n    # The Great Work Sequence - Alchemical transformation from base to divine",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.automata.cellular_rules",
        "description": "build.lib.word_manifold.automata.cellular_rules",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HermeticPrinciple(Enum):\n    \"\"\"The seven Hermetic principles that govern transformation rules.\"\"\"\n    MENTALISM = auto()         # \"THE ALL is MIND; The Universe is Mental.\"\n    CORRESPONDENCE = auto()    # \"As above, so below; as below, so above.\"\n    VIBRATION = auto()         # \"Nothing rests; everything moves; everything vibrates.\"\n    POLARITY = auto()          # \"Everything is Dual; everything has poles.\"\n    RHYTHM = auto()            # \"Everything flows, out and in; everything has its tides.\"\n    CAUSE_EFFECT = auto()      # \"Every Cause has its Effect; Every Effect has its Cause.\"\n    GENDER = auto()            # \"Gender is in everything; everything has its Masculine and Feminine.\"",
        "detail": "build.lib.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.system",
        "description": "build.lib.word_manifold.automata.system",
        "peekOfCode": "class EvolutionPattern(Enum):\n    \"\"\"Patterns of evolution that the automata system can follow.\"\"\"\n    LINEAR = auto()      # Sequential application of rules\n    CYCLIC = auto()      # Repeated application of rules in a cycle\n    SPIRAL = auto()      # Cyclic with increasing intensity\n    CHAOTIC = auto()     # Random selection of rules\n    THELEMIC = auto()    # Rules selected based on True Will principle\n    KABBALISTIC = auto() # Rules follow Tree of Life pattern\n@dataclass\nclass SystemState:",
        "detail": "build.lib.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "SystemState",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.system",
        "description": "build.lib.word_manifold.automata.system",
        "peekOfCode": "class SystemState:\n    \"\"\"State of the automata system at a point in time.\"\"\"\n    generation: int                # Current generation number\n    active_rules: List[str]        # Names of rules currently active\n    manifold_state: Dict[str, Any] # State snapshot of the manifold\n    timestamp: float               # Unix timestamp when state was captured\n    metrics: Dict[str, float]      # Metrics about the system's state\nclass AutomataSystem:\n    \"\"\"\n    A system that orchestrates the application of cellular automata rules",
        "detail": "build.lib.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "kind": 6,
        "importPath": "build.lib.word_manifold.automata.system",
        "description": "build.lib.word_manifold.automata.system",
        "peekOfCode": "class AutomataSystem:\n    \"\"\"\n    A system that orchestrates the application of cellular automata rules\n    to a word vector manifold according to hermetic principles.\n    This class manages the evolution of the manifold through generations,\n    applying rules according to specified patterns and tracking the system's\n    state over time.\n    \"\"\"\n    def __init__(\n        self,",
        "detail": "build.lib.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.automata.system",
        "description": "build.lib.word_manifold.automata.system",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass EvolutionPattern(Enum):\n    \"\"\"Patterns of evolution that the automata system can follow.\"\"\"\n    LINEAR = auto()      # Sequential application of rules\n    CYCLIC = auto()      # Repeated application of rules in a cycle\n    SPIRAL = auto()      # Cyclic with increasing intensity\n    CHAOTIC = auto()     # Random selection of rules\n    THELEMIC = auto()    # Rules selected based on True Will principle\n    KABBALISTIC = auto() # Rules follow Tree of Life pattern\n@dataclass",
        "detail": "build.lib.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "PhraseEmbedding",
        "kind": 6,
        "importPath": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "description": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "class PhraseEmbedding:\n    \"\"\"\n    A class representing the embedding of a phrase or sentence,\n    including both its semantic content and structural shape.\n    \"\"\"\n    def __init__(self, text: str, embedding: np.ndarray, shape_params: Dict):\n        self.text = text\n        self.embedding = embedding\n        self.shape_params = shape_params\nclass PhraseEmbedder:",
        "detail": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "PhraseEmbedder",
        "kind": 6,
        "importPath": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "description": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "class PhraseEmbedder:\n    \"\"\"\n    A class for embedding phrases and sentences into a semantic manifold,\n    extracting both meaning and structural patterns.\n    \"\"\"\n    def __init__(\n        self,\n        model_name: str = \"Snowflake/snowflake-arctic-embed-l\",  # Updated to use Arctic-embed\n        use_gpu: bool = True\n    ):",
        "detail": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "description": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n# Create formatters and handlers if they don't exist\nif not logger.handlers:\n    # Create console handler with formatting\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    console_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - [%(levelname)s] - %(message)s'\n    )",
        "detail": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "EMOTION_ANCHORS",
        "kind": 5,
        "importPath": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "description": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "EMOTION_ANCHORS = {\n    'joy': nlp(' '.join(['happy', 'joyful', 'delighted', 'elated'])).vector.mean(axis=0),\n    'sadness': nlp(' '.join(['sad', 'depressed', 'gloomy', 'melancholy'])).vector.mean(axis=0),\n    'anger': nlp(' '.join(['angry', 'furious', 'enraged', 'hostile'])).vector.mean(axis=0),\n    'fear': nlp(' '.join(['afraid', 'scared', 'terrified', 'anxious'])).vector.mean(axis=0),\n    'surprise': nlp(' '.join(['surprised', 'amazed', 'astonished', 'shocked'])).vector.mean(axis=0),\n    'disgust': nlp(' '.join(['disgusted', 'repulsed', 'revolted', 'appalled'])).vector.mean(axis=0),\n    'trust': nlp(' '.join(['trusting', 'confident', 'secure', 'reliable'])).vector.mean(axis=0),\n    'anticipation': nlp(' '.join(['expectant', 'eager', 'excited', 'hopeful'])).vector.mean(axis=0)\n}",
        "detail": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "EMOTION_ANCHORS",
        "kind": 5,
        "importPath": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "description": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "EMOTION_ANCHORS = {\n    emotion: vector / np.linalg.norm(vector)\n    for emotion, vector in EMOTION_ANCHORS.items()\n}\nclass PhraseEmbedding:\n    \"\"\"\n    A class representing the embedding of a phrase or sentence,\n    including both its semantic content and structural shape.\n    \"\"\"\n    def __init__(self, text: str, embedding: np.ndarray, shape_params: Dict):",
        "detail": "build.lib.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "kind": 6,
        "importPath": "build.lib.word_manifold.embeddings.word_embeddings",
        "description": "build.lib.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "class WordEmbeddings:\n    \"\"\"\n    A class to manage word embeddings from various sources.\n    Supports:\n    - spaCy models (e.g., 'en_core_web_sm', 'en_core_web_md', 'en_core_web_lg')\n    - HuggingFace models (e.g., 'bert-base-uncased', 'gpt2', etc.)\n    - Custom embedding spaces\n    \"\"\"\n    def __init__(\n        self,",
        "detail": "build.lib.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.embeddings.word_embeddings",
        "description": "build.lib.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass WordEmbeddings:\n    \"\"\"\n    A class to manage word embeddings from various sources.\n    Supports:\n    - spaCy models (e.g., 'en_core_web_sm', 'en_core_web_md', 'en_core_web_lg')\n    - HuggingFace models (e.g., 'bert-base-uncased', 'gpt2', etc.)\n    - Custom embedding spaces\n    \"\"\"\n    def __init__(",
        "detail": "build.lib.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "ForceFieldDemo",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.force_field_demo",
        "description": "build.lib.word_manifold.examples.force_field_demo",
        "peekOfCode": "class ForceFieldDemo:\n    def __init__(self, n_dimensions=3):\n        \"\"\"Initialize the force field demonstration.\n        Args:\n            n_dimensions (int): Number of dimensions for the semantic space\n        \"\"\"\n        self.n_dimensions = n_dimensions\n        self.embeddings = None\n        self.manifold = None\n        self.visualizer = None",
        "detail": "build.lib.word_manifold.examples.force_field_demo",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "build.lib.word_manifold.examples.force_field_demo",
        "description": "build.lib.word_manifold.examples.force_field_demo",
        "peekOfCode": "def main():\n    \"\"\"Run the force field visualization demo.\"\"\"\n    # Create and run simulation\n    demo = ForceFieldDemo(n_dimensions=3)\n    demo.prepare_components()\n    viz_path = demo.simulate_force_field()\n    logger.info(f\"\"\"\n    Force field visualization complete!\n    This demonstration shows how concepts move through a semantic force field:\n    - Red points are attractors (positive concepts)",
        "detail": "build.lib.word_manifold.examples.force_field_demo",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.force_field_demo",
        "description": "build.lib.word_manifold.examples.force_field_demo",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ForceFieldDemo:\n    def __init__(self, n_dimensions=3):\n        \"\"\"Initialize the force field demonstration.\n        Args:\n            n_dimensions (int): Number of dimensions for the semantic space\n        \"\"\"\n        self.n_dimensions = n_dimensions\n        self.embeddings = None\n        self.manifold = None",
        "detail": "build.lib.word_manifold.examples.force_field_demo",
        "documentation": {}
    },
    {
        "label": "HyperdimensionalRitual",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "description": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "peekOfCode": "class HyperdimensionalRitual:\n    \"\"\"\n    A class demonstrating hyperdimensional visualization of Thelemic rituals.\n    \"\"\"\n    def __init__(\n        self,\n        n_dimensions: int = 5,  # We'll use 5D for richer semantic representation\n        output_dir: str = \"visualizations/hyperdimensional\"\n    ):\n        self.n_dimensions = n_dimensions",
        "detail": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "description": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "peekOfCode": "def main():\n    \"\"\"Run the hyperdimensional ritual visualization example.\"\"\"\n    # Create and prepare the ritual\n    ritual = HyperdimensionalRitual(n_dimensions=5)\n    ritual.prepare_components()\n    # Create visualization\n    viz_path = ritual.visualize_ritual_transformation()\n    logger.info(f\"\"\"\n    Hyperdimensional ritual visualization complete!\n    The visualization shows the evolution of Thelemic concepts through a 5-dimensional",
        "detail": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "description": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HyperdimensionalRitual:\n    \"\"\"\n    A class demonstrating hyperdimensional visualization of Thelemic rituals.\n    \"\"\"\n    def __init__(\n        self,\n        n_dimensions: int = 5,  # We'll use 5D for richer semantic representation\n        output_dir: str = \"visualizations/hyperdimensional\"\n    ):",
        "detail": "build.lib.word_manifold.examples.hyperdimensional_ritual",
        "documentation": {}
    },
    {
        "label": "RitualWorking",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.ritual_evolution",
        "description": "build.lib.word_manifold.examples.ritual_evolution",
        "peekOfCode": "class RitualWorking:\n    \"\"\"\n    A class that implements a complete magical working in word vector space.\n    \"\"\"\n    def _create_evolution_animation(self, key_terms):\n        \"\"\"\n        Create an animation of the evolution of machinic desires using fluid visual transformations and emergent patterns.\n        Args:\n            key_terms: List of key terms to highlight in the animation description\n        Returns:",
        "detail": "build.lib.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "memoize",
        "kind": 2,
        "importPath": "build.lib.word_manifold.examples.ritual_evolution",
        "description": "build.lib.word_manifold.examples.ritual_evolution",
        "peekOfCode": "def memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.\n    Results are cached in memory and on disk for persistence between runs.\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # Create a unique key based on function name and arguments\n        key_parts = [func.__name__]\n        # Add class name if it's a method",
        "detail": "build.lib.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "build.lib.word_manifold.examples.ritual_evolution",
        "description": "build.lib.word_manifold.examples.ritual_evolution",
        "peekOfCode": "def main():\n    \"\"\" Demonstrate the ritual evolution process. \"\"\"\n    ritual = RitualWorking(\n        ritual_name=\"True Will Discovery\",\n        ritual_intent=\"To discover and align with one's True Will through semantic transformation\"\n    )\n    # Prepare components\n    ritual.prepare_components()\n    # Perform the ritual\n    ritual.perform_ritual()",
        "detail": "build.lib.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.ritual_evolution",
        "description": "build.lib.word_manifold.examples.ritual_evolution",
        "peekOfCode": "logger = logging.getLogger(\"ritual_evolution\")\n# Directory for saving outputs\nOUTPUT_DIR = Path(\"ritual_outputs\")\nCACHE_DIR = Path(\".ritual_cache\")\n# Create cache directory if it doesn't exist\nCACHE_DIR.mkdir(exist_ok=True)\n# Function cache decorator with key based on function arguments\ndef memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.",
        "detail": "build.lib.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "OUTPUT_DIR",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.ritual_evolution",
        "description": "build.lib.word_manifold.examples.ritual_evolution",
        "peekOfCode": "OUTPUT_DIR = Path(\"ritual_outputs\")\nCACHE_DIR = Path(\".ritual_cache\")\n# Create cache directory if it doesn't exist\nCACHE_DIR.mkdir(exist_ok=True)\n# Function cache decorator with key based on function arguments\ndef memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.\n    Results are cached in memory and on disk for persistence between runs.\n    \"\"\"",
        "detail": "build.lib.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "CACHE_DIR",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.ritual_evolution",
        "description": "build.lib.word_manifold.examples.ritual_evolution",
        "peekOfCode": "CACHE_DIR = Path(\".ritual_cache\")\n# Create cache directory if it doesn't exist\nCACHE_DIR.mkdir(exist_ok=True)\n# Function cache decorator with key based on function arguments\ndef memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.\n    Results are cached in memory and on disk for persistence between runs.\n    \"\"\"\n    @functools.wraps(func)",
        "detail": "build.lib.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "ReadingStep",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.semantic_crystallization",
        "description": "build.lib.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "class ReadingStep:\n    \"\"\"Represents a single step in the reading sequence.\"\"\"\n    card: str  # The card or concept being integrated\n    keywords: List[str]  # Associated keywords/meanings\n    position: str  # Position or aspect in the reading (e.g., \"past\", \"present\", \"future\")\n    influence: float = 1.0  # Relative influence of this step (0-1)\nterms=[\n                # Major Arcana\n                \"fool\", \"magician\", \"priestess\", \"empress\", \"emperor\",\n                \"hierophant\", \"lovers\", \"chariot\", \"strength\", \"hermit\",",
        "detail": "build.lib.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "SemanticCrystallization",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.semantic_crystallization",
        "description": "build.lib.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "class SemanticCrystallization:\n    \"\"\"\n    Visualizes the crystallization of meaning during a reading sequence.\n    This class tracks how semantic space transforms as each new card or concept\n    is integrated, showing the accumulation and crystallization of meaning over time.\n    \"\"\"\n    def __init__(\n        self,\n        n_dimensions: int = 5,\n        output_dir: str = \"visualizations/crystallization\",",
        "detail": "build.lib.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "build.lib.word_manifold.examples.semantic_crystallization",
        "description": "build.lib.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "def main():\n    \"\"\"Run the semantic crystallization example.\"\"\"\n    # Create and prepare crystallization viewer\n    crystal = SemanticCrystallization(n_dimensions=5)\n    crystal.prepare_components()\n    # Example Celtic Cross reading sequence\n    reading_sequence = [\n        # Central cross\n        (\"present\", \"tower\", [\"disruption\", \"awakening\", \"revelation\"]),\n        (\"challenge\", \"death\", [\"transformation\", \"ending\", \"rebirth\"]),",
        "detail": "build.lib.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.semantic_crystallization",
        "description": "build.lib.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass ReadingStep:\n    \"\"\"Represents a single step in the reading sequence.\"\"\"\n    card: str  # The card or concept being integrated\n    keywords: List[str]  # Associated keywords/meanings\n    position: str  # Position or aspect in the reading (e.g., \"past\", \"present\", \"future\")\n    influence: float = 1.0  # Relative influence of this step (0-1)\nterms=[\n                # Major Arcana",
        "detail": "build.lib.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "ThelemaMetrics",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.thelemic_evolution",
        "description": "build.lib.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "class ThelemaMetrics:\n    \"\"\"\n    A class to calculate and track metrics for the Thelemic evolution of a word manifold.\n    Metrics include:\n    - Semantic entropy: Measure of semantic diversity\n    - Numerological alignment: Correspondence between numerological values\n    - Will manifestation: How closely the system follows its \"True Will\"\n    - Transmutation index: Degree of alchemical transformation\n    \"\"\"\n    def __init__(self):",
        "detail": "build.lib.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "BasicVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.examples.thelemic_evolution",
        "description": "build.lib.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "class BasicVisualizer:\n    \"\"\"\n    A basic visualization class for when the full visualizer is not available.\n    This creates simple 2D plots of the manifold's reduced representation.\n    \"\"\"\n    def __init__(self, manifold: VectorManifold, save_path: str):\n        \"\"\"\n        Initialize the basic visualizer.\n        Args:\n            manifold: The vector manifold to visualize",
        "detail": "build.lib.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "run_thelemic_evolution",
        "kind": 2,
        "importPath": "build.lib.word_manifold.examples.thelemic_evolution",
        "description": "build.lib.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "def run_thelemic_evolution(\n    generations: int = 22,  # One for each Major Arcana\n    save_path: str = None,\n    model_name: str = \"bert-base-uncased\",\n    n_cells: int = 22,\n    random_state: int = 93  # Significant in Thelema/Crowley's work\n):\n    \"\"\"\n    Run the Thelemic evolution of the word manifold.\n    Args:",
        "detail": "build.lib.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.examples.thelemic_evolution",
        "description": "build.lib.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Add the project root to the Python path if running as a script\nif __name__ == \"__main__\":\n    project_root = str(Path(__file__).resolve().parents[3])\n    sys.path.insert(0, project_root)\n# Import Word Manifold components\nfrom word_manifold.embeddings.word_embeddings import WordEmbeddings\nfrom word_manifold.manifold.vector_manifold import VectorManifold, CellType\nfrom word_manifold.automata.cellular_rules import create_predefined_rules\nfrom word_manifold.automata.system import AutomataSystem, EvolutionPattern, SystemState",
        "detail": "build.lib.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "ShapePoint",
        "kind": 6,
        "importPath": "build.lib.word_manifold.manifold.semantic_shape",
        "description": "build.lib.word_manifold.manifold.semantic_shape",
        "peekOfCode": "class ShapePoint:\n    \"\"\"A point in the semantic shape with its associated properties.\"\"\"\n    position: np.ndarray\n    intensity: float  # Emotional/semantic intensity\n    direction: np.ndarray  # Flow direction\n    properties: Dict  # Additional shape properties\nclass SemanticShape:\n    \"\"\"\n    A class representing the shape of meaning in semantic space.\n    This captures both the geometric form and the dynamic properties",
        "detail": "build.lib.word_manifold.manifold.semantic_shape",
        "documentation": {}
    },
    {
        "label": "SemanticShape",
        "kind": 6,
        "importPath": "build.lib.word_manifold.manifold.semantic_shape",
        "description": "build.lib.word_manifold.manifold.semantic_shape",
        "peekOfCode": "class SemanticShape:\n    \"\"\"\n    A class representing the shape of meaning in semantic space.\n    This captures both the geometric form and the dynamic properties\n    of a semantic expression (phrase, sentence, or text chunk).\n    \"\"\"\n    def __init__(\n        self,\n        phrase_embedding: PhraseEmbedding,\n        n_control_points: int = 10",
        "detail": "build.lib.word_manifold.manifold.semantic_shape",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.manifold.semantic_shape",
        "description": "build.lib.word_manifold.manifold.semantic_shape",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass ShapePoint:\n    \"\"\"A point in the semantic shape with its associated properties.\"\"\"\n    position: np.ndarray\n    intensity: float  # Emotional/semantic intensity\n    direction: np.ndarray  # Flow direction\n    properties: Dict  # Additional shape properties\nclass SemanticShape:\n    \"\"\"",
        "detail": "build.lib.word_manifold.manifold.semantic_shape",
        "documentation": {}
    },
    {
        "label": "Cell",
        "kind": 6,
        "importPath": "build.lib.word_manifold.manifold.vector_manifold",
        "description": "build.lib.word_manifold.manifold.vector_manifold",
        "peekOfCode": "class Cell:\n    \"\"\"\n    A cell in the manifold representing a region in the vector space.\n    \"\"\"\n    id: int\n    terms: List[str]  # Words that belong to this cell\n    centroid: np.ndarray  # Center point of the cell in embedding space\n    type: CellType  # Type of cell with occult significance\n    numerological_value: int  # Numerological value of the cell\n    boundary_points: Optional[np.ndarray] = None  # Points defining the boundary (if available)",
        "detail": "build.lib.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "ManifoldReducedState",
        "kind": 6,
        "importPath": "build.lib.word_manifold.manifold.vector_manifold",
        "description": "build.lib.word_manifold.manifold.vector_manifold",
        "peekOfCode": "class ManifoldReducedState(NamedTuple):\n    \"\"\"State of the reduced manifold for visualization and cellular operations.\"\"\"\n    points: np.ndarray         # 2D or 3D points\n    labels: List[int]          # Cell labels for each point\n    cell_centroids: np.ndarray # Reduced centroids\n    boundaries: Any            # Boundary representations (e.g., Voronoi)\nclass VectorManifold:\n    \"\"\"\n    A class representing a manifold in vector space for word embeddings.\n    This class handles the geometric relationships between word embeddings,",
        "detail": "build.lib.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "kind": 6,
        "importPath": "build.lib.word_manifold.manifold.vector_manifold",
        "description": "build.lib.word_manifold.manifold.vector_manifold",
        "peekOfCode": "class VectorManifold:\n    \"\"\"\n    A class representing a manifold in vector space for word embeddings.\n    This class handles the geometric relationships between word embeddings,\n    including Voronoi tessellation and neighborhood calculations.\n    \"\"\"\n    def __init__(\n        self,\n        word_embeddings: WordEmbeddings,\n        n_cells: int = 22,  # Default to 22 cells (major arcana)",
        "detail": "build.lib.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.manifold.vector_manifold",
        "description": "build.lib.word_manifold.manifold.vector_manifold",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass Cell:\n    \"\"\"\n    A cell in the manifold representing a region in the vector space.\n    \"\"\"\n    id: int\n    terms: List[str]  # Words that belong to this cell\n    centroid: np.ndarray  # Center point of the cell in embedding space\n    type: CellType  # Type of cell with occult significance",
        "detail": "build.lib.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "AudioFeatures",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.audio_visualizer",
        "description": "build.lib.word_manifold.visualization.audio_visualizer",
        "peekOfCode": "class AudioFeatures:\n    \"\"\"Container for extracted audio features.\"\"\"\n    mfcc: np.ndarray\n    chroma: np.ndarray\n    spectral_contrast: np.ndarray\n    tonnetz: np.ndarray\n    onset_strength: np.ndarray\n    tempogram: np.ndarray\nclass AudioEncoder(nn.Module):\n    \"\"\"Neural network for encoding audio features into semantic space.\"\"\"",
        "detail": "build.lib.word_manifold.visualization.audio_visualizer",
        "documentation": {}
    },
    {
        "label": "AudioEncoder",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.audio_visualizer",
        "description": "build.lib.word_manifold.visualization.audio_visualizer",
        "peekOfCode": "class AudioEncoder(nn.Module):\n    \"\"\"Neural network for encoding audio features into semantic space.\"\"\"\n    def __init__(\n        self,\n        input_dim: int,\n        embedding_dim: int,\n        hidden_dim: int = 256,\n        n_layers: int = 3\n    ):\n        \"\"\"",
        "detail": "build.lib.word_manifold.visualization.audio_visualizer",
        "documentation": {}
    },
    {
        "label": "AudioVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.audio_visualizer",
        "description": "build.lib.word_manifold.visualization.audio_visualizer",
        "peekOfCode": "class AudioVisualizer:\n    \"\"\"Main class for audio visualization in semantic space.\"\"\"\n    def __init__(\n        self,\n        embedding_dim: int,\n        sample_rate: int = 22050,\n        hop_length: int = 512,\n        device: str = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n    ):\n        \"\"\"",
        "detail": "build.lib.word_manifold.visualization.audio_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.audio_visualizer",
        "description": "build.lib.word_manifold.visualization.audio_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass AudioFeatures:\n    \"\"\"Container for extracted audio features.\"\"\"\n    mfcc: np.ndarray\n    chroma: np.ndarray\n    spectral_contrast: np.ndarray\n    tonnetz: np.ndarray\n    onset_strength: np.ndarray\n    tempogram: np.ndarray",
        "detail": "build.lib.word_manifold.visualization.audio_visualizer",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 2,
        "importPath": "build.lib.word_manifold.visualization.cli",
        "description": "build.lib.word_manifold.visualization.cli",
        "peekOfCode": "def cli():\n    \"\"\"Word Manifold Visualization Tools\"\"\"\n    pass\n@cli.command()\n@click.option('--model', default='en_core_web_sm', help='Spacy model to use')\n@click.option('--terms', '-t', multiple=True, help='Terms to visualize')\n@click.option('--terms-file', type=click.Path(exists=True), help='File containing terms (one per line)')\n@click.option('--output-dir', default='visualizations', help='Output directory for visualizations')\n@click.option('--dimensions', default=4, help='Number of dimensions for visualization')\n@click.option('--interactive/--no-interactive', default=True, help='Enable/disable interactive mode')",
        "detail": "build.lib.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "visualize",
        "kind": 2,
        "importPath": "build.lib.word_manifold.visualization.cli",
        "description": "build.lib.word_manifold.visualization.cli",
        "peekOfCode": "def visualize(model: str, terms: List[str], terms_file: Optional[str], output_dir: str,\n             dimensions: int, interactive: bool, auto_rotate: bool, show_trails: bool,\n             show_force_field: bool, color_palette: str, save_format: str):\n    \"\"\"Create an interactive visualization of word vectors.\"\"\"\n    # Load terms from file if provided\n    if terms_file:\n        with open(terms_file) as f:\n            file_terms = [line.strip() for line in f if line.strip()]\n        terms = list(terms) + file_terms\n    if not terms:",
        "detail": "build.lib.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "animate_ritual",
        "kind": 2,
        "importPath": "build.lib.word_manifold.visualization.cli",
        "description": "build.lib.word_manifold.visualization.cli",
        "peekOfCode": "def animate_ritual(model: str, ritual_file: str, output_dir: str,\n                  duration: float, fps: int, add_trails: bool):\n    \"\"\"Create an animated visualization of a ritual sequence.\"\"\"\n    import json\n    # Load ritual sequence\n    with open(ritual_file) as f:\n        ritual_data = json.load(f)\n    # Initialize embeddings and manifold\n    embeddings = WordEmbeddings(model)\n    terms = set()",
        "detail": "build.lib.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "serve",
        "kind": 2,
        "importPath": "build.lib.word_manifold.visualization.cli",
        "description": "build.lib.word_manifold.visualization.cli",
        "peekOfCode": "def serve(host: str, port: int, debug: bool):\n    \"\"\"Start the visualization server.\"\"\"\n    from .server import VisualizationServer\n    server = VisualizationServer()\n    server.run(host=host, port=port, debug=debug)\nif __name__ == '__main__':\n    cli()",
        "detail": "build.lib.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.cli",
        "description": "build.lib.word_manifold.visualization.cli",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@click.group()\ndef cli():\n    \"\"\"Word Manifold Visualization Tools\"\"\"\n    pass\n@cli.command()\n@click.option('--model', default='en_core_web_sm', help='Spacy model to use')\n@click.option('--terms', '-t', multiple=True, help='Terms to visualize')\n@click.option('--terms-file', type=click.Path(exists=True), help='File containing terms (one per line)')\n@click.option('--output-dir', default='visualizations', help='Output directory for visualizations')",
        "detail": "build.lib.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "description": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "class HyperToolsVisualizer:\n    \"\"\"\n    Advanced high-dimensional visualization class using HyperTools.\n    This visualizer provides fluid, interactive visualizations of semantic\n    transformations in high-dimensional spaces, with advanced animation\n    capabilities for ritual evolution processes and 4D+ rotations.\n    \"\"\"\n    def __init__(\n        self,\n        output_dir: str = \"visualizations/hypertools\",",
        "detail": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "is_string_like",
        "kind": 2,
        "importPath": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "description": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "def is_string_like(obj):\n    \"\"\"Check if the object is a string-like object (str or bytes)\"\"\"\n    return isinstance(obj, (str, bytes))\n# Apply the patch to hypertools\ntry:\n    # Get the reduce function from hypertools.tools\n    if hasattr(hyp.tools, 'reduce'):\n        original_reduce = hyp.tools.reduce\n    else:\n        # If reduce isn't directly accessible, try to get it from the module",
        "detail": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "hypertools_path",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "description": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "hypertools_path = Path(__file__).parent.parent.parent.parent / 'hypertools'\nsys.path.insert(0, str(hypertools_path))\nimport hypertools as hyp\nimport warnings\nimport datetime\nfrom typing import List, Dict, Optional, Tuple, Union, Any\nimport logging\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.colors as mcolors\nfrom mpl_toolkits.mplot3d import Axes3D",
        "detail": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "description": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Monkey patch for NumPy 2.0 compatibility\ndef is_string_like(obj):\n    \"\"\"Check if the object is a string-like object (str or bytes)\"\"\"\n    return isinstance(obj, (str, bytes))\n# Apply the patch to hypertools\ntry:\n    # Get the reduce function from hypertools.tools\n    if hasattr(hyp.tools, 'reduce'):\n        original_reduce = hyp.tools.reduce",
        "detail": "build.lib.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "InteractiveVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.interactive_visualizer",
        "description": "build.lib.word_manifold.visualization.interactive_visualizer",
        "peekOfCode": "class InteractiveVisualizer:\n    \"\"\"\n    Interactive visualization class for exploring semantic spaces.\n    This class provides real-time visualization of word embeddings and\n    semantic transformations, with support for:\n    - Dynamic embedding projection\n    - Interactive exploration of semantic neighborhoods\n    - Real-time visualization of transformations\n    - Multiple visualization modes (2D/3D)\n    \"\"\"",
        "detail": "build.lib.word_manifold.visualization.interactive_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.interactive_visualizer",
        "description": "build.lib.word_manifold.visualization.interactive_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass InteractiveVisualizer:\n    \"\"\"\n    Interactive visualization class for exploring semantic spaces.\n    This class provides real-time visualization of word embeddings and\n    semantic transformations, with support for:\n    - Dynamic embedding projection\n    - Interactive exploration of semantic neighborhoods\n    - Real-time visualization of transformations\n    - Multiple visualization modes (2D/3D)",
        "detail": "build.lib.word_manifold.visualization.interactive_visualizer",
        "documentation": {}
    },
    {
        "label": "SemanticNeRF",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.nerf_renderer",
        "description": "build.lib.word_manifold.visualization.nerf_renderer",
        "peekOfCode": "class SemanticNeRF(nn.Module):\n    \"\"\"Neural network for semantic radiance fields.\"\"\"\n    def __init__(\n        self,\n        embedding_dim: int,\n        hidden_dim: int = 256,\n        n_layers: int = 8,\n        activation: nn.Module = nn.ReLU()\n    ):\n        \"\"\"",
        "detail": "build.lib.word_manifold.visualization.nerf_renderer",
        "documentation": {}
    },
    {
        "label": "PositionalEncoding",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.nerf_renderer",
        "description": "build.lib.word_manifold.visualization.nerf_renderer",
        "peekOfCode": "class PositionalEncoding(nn.Module):\n    \"\"\"Positional encoding for continuous input coordinates.\"\"\"\n    def __init__(self, input_dim: int, n_freqs: int = 10):\n        \"\"\"\n        Initialize positional encoding.\n        Args:\n            input_dim: Dimension of input coordinates\n            n_freqs: Number of frequency bands to use\n        \"\"\"\n        super().__init__()",
        "detail": "build.lib.word_manifold.visualization.nerf_renderer",
        "documentation": {}
    },
    {
        "label": "SemanticAttention",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.nerf_renderer",
        "description": "build.lib.word_manifold.visualization.nerf_renderer",
        "peekOfCode": "class SemanticAttention(nn.Module):\n    \"\"\"Attention mechanism for semantic feature refinement.\"\"\"\n    def __init__(self, embedding_dim: int, hidden_dim: int):\n        \"\"\"\n        Initialize semantic attention module.\n        Args:\n            embedding_dim: Dimension of semantic embeddings\n            hidden_dim: Size of hidden layer\n        \"\"\"\n        super().__init__()",
        "detail": "build.lib.word_manifold.visualization.nerf_renderer",
        "documentation": {}
    },
    {
        "label": "NeRFRenderer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.nerf_renderer",
        "description": "build.lib.word_manifold.visualization.nerf_renderer",
        "peekOfCode": "class NeRFRenderer:\n    \"\"\"Main renderer class for semantic NeRF visualization.\"\"\"\n    def __init__(\n        self,\n        embedding_dim: int,\n        device: str = \"cuda\" if torch.cuda.is_available() else \"cpu\",\n        **nerf_kwargs\n    ):\n        \"\"\"\n        Initialize the NeRF renderer.",
        "detail": "build.lib.word_manifold.visualization.nerf_renderer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.nerf_renderer",
        "description": "build.lib.word_manifold.visualization.nerf_renderer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass SemanticNeRF(nn.Module):\n    \"\"\"Neural network for semantic radiance fields.\"\"\"\n    def __init__(\n        self,\n        embedding_dim: int,\n        hidden_dim: int = 256,\n        n_layers: int = 8,\n        activation: nn.Module = nn.ReLU()\n    ):",
        "detail": "build.lib.word_manifold.visualization.nerf_renderer",
        "documentation": {}
    },
    {
        "label": "VisualizationServer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.server",
        "description": "build.lib.word_manifold.visualization.server",
        "peekOfCode": "class VisualizationServer:\n    \"\"\"Server for interactive visualization of word embeddings and semantic analysis.\"\"\"\n    def __init__(\n        self,\n        embeddings: np.ndarray,\n        labels: List[str],\n        host: str = \"localhost\",\n        port: int = 5000,\n        debug: bool = False\n    ):",
        "detail": "build.lib.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.server",
        "description": "build.lib.word_manifold.visualization.server",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass VisualizationServer:\n    \"\"\"Server for interactive visualization of word embeddings and semantic analysis.\"\"\"\n    def __init__(\n        self,\n        embeddings: np.ndarray,\n        labels: List[str],\n        host: str = \"localhost\",\n        port: int = 5000,\n        debug: bool = False",
        "detail": "build.lib.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "ExportConfig",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.shape_visualizer",
        "description": "build.lib.word_manifold.visualization.shape_visualizer",
        "peekOfCode": "class ExportConfig:\n    \"\"\"Configuration for exporting visualizations.\"\"\"\n    def __init__(\n        self,\n        format: str = \"mp4\",\n        dpi: int = 300,\n        fps: int = 60,\n        bitrate: int = 2000,\n        save_frames: bool = True,\n        output_dir: Optional[str] = None",
        "detail": "build.lib.word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "ShapeVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.shape_visualizer",
        "description": "build.lib.word_manifold.visualization.shape_visualizer",
        "peekOfCode": "class ShapeVisualizer:\n    \"\"\"\n    Advanced visualization class for semantic shapes with enhanced visual encoding.\n    \"\"\"\n    def __init__(\n        self,\n        color_scheme: str = \"semantic\",\n        use_textures: bool = True,\n        export_config: Optional[ExportConfig] = None\n    ):",
        "detail": "build.lib.word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.shape_visualizer",
        "description": "build.lib.word_manifold.visualization.shape_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)  # Default to INFO level\n# Create formatters and handlers if they don't exist\nif not logger.handlers:\n    # Create console handler with formatting\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    console_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - [%(levelname)s] - %(message)s'\n    )",
        "detail": "build.lib.word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "Simple3DVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.simple_3d_visualizer",
        "description": "build.lib.word_manifold.visualization.simple_3d_visualizer",
        "peekOfCode": "class Simple3DVisualizer:\n    \"\"\"\n    Basic 3D visualization class as an alternative to HyperTools.\n    This visualizer provides 3D visualizations using matplotlib\n    to avoid compatibility issues with HyperTools and NumPy 2.0.\n    \"\"\"\n    def __init__(\n        self,\n        output_dir: str = \"visualizations/3d\",\n        color_palette: str = \"viridis\",",
        "detail": "build.lib.word_manifold.visualization.simple_3d_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.simple_3d_visualizer",
        "description": "build.lib.word_manifold.visualization.simple_3d_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass Simple3DVisualizer:\n    \"\"\"\n    Basic 3D visualization class as an alternative to HyperTools.\n    This visualizer provides 3D visualizations using matplotlib\n    to avoid compatibility issues with HyperTools and NumPy 2.0.\n    \"\"\"\n    def __init__(\n        self,\n        output_dir: str = \"visualizations/3d\",",
        "detail": "build.lib.word_manifold.visualization.simple_3d_visualizer",
        "documentation": {}
    },
    {
        "label": "ManifoldVisualizer",
        "kind": 6,
        "importPath": "build.lib.word_manifold.visualization.visualizer",
        "description": "build.lib.word_manifold.visualization.visualizer",
        "peekOfCode": "class ManifoldVisualizer:\n    \"\"\"\n    Advanced visualization class for exploring word manifolds.\n    Features:\n    - Interactive 3D visualization with plotly\n    - Dynamic term relationships\n    - Sonic feedback for term distances\n    - Color encoding of semantic properties\n    - Animated transitions\n    - Multi-scale visualization",
        "detail": "build.lib.word_manifold.visualization.visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "build.lib.word_manifold.visualization.visualizer",
        "description": "build.lib.word_manifold.visualization.visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ManifoldVisualizer:\n    \"\"\"\n    Advanced visualization class for exploring word manifolds.\n    Features:\n    - Interactive 3D visualization with plotly\n    - Dynamic term relationships\n    - Sonic feedback for term distances\n    - Color encoding of semantic properties\n    - Animated transitions",
        "detail": "build.lib.word_manifold.visualization.visualizer",
        "documentation": {}
    },
    {
        "label": "CellType",
        "kind": 6,
        "importPath": "build.lib.word_manifold.types",
        "description": "build.lib.word_manifold.types",
        "peekOfCode": "class CellType(Enum):\n    \"\"\"Types of cells with occult correspondences.\"\"\"\n    ELEMENTAL = auto()   # Corresponds to the four elements\n    PLANETARY = auto()   # Corresponds to planetary influences\n    ZODIACAL = auto()    # Corresponds to zodiac signs\n    TAROT = auto()       # Corresponds to tarot archetypes\n    SEPHIROTIC = auto()  # Corresponds to Kabbalistic sephiroth\n    OTHER = auto()       # Default/unclassified\nclass DistanceType(Enum):\n    \"\"\"Types of distance metrics for cell relationships.\"\"\"",
        "detail": "build.lib.word_manifold.types",
        "documentation": {}
    },
    {
        "label": "DistanceType",
        "kind": 6,
        "importPath": "build.lib.word_manifold.types",
        "description": "build.lib.word_manifold.types",
        "peekOfCode": "class DistanceType(Enum):\n    \"\"\"Types of distance metrics for cell relationships.\"\"\"\n    EUCLIDEAN = auto()      # Standard Euclidean distance\n    COSINE = auto()         # Cosine distance (semantic similarity)\n    NUMEROLOGICAL = auto()  # Distance weighted by numerological values\n    HYBRID = auto()         # Combination of semantic and numerological",
        "detail": "build.lib.word_manifold.types",
        "documentation": {}
    },
    {
        "label": "setup_system",
        "kind": 2,
        "importPath": "examples.automata.evolution_demo",
        "description": "examples.automata.evolution_demo",
        "peekOfCode": "def setup_system():\n    \"\"\"Set up the automata system with initial terms and rules.\"\"\"\n    # Initialize embeddings with occult terms\n    embeddings = WordEmbeddings()\n    terms = {\n        \"thelema\", \"will\", \"love\", \"magick\", \"ritual\",\n        \"knowledge\", \"wisdom\", \"power\", \"light\", \"dark\",\n        \"earth\", \"air\", \"fire\", \"water\", \"spirit\",\n        \"sun\", \"moon\", \"mercury\", \"venus\", \"mars\"\n    }",
        "detail": "examples.automata.evolution_demo",
        "documentation": {}
    },
    {
        "label": "demonstrate_evolution",
        "kind": 2,
        "importPath": "examples.automata.evolution_demo",
        "description": "examples.automata.evolution_demo",
        "peekOfCode": "def demonstrate_evolution(system: AutomataSystem):\n    \"\"\"Demonstrate different evolution patterns.\"\"\"\n    # Individual rule evolution\n    logger.info(\"\\nApplying individual rules:\")\n    for rule_name in [\"great_work\", \"equilibrium\", \"tower\"]:\n        rule = system.rules[rule_name]\n        logger.info(\"Applying rule: %s\" % rule.name)\n        logger.info(\"Description: %s\" % rule.description)\n        rule.apply(system.manifold, system.generation)\n        state = system.manifold.get_manifold_state()",
        "detail": "examples.automata.evolution_demo",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.automata.evolution_demo",
        "description": "examples.automata.evolution_demo",
        "peekOfCode": "def main():\n    # Set up system\n    system = setup_system()\n    logger.info(\"Initialized automata system\")\n    # Demonstrate evolution\n    demonstrate_evolution(system)\n    logger.info(\"\\nEvolution demonstration complete\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "examples.automata.evolution_demo",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.automata.evolution_demo",
        "description": "examples.automata.evolution_demo",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef setup_system():\n    \"\"\"Set up the automata system with initial terms and rules.\"\"\"\n    # Initialize embeddings with occult terms\n    embeddings = WordEmbeddings()\n    terms = {\n        \"thelema\", \"will\", \"love\", \"magick\", \"ritual\",\n        \"knowledge\", \"wisdom\", \"power\", \"light\", \"dark\",\n        \"earth\", \"air\", \"fire\", \"water\", \"spirit\",\n        \"sun\", \"moon\", \"mercury\", \"venus\", \"mars\"",
        "detail": "examples.automata.evolution_demo",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.embeddings.word_embeddings_demo",
        "description": "examples.embeddings.word_embeddings_demo",
        "peekOfCode": "def main():\n    # Initialize embeddings\n    embeddings = WordEmbeddings()\n    logger.info(\"Initialized word embeddings model\")\n    # Load standard occult terms\n    embeddings.load_terms(OCCULT_TERMS)\n    logger.info(f\"Loaded {len(OCCULT_TERMS)} occult terms\")\n    # Demonstrate similarity search\n    query_terms = [\"magic\", \"thelema\", \"ritual\"]\n    k = 5  # Number of similar terms to find",
        "detail": "examples.embeddings.word_embeddings_demo",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.embeddings.word_embeddings_demo",
        "description": "examples.embeddings.word_embeddings_demo",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef main():\n    # Initialize embeddings\n    embeddings = WordEmbeddings()\n    logger.info(\"Initialized word embeddings model\")\n    # Load standard occult terms\n    embeddings.load_terms(OCCULT_TERMS)\n    logger.info(f\"Loaded {len(OCCULT_TERMS)} occult terms\")\n    # Demonstrate similarity search\n    query_terms = [\"magic\", \"thelema\", \"ritual\"]",
        "detail": "examples.embeddings.word_embeddings_demo",
        "documentation": {}
    },
    {
        "label": "n_points",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "n_points = 1000\nX, color = datasets.make_swiss_roll(n_points, random_state=0)\nn_neighbors = 10\nn_components = 2\n# Creating the plot\nfig = plt.figure(figsize=(15, 8))\nfig.suptitle(\"Manifold Learning with %i points, %i neighbors\"\n             % (1000, n_neighbors), fontsize=14)\n# Adding 3d scatter plot\nax = fig.add_subplot(231, projection='3d')",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "n_neighbors",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "n_neighbors = 10\nn_components = 2\n# Creating the plot\nfig = plt.figure(figsize=(15, 8))\nfig.suptitle(\"Manifold Learning with %i points, %i neighbors\"\n             % (1000, n_neighbors), fontsize=14)\n# Adding 3d scatter plot\nax = fig.add_subplot(231, projection='3d')\nax.scatter(X[:, 0], X[:, 1], X[:, 2], c=color, cmap=plt.cm.Spectral)\nax.view_init(4, -72)",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "n_components",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "n_components = 2\n# Creating the plot\nfig = plt.figure(figsize=(15, 8))\nfig.suptitle(\"Manifold Learning with %i points, %i neighbors\"\n             % (1000, n_neighbors), fontsize=14)\n# Adding 3d scatter plot\nax = fig.add_subplot(231, projection='3d')\nax.scatter(X[:, 0], X[:, 1], X[:, 2], c=color, cmap=plt.cm.Spectral)\nax.view_init(4, -72)\n# Making a dictionary 'methods' containing LLE, t-SNE and PCA",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "fig",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "fig = plt.figure(figsize=(15, 8))\nfig.suptitle(\"Manifold Learning with %i points, %i neighbors\"\n             % (1000, n_neighbors), fontsize=14)\n# Adding 3d scatter plot\nax = fig.add_subplot(231, projection='3d')\nax.scatter(X[:, 0], X[:, 1], X[:, 2], c=color, cmap=plt.cm.Spectral)\nax.view_init(4, -72)\n# Making a dictionary 'methods' containing LLE, t-SNE and PCA\nLLE = partial(manifold.LocallyLinearEmbedding,\n              n_neighbors, n_components, eigen_solver='auto')",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "ax",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "ax = fig.add_subplot(231, projection='3d')\nax.scatter(X[:, 0], X[:, 1], X[:, 2], c=color, cmap=plt.cm.Spectral)\nax.view_init(4, -72)\n# Making a dictionary 'methods' containing LLE, t-SNE and PCA\nLLE = partial(manifold.LocallyLinearEmbedding,\n              n_neighbors, n_components, eigen_solver='auto')\nmethods = OrderedDict()\nmethods['LLE'] = LLE(method='standard')\nmethods['t-SNE'] = manifold.TSNE(n_components=n_components, init='pca',\n                                 random_state=0)",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "LLE",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "LLE = partial(manifold.LocallyLinearEmbedding,\n              n_neighbors, n_components, eigen_solver='auto')\nmethods = OrderedDict()\nmethods['LLE'] = LLE(method='standard')\nmethods['t-SNE'] = manifold.TSNE(n_components=n_components, init='pca',\n                                 random_state=0)\nmethods['PCA']=PCA(n_components=2)\n# Plotting the results\nfor i, (label, method) in enumerate(methods.items()):\n    t0 = time()",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "methods",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "methods = OrderedDict()\nmethods['LLE'] = LLE(method='standard')\nmethods['t-SNE'] = manifold.TSNE(n_components=n_components, init='pca',\n                                 random_state=0)\nmethods['PCA']=PCA(n_components=2)\n# Plotting the results\nfor i, (label, method) in enumerate(methods.items()):\n    t0 = time()\n    Y = method.fit_transform(X)\n    t1 = time()",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "methods['LLE']",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "methods['LLE'] = LLE(method='standard')\nmethods['t-SNE'] = manifold.TSNE(n_components=n_components, init='pca',\n                                 random_state=0)\nmethods['PCA']=PCA(n_components=2)\n# Plotting the results\nfor i, (label, method) in enumerate(methods.items()):\n    t0 = time()\n    Y = method.fit_transform(X)\n    t1 = time()\n    print(\"%s: %.2g sec\" % (label, t1 - t0))",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "methods['t-SNE']",
        "kind": 5,
        "importPath": "examples.manifold.manifold_learning",
        "description": "examples.manifold.manifold_learning",
        "peekOfCode": "methods['t-SNE'] = manifold.TSNE(n_components=n_components, init='pca',\n                                 random_state=0)\nmethods['PCA']=PCA(n_components=2)\n# Plotting the results\nfor i, (label, method) in enumerate(methods.items()):\n    t0 = time()\n    Y = method.fit_transform(X)\n    t1 = time()\n    print(\"%s: %.2g sec\" % (label, t1 - t0))\n    ax = fig.add_subplot(2, 3, 2 + i+(i>1))",
        "detail": "examples.manifold.manifold_learning",
        "documentation": {}
    },
    {
        "label": "MultimodalVisualizer",
        "kind": 6,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "class MultimodalVisualizer:\n    \"\"\"Class for handling multimodal visualization with text and images.\"\"\"\n    def __init__(self, image_size=128):  # Reduced from 512 to 128 for memory efficiency\n        \"\"\"Initialize the multimodal visualizer with CLIP model.\"\"\"\n        self.image_size = image_size\n        self.device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n        # Load CLIP with memory optimization\n        logger.info(\"Loading CLIP model...\")\n        self.clip_model = CLIPModel.from_pretrained(\n            \"openai/clip-vit-base-patch32\",",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "InteractiveVisualizer",
        "kind": 6,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "class InteractiveVisualizer:\n    \"\"\"Class for handling interactive visualization controls.\"\"\"\n    def __init__(self, manifold, visualizer):\n        self.manifold = manifold\n        self.visualizer = visualizer\n        self.current_level = 0\n        self.fig = None\n        self.animation = None\n        # Create interactive controls\n        self.setup_controls()",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "find_level_data",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def find_level_data(result: Dict[str, Any], target_level: int, current_level: int = 0) -> Optional[Dict[str, Any]]:\n    \"\"\"Find data for a specific level in the recursive reduction results.\"\"\"\n    if current_level == target_level:\n        return result\n    for child in result['children']:\n        found = find_level_data(child, target_level, current_level + 1)\n        if found is not None:\n            return found\n    return None\nclass MultimodalVisualizer:",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "load_embeddings",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def load_embeddings(model_name=\"sentence-transformers/all-MiniLM-L6-v2\"):\n    \"\"\"Load pre-trained embeddings and extract meaningful term clusters.\"\"\"\n    logger.info(f\"Loading model: {model_name}\")\n    # Initialize word embeddings with background processing\n    word_embeddings = WordEmbeddings(model_name=model_name)\n    # Define semantic clusters with rich vocabulary\n    term_clusters = {\n        \"elements\": [\n            \"fire\", \"water\", \"earth\", \"air\", \"aether\", \"void\", \"plasma\",\n            \"crystal\", \"metal\", \"wood\", \"stone\", \"lightning\", \"ice\", \"steam\"",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "plot_coherence_heatmap",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def plot_coherence_heatmap(manifold):\n    \"\"\"Plot coherence heatmap across reduction levels.\"\"\"\n    def extract_coherence(result, depth=0, coherence_matrix=None, max_depth=None):\n        if coherence_matrix is None:\n            # Find max depth first\n            def get_max_depth(r, d=0):\n                if not r['children']:\n                    return d\n                return max(get_max_depth(child, d+1) for child in r['children'])\n            max_depth = get_max_depth(result)",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "plot_term_clusters",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def plot_term_clusters(manifold, level=0, show_labels=True):\n    \"\"\"Create a 3D scatter plot colored by semantic clusters.\"\"\"\n    if not hasattr(manifold, 'recursive_reduced'):\n        raise ValueError(\"Must run recursive_reduce() first\")\n    # Get the points for the specified level\n    level_data = find_level_data(manifold.recursive_reduced, level)\n    if level_data is None:\n        raise ValueError(f\"Level {level} not found\")\n    points = level_data['points']\n    # Create category mapping",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "plot_multimodal_clusters",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def plot_multimodal_clusters(manifold, level=0, visualizer: Optional[MultimodalVisualizer] = None, show_labels=True):\n    \"\"\"Create a multimodal visualization combining semantic and visual embeddings.\"\"\"\n    if not hasattr(manifold, 'recursive_reduced'):\n        raise ValueError(\"Must run recursive_reduce() first\")\n    # Get level data\n    level_data = find_level_data(manifold.recursive_reduced, level)\n    if level_data is None:\n        raise ValueError(f\"Level {level} not found\")\n    points = level_data['points']\n    # Group terms by category",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "create_source_cube",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def create_source_cube(manifold: VectorManifold, n_terms: int = 8) -> Dict[str, Any]:\n    \"\"\"\n    Create a semantic source cube visualization.\n    Args:\n        manifold: The VectorManifold instance\n        n_terms: Number of terms to place at cube vertices (default 8)\n    Returns:\n        Dictionary containing cube visualization data\n    \"\"\"\n    # Get the most semantically diverse terms",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "plot_source_cube",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def plot_source_cube(cube_data: Dict[str, Any], ax: Optional[plt.Axes] = None) -> plt.Axes:\n    \"\"\"\n    Plot the semantic source cube.\n    Args:\n        cube_data: Cube visualization data from create_source_cube\n        ax: Optional matplotlib axes to plot on\n    Returns:\n        The matplotlib axes object\n    \"\"\"\n    if ax is None:",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "def main():\n    # Load pre-trained embeddings\n    embeddings = load_embeddings()\n    # Create manifold with reduced dimensionality for visualization\n    manifold = VectorManifold(\n        embeddings=embeddings,\n        n_cells=22,  # Default to 22 cells (major arcana)\n        random_state=93,\n        reduction_dims=3,  # Use 3D for better visualization\n        use_fractals=True,",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.manifold.recursive_reduction_example",
        "description": "examples.manifold.recursive_reduction_example",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef find_level_data(result: Dict[str, Any], target_level: int, current_level: int = 0) -> Optional[Dict[str, Any]]:\n    \"\"\"Find data for a specific level in the recursive reduction results.\"\"\"\n    if current_level == target_level:\n        return result\n    for child in result['children']:\n        found = find_level_data(child, target_level, current_level + 1)\n        if found is not None:\n            return found\n    return None",
        "detail": "examples.manifold.recursive_reduction_example",
        "documentation": {}
    },
    {
        "label": "VisualizationResult",
        "kind": 6,
        "importPath": "examples.visualization.example_visualizations",
        "description": "examples.visualization.example_visualizations",
        "peekOfCode": "class VisualizationResult:\n    \"\"\"Track the success and outputs of visualization operations.\"\"\"\n    def __init__(self):\n        self.ritual_evolution_success = False\n        self.shape_field_success = False\n        self.comparative_success = False\n        self.symbolic_success = False\n        self.saved_files: List[str] = []\n    def add_saved_file(self, filepath: str):\n        \"\"\"Record a successfully saved visualization file.\"\"\"",
        "detail": "examples.visualization.example_visualizations",
        "documentation": {}
    },
    {
        "label": "ritual_evolution_example",
        "kind": 2,
        "importPath": "examples.visualization.example_visualizations",
        "description": "examples.visualization.example_visualizations",
        "peekOfCode": "def ritual_evolution_example(result: VisualizationResult):\n    \"\"\"Demonstrate ritual evolution visualization.\"\"\"\n    try:\n        # Initialize embeddings and manifold\n        embeddings = WordEmbeddings()\n        # Define ritual terms\n        terms = [\n            \"light\", \"darkness\", \"wisdom\", \"understanding\",\n            \"beauty\", \"strength\", \"mercy\", \"severity\"\n        ]",
        "detail": "examples.visualization.example_visualizations",
        "documentation": {}
    },
    {
        "label": "semantic_shape_example",
        "kind": 2,
        "importPath": "examples.visualization.example_visualizations",
        "description": "examples.visualization.example_visualizations",
        "peekOfCode": "def semantic_shape_example(result: VisualizationResult):\n    \"\"\"Demonstrate semantic shape visualization.\"\"\"\n    try:\n        # Initialize visualizer with explicit output directory\n        visualizer = ShapeVisualizer(\n            export_config=ExportConfig(\n                output_dir=\"visualizations/shapes\",\n                format=\"mp4\",\n                save_frames=True\n            )",
        "detail": "examples.visualization.example_visualizations",
        "documentation": {}
    },
    {
        "label": "symbolic_visualization_example",
        "kind": 2,
        "importPath": "examples.visualization.example_visualizations",
        "description": "examples.visualization.example_visualizations",
        "peekOfCode": "def symbolic_visualization_example(result: VisualizationResult):\n    \"\"\"Demonstrate symbolic ASCII visualization.\"\"\"\n    try:\n        # Initialize embeddings and visualizer\n        embeddings = WordEmbeddings()\n        visualizer = SymbolicVisualizer(\n            word_embeddings=embeddings,\n            width=100,  # Wider field for better patterns\n            height=50   # Taller field for better patterns\n        )",
        "detail": "examples.visualization.example_visualizations",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.visualization.example_visualizations",
        "description": "examples.visualization.example_visualizations",
        "peekOfCode": "def main():\n    \"\"\"Run all visualization examples.\"\"\"\n    result = VisualizationResult()\n    print(\"Creating ritual evolution visualization...\")\n    ritual_evolution_example(result)\n    print(\"\\nCreating semantic shape visualization...\")\n    semantic_shape_example(result)\n    print(\"\\nCreating symbolic ASCII visualization...\")\n    symbolic_visualization_example(result)\n    print(result.get_summary())",
        "detail": "examples.visualization.example_visualizations",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.visualization.example_visualizations",
        "description": "examples.visualization.example_visualizations",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass VisualizationResult:\n    \"\"\"Track the success and outputs of visualization operations.\"\"\"\n    def __init__(self):\n        self.ritual_evolution_success = False\n        self.shape_field_success = False\n        self.comparative_success = False\n        self.symbolic_success = False\n        self.saved_files: List[str] = []\n    def add_saved_file(self, filepath: str):",
        "detail": "examples.visualization.example_visualizations",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.visualization.semantic_tree_example",
        "description": "examples.visualization.semantic_tree_example",
        "peekOfCode": "def main():\n    # Initialize visualizer\n    visualizer = SemanticTreeVisualizer(\n        output_dir=\"visualizations/semantic_trees\",\n        node_size_base=800,\n        min_similarity=0.3\n    )\n    # Example 1: Simple concept hierarchy\n    root = \"consciousness\"\n    related_terms = set([",
        "detail": "examples.visualization.semantic_tree_example",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.visualization.shape_visualization",
        "description": "examples.visualization.shape_visualization",
        "peekOfCode": "def main():\n    \"\"\"Run semantic shape visualization examples.\"\"\"\n    # Create visualizer\n    visualizer = ShapeVisualizer()\n    # Example 1: Visualize evolution of a poetic text\n    print(\"Creating visualization of poetic evolution...\")\n    poetic_text = \"\"\"\n    The stars move still, time runs, the clock will strike,\n    The devil will come, and Faustus must be damned.\n    O, I'll leap up to my God! Who pulls me down?",
        "detail": "examples.visualization.shape_visualization",
        "documentation": {}
    },
    {
        "label": "os.environ[\"TOKENIZERS_PARALLELISM\"]",
        "kind": 5,
        "importPath": "examples.visualization.shape_visualization",
        "description": "examples.visualization.shape_visualization",
        "peekOfCode": "os.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"\ndef main():\n    \"\"\"Run semantic shape visualization examples.\"\"\"\n    # Create visualizer\n    visualizer = ShapeVisualizer()\n    # Example 1: Visualize evolution of a poetic text\n    print(\"Creating visualization of poetic evolution...\")\n    poetic_text = \"\"\"\n    The stars move still, time runs, the clock will strike,\n    The devil will come, and Faustus must be damned.",
        "detail": "examples.visualization.shape_visualization",
        "documentation": {}
    },
    {
        "label": "EmbeddingRequest",
        "kind": 6,
        "importPath": "src.word_manifold.api.models.embeddings",
        "description": "src.word_manifold.api.models.embeddings",
        "peekOfCode": "class EmbeddingRequest(BaseModel):\n    \"\"\"Request model for text embedding.\"\"\"\n    text: constr(min_length=1) = Field(..., description=\"Text to embed\")\n    model_name: Optional[str] = Field(\n        \"sentence-transformers/all-MiniLM-L6-v2\",\n        description=\"Name of the model to use for embedding\"\n    )\n    normalize: bool = Field(True, description=\"Whether to L2-normalize the embeddings\")\n    instruction: Optional[str] = Field(None, description=\"Optional instruction for embedding\")\nclass BatchEmbeddingRequest(BaseModel):",
        "detail": "src.word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "BatchEmbeddingRequest",
        "kind": 6,
        "importPath": "src.word_manifold.api.models.embeddings",
        "description": "src.word_manifold.api.models.embeddings",
        "peekOfCode": "class BatchEmbeddingRequest(BaseModel):\n    \"\"\"Request model for batch text embedding.\"\"\"\n    texts: List[constr(min_length=1)] = Field(..., description=\"List of texts to embed\")\n    model_name: Optional[str] = Field(\n        \"sentence-transformers/all-MiniLM-L6-v2\",\n        description=\"Name of the model to use for embedding\"\n    )\n    normalize: bool = Field(True, description=\"Whether to L2-normalize the embeddings\")\n    instruction: Optional[str] = Field(None, description=\"Optional instruction for embedding\")\n    batch_size: Optional[int] = Field(32, description=\"Batch size for processing\")",
        "detail": "src.word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "EmbeddingResponse",
        "kind": 6,
        "importPath": "src.word_manifold.api.models.embeddings",
        "description": "src.word_manifold.api.models.embeddings",
        "peekOfCode": "class EmbeddingResponse(BaseModel):\n    \"\"\"Response model for text embedding.\"\"\"\n    embedding: List[float] = Field(..., description=\"Embedding vector\")\n    model_name: str = Field(..., description=\"Model used for embedding\")\n    dimensions: int = Field(..., description=\"Dimensionality of embedding\")\n    metadata: Optional[Dict[str, Any]] = Field(None, description=\"Additional metadata\")\n    class Config:\n        json_encoders = {\n            np.ndarray: lambda x: x.tolist(),\n            np.float32: float,",
        "detail": "src.word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "BatchEmbeddingResponse",
        "kind": 6,
        "importPath": "src.word_manifold.api.models.embeddings",
        "description": "src.word_manifold.api.models.embeddings",
        "peekOfCode": "class BatchEmbeddingResponse(BaseModel):\n    \"\"\"Response model for batch text embedding.\"\"\"\n    embeddings: List[List[float]] = Field(..., description=\"List of embedding vectors\")\n    model_name: str = Field(..., description=\"Model used for embedding\")\n    dimensions: int = Field(..., description=\"Dimensionality of embeddings\")\n    metadata: Optional[Dict[str, Any]] = Field(None, description=\"Additional metadata\")\n    class Config:\n        json_encoders = {\n            np.ndarray: lambda x: x.tolist(),\n            np.float32: float,",
        "detail": "src.word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "SimilarityRequest",
        "kind": 6,
        "importPath": "src.word_manifold.api.models.embeddings",
        "description": "src.word_manifold.api.models.embeddings",
        "peekOfCode": "class SimilarityRequest(BaseModel):\n    \"\"\"Request model for computing text similarity.\"\"\"\n    text1: constr(min_length=1) = Field(..., description=\"First text\")\n    text2: constr(min_length=1) = Field(..., description=\"Second text\")\n    model_name: Optional[str] = Field(\n        \"sentence-transformers/all-MiniLM-L6-v2\",\n        description=\"Name of the model to use\"\n    )\n    metric: str = Field(\"cosine\", description=\"Similarity metric to use\")\nclass SimilarityResponse(BaseModel):",
        "detail": "src.word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "SimilarityResponse",
        "kind": 6,
        "importPath": "src.word_manifold.api.models.embeddings",
        "description": "src.word_manifold.api.models.embeddings",
        "peekOfCode": "class SimilarityResponse(BaseModel):\n    \"\"\"Response model for text similarity.\"\"\"\n    similarity: float = Field(..., description=\"Similarity score\")\n    model_name: str = Field(..., description=\"Model used for comparison\")\n    metric: str = Field(..., description=\"Similarity metric used\")\n    metadata: Optional[Dict[str, Any]] = Field(None, description=\"Additional metadata\")",
        "detail": "src.word_manifold.api.models.embeddings",
        "documentation": {}
    },
    {
        "label": "get_provider",
        "kind": 2,
        "importPath": "src.word_manifold.api.routes.embeddings",
        "description": "src.word_manifold.api.routes.embeddings",
        "peekOfCode": "def get_provider(\n    model_name: str,\n    instruction: Optional[str] = None\n) -> TransformerEmbeddingProvider:\n    \"\"\"Get or create an embedding provider for the specified model.\"\"\"\n    if model_name not in _provider_cache:\n        device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n        if instruction is not None:\n            provider = InstructEmbeddingProvider(\n                model_name=model_name,",
        "detail": "src.word_manifold.api.routes.embeddings",
        "documentation": {}
    },
    {
        "label": "router",
        "kind": 5,
        "importPath": "src.word_manifold.api.routes.embeddings",
        "description": "src.word_manifold.api.routes.embeddings",
        "peekOfCode": "router = APIRouter(prefix=\"/embeddings\", tags=[\"embeddings\"])\n# Cache for embedding providers to avoid recreating them\n_provider_cache: Dict[str, TransformerEmbeddingProvider] = {}\ndef get_provider(\n    model_name: str,\n    instruction: Optional[str] = None\n) -> TransformerEmbeddingProvider:\n    \"\"\"Get or create an embedding provider for the specified model.\"\"\"\n    if model_name not in _provider_cache:\n        device = \"cuda\" if torch.cuda.is_available() else \"cpu\"",
        "detail": "src.word_manifold.api.routes.embeddings",
        "documentation": {}
    },
    {
        "label": "create_celestial_rules",
        "kind": 2,
        "importPath": "src.word_manifold.automata.additional_rules",
        "description": "src.word_manifold.automata.additional_rules",
        "peekOfCode": "def create_celestial_rules() -> Dict[str, CellularRule]:\n    \"\"\"\n    Create rules based on celestial bodies and higher spiritual archetypes.\n    These rules complement the base rule set by adding transformations\n    related to cosmic forces and stellar/planetary influences.\n    Returns:\n        Dictionary mapping rule names to CellularRule objects\n    \"\"\"\n    rules = {}",
        "detail": "src.word_manifold.automata.additional_rules",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.automata.additional_rules",
        "description": "src.word_manifold.automata.additional_rules",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef create_celestial_rules() -> Dict[str, CellularRule]:\n    \"\"\"\n    Create rules based on celestial bodies and higher spiritual archetypes.\n    These rules complement the base rule set by adding transformations\n    related to cosmic forces and stellar/planetary influences.\n    Returns:\n        Dictionary mapping rule names to CellularRule objects\n    \"\"\"\n    rules = {}",
        "detail": "src.word_manifold.automata.additional_rules",
        "documentation": {}
    },
    {
        "label": "HermeticPrinciple",
        "kind": 6,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "class HermeticPrinciple(Enum):\n    \"\"\"The seven Hermetic principles that govern transformation rules.\"\"\"\n    MENTALISM = auto()         # \"THE ALL is MIND; The Universe is Mental.\"\n    CORRESPONDENCE = auto()    # \"As above, so below; as below, so above.\"\n    VIBRATION = auto()         # \"Nothing rests; everything moves; everything vibrates.\"\n    POLARITY = auto()          # \"Everything is Dual; everything has poles.\"\n    RHYTHM = auto()            # \"Everything flows, out and in; everything has its tides.\"\n    CAUSE_EFFECT = auto()      # \"Every Cause has its Effect; Every Effect has its Cause.\"\n    GENDER = auto()            # \"Gender is in everything; everything has its Masculine and Feminine.\"\nclass ElementalForce(Enum):",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "ElementalForce",
        "kind": 6,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "class ElementalForce(Enum):\n    \"\"\"The four elemental forces that influence transformation.\"\"\"\n    EARTH = auto()  # Stability, materiality, resistance to change\n    AIR = auto()    # Intellect, communication, adaptability\n    FIRE = auto()   # Energy, transformation, creation/destruction\n    WATER = auto()  # Emotion, intuition, connection\nclass VibrationDirection(Enum):\n    \"\"\"Possible directions of vibrational change in the vector space.\"\"\"\n    ASCENDING = auto()  # Moving towards higher vibration (complexity, abstraction)\n    DESCENDING = auto() # Moving towards lower vibration (simplicity, concreteness)",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "VibrationDirection",
        "kind": 6,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "class VibrationDirection(Enum):\n    \"\"\"Possible directions of vibrational change in the vector space.\"\"\"\n    ASCENDING = auto()  # Moving towards higher vibration (complexity, abstraction)\n    DESCENDING = auto() # Moving towards lower vibration (simplicity, concreteness)\n    EXPANDING = auto()  # Increasing in scope or influence\n    CONTRACTING = auto() # Decreasing in scope or influence\n    HARMONIZING = auto() # Moving towards balance with neighbors\n    POLARIZING = auto()  # Moving away from neighbors, increasing distinction\n@dataclass\nclass RuleParameterSet:",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleParameterSet",
        "kind": 6,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "class RuleParameterSet:\n    \"\"\"Parameters that define how a transformation rule behaves.\"\"\"\n    magnitude: float = 1.0                  # Base strength of transformation\n    principle: HermeticPrinciple = HermeticPrinciple.CORRESPONDENCE\n    elemental_influence: Dict[ElementalForce, float] = None  # Influence of each element\n    numerological_weights: Dict[int, float] = None  # Weights by numerological value\n    cell_type_weights: Dict[CellType, float] = None  # Weights by cell type\n    vibration_direction: VibrationDirection = VibrationDirection.HARMONIZING\n    def __init__(self, magnitude=1.0, principle=None, vibration_direction=None,\n                 numerological_weights=None, elemental_influence=None, cell_type_weights=None):",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "CellularRule",
        "kind": 6,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "class CellularRule:\n    \"\"\"\n    A rule that defines how cells transform in the vector space.\n    Each rule embodies one or more hermetic principles and governs \n    the evolution of the cellular automata system.\n    \"\"\"\n    def __init__(\n        self, \n        name: str, \n        description: str,",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "RuleSequence",
        "kind": 6,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "class RuleSequence:\n    \"\"\"\n    A sequence of cellular automata rules to be applied in a specific order.\n    The sequence can be applied in different ways:\n    - Sequentially (default): Rules are applied in order\n    - Conditionally: Rules are applied based on conditions\n    - With branching: Different paths can be taken based on state\n    The sequence also supports:\n    - Dependencies between rules\n    - Conditions for rule application",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_rules",
        "kind": 2,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "def create_predefined_rules() -> Dict[str, CellularRule]:\n    \"\"\"\n    Create a set of predefined cellular automata rules based on\n    hermetic principles and occult correspondences.\n    Returns:\n        Dictionary mapping rule names to CellularRule objects\n    \"\"\"\n    rules = {}\n    # The Great Work Rule - Based on alchemical transformation\n    great_work_params = RuleParameterSet(",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "create_predefined_sequences",
        "kind": 2,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "def create_predefined_sequences() -> Dict[str, RuleSequence]:\n    \"\"\"\n    Create a set of predefined rule sequences based on\n    magical rituals and occult correspondences.\n    Returns:\n        Dictionary mapping sequence names to RuleSequence objects\n    \"\"\"\n    rules = create_predefined_rules()\n    sequences = {}\n    # The Great Work Sequence - Alchemical transformation from base to divine",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.automata.cellular_rules",
        "description": "src.word_manifold.automata.cellular_rules",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HermeticPrinciple(Enum):\n    \"\"\"The seven Hermetic principles that govern transformation rules.\"\"\"\n    MENTALISM = auto()         # \"THE ALL is MIND; The Universe is Mental.\"\n    CORRESPONDENCE = auto()    # \"As above, so below; as below, so above.\"\n    VIBRATION = auto()         # \"Nothing rests; everything moves; everything vibrates.\"\n    POLARITY = auto()          # \"Everything is Dual; everything has poles.\"\n    RHYTHM = auto()            # \"Everything flows, out and in; everything has its tides.\"\n    CAUSE_EFFECT = auto()      # \"Every Cause has its Effect; Every Effect has its Cause.\"\n    GENDER = auto()            # \"Gender is in everything; everything has its Masculine and Feminine.\"",
        "detail": "src.word_manifold.automata.cellular_rules",
        "documentation": {}
    },
    {
        "label": "HermeticPrinciple",
        "kind": 6,
        "importPath": "src.word_manifold.automata.hermetic_principles",
        "description": "src.word_manifold.automata.hermetic_principles",
        "peekOfCode": "class HermeticPrinciple(Enum):\n    \"\"\"The seven hermetic principles from the Kybalion.\"\"\"\n    MENTALISM = auto()      # \"The All is Mind; The Universe is Mental.\"\n    CORRESPONDENCE = auto() # \"As above, so below; as below, so above.\"\n    VIBRATION = auto()     # \"Nothing rests; everything moves; everything vibrates.\"\n    POLARITY = auto()      # \"Everything is dual; everything has poles.\"\n    RHYTHM = auto()        # \"Everything flows, out and in; everything has its tides.\"\n    CAUSATION = auto()     # \"Every cause has its effect; every effect has its cause.\"\n    GENDER = auto()        # \"Gender is in everything; everything has its masculine and feminine principles.\"\n# Principle associations and correspondences",
        "detail": "src.word_manifold.automata.hermetic_principles",
        "documentation": {}
    },
    {
        "label": "Line",
        "kind": 6,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "class Line(Enum):\n    \"\"\"I Ching line types.\"\"\"\n    YIN = 0   # Broken line ⚋\n    YANG = 1  # Solid line ⚊\nclass CastingMethod(Enum):\n    \"\"\"Methods for casting hexagrams.\"\"\"\n    YARROW_STALKS = \"yarrow\"  # Traditional 50 yarrow stalks method\n    COINS = \"coins\"           # Three coins method\n    ORACLE_BONES = \"bones\"    # Ancient oracle bone method\n@dataclass",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "CastingMethod",
        "kind": 6,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "class CastingMethod(Enum):\n    \"\"\"Methods for casting hexagrams.\"\"\"\n    YARROW_STALKS = \"yarrow\"  # Traditional 50 yarrow stalks method\n    COINS = \"coins\"           # Three coins method\n    ORACLE_BONES = \"bones\"    # Ancient oracle bone method\n@dataclass\nclass Hexagram:\n    \"\"\"Represents an I Ching hexagram.\"\"\"\n    number: int  # 1-64\n    lines: List[Line]  # Bottom to top",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "Hexagram",
        "kind": 6,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "class Hexagram:\n    \"\"\"Represents an I Ching hexagram.\"\"\"\n    number: int  # 1-64\n    lines: List[Line]  # Bottom to top\n    name: str\n    attribute: str\n    image: str\n    nuclear_hexagram: Optional['Hexagram'] = None\n    opposite_hexagram: Optional['Hexagram'] = None\n    @property",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "HexagramRule",
        "kind": 6,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "class HexagramRule(CellularRule):\n    \"\"\"\n    A cellular automata rule based on I Ching hexagram transformations.\n    Each rule embodies the transformative principles of a specific hexagram,\n    applying its wisdom to vector space evolution.\n    \"\"\"\n    def __init__(\n        self,\n        hexagram: Hexagram,\n        parameters: Optional[RuleParameterSet] = None,",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "cast_hexagram",
        "kind": 2,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "def cast_hexagram(method: CastingMethod = CastingMethod.ORACLE_BONES) -> Tuple[Hexagram, List[int]]:\n    \"\"\"\n    Cast a hexagram using the specified method.\n    Args:\n        method: The divination method to use\n    Returns:\n        Tuple of (resulting hexagram, list of changing lines)\n    \"\"\"\n    lines = []\n    changing_lines = []",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "get_default_text",
        "kind": 2,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "def get_default_text() -> str:\n    \"\"\"Get a random default sacred text.\"\"\"\n    category = random.choice(list(DEFAULT_TEXTS.keys()))\n    return random.choice(DEFAULT_TEXTS[category])\nclass HexagramRule(CellularRule):\n    \"\"\"\n    A cellular automata rule based on I Ching hexagram transformations.\n    Each rule embodies the transformative principles of a specific hexagram,\n    applying its wisdom to vector space evolution.\n    \"\"\"",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "create_hexagram_rules",
        "kind": 2,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "def create_hexagram_rules() -> Dict[str, HexagramRule]:\n    \"\"\"Create the complete set of 64 hexagram-based rules.\"\"\"\n    rules = {}\n    # Create rules for each hexagram\n    for hexagram in hexagram_lookup.values():\n        rule = HexagramRule(hexagram)\n        rules[rule.name] = rule\n    return rules\n# Initialize hexagram lookup table with complete set\nhexagram_lookup: Dict[int, Hexagram] = {",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "nuclear_lines_to_number",
        "kind": 2,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "def nuclear_lines_to_number(lines: List[Line]) -> int:\n    \"\"\"Convert nuclear hexagram lines to hexagram number.\"\"\"\n    # Implementation to convert lines to hexagram number\n    return sum(line.value << i for i, line in enumerate(lines)) + 1",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TEXTS",
        "kind": 5,
        "importPath": "src.word_manifold.automata.hexagram_rules",
        "description": "src.word_manifold.automata.hexagram_rules",
        "peekOfCode": "DEFAULT_TEXTS = {\n    'hermetic': [\n        \"As above, so below; as below, so above.\",\n        \"All is mind; the universe is mental.\",\n        \"Nothing rests; everything moves; everything vibrates.\",\n        \"Everything is dual; everything has poles.\",\n        \"Everything flows, out and in; everything has its tides.\",\n    ],\n    'alchemical': [\n        \"Solve et Coagula\",",
        "detail": "src.word_manifold.automata.hexagram_rules",
        "documentation": {}
    },
    {
        "label": "EvolutionPattern",
        "kind": 6,
        "importPath": "src.word_manifold.automata.system",
        "description": "src.word_manifold.automata.system",
        "peekOfCode": "class EvolutionPattern(Enum):\n    \"\"\"Patterns of evolution that the automata system can follow.\"\"\"\n    LINEAR = auto()      # Sequential application of rules\n    CYCLIC = auto()      # Repeated application of rules in a cycle\n    SPIRAL = auto()      # Cyclic with increasing intensity\n    CHAOTIC = auto()     # Random selection of rules\n    THELEMIC = auto()    # Rules selected based on True Will principle\n    KABBALISTIC = auto() # Rules follow Tree of Life pattern\n@dataclass\nclass SystemState:",
        "detail": "src.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "SystemState",
        "kind": 6,
        "importPath": "src.word_manifold.automata.system",
        "description": "src.word_manifold.automata.system",
        "peekOfCode": "class SystemState:\n    \"\"\"State of the automata system at a point in time.\"\"\"\n    generation: int                # Current generation number\n    active_rules: List[str]        # Names of rules currently active\n    manifold_state: Dict[str, Any] # State snapshot of the manifold\n    timestamp: float               # Unix timestamp when state was captured\n    metrics: Dict[str, float]      # Metrics about the system's state\nclass AutomataSystem:\n    \"\"\"\n    A system that orchestrates the application of cellular automata rules",
        "detail": "src.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "AutomataSystem",
        "kind": 6,
        "importPath": "src.word_manifold.automata.system",
        "description": "src.word_manifold.automata.system",
        "peekOfCode": "class AutomataSystem:\n    \"\"\"\n    A system that orchestrates the application of cellular automata rules\n    to a word vector manifold according to hermetic principles.\n    This class manages the evolution of the manifold through generations,\n    applying rules according to specified patterns and tracking the system's\n    state over time.\n    \"\"\"\n    def __init__(\n        self,",
        "detail": "src.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.automata.system",
        "description": "src.word_manifold.automata.system",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass EvolutionPattern(Enum):\n    \"\"\"Patterns of evolution that the automata system can follow.\"\"\"\n    LINEAR = auto()      # Sequential application of rules\n    CYCLIC = auto()      # Repeated application of rules in a cycle\n    SPIRAL = auto()      # Cyclic with increasing intensity\n    CHAOTIC = auto()     # Random selection of rules\n    THELEMIC = auto()    # Rules selected based on True Will principle\n    KABBALISTIC = auto() # Rules follow Tree of Life pattern\n@dataclass",
        "detail": "src.word_manifold.automata.system",
        "documentation": {}
    },
    {
        "label": "LoggingSettings",
        "kind": 6,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "class LoggingSettings(BaseSettings):\n    \"\"\"Logging configuration settings.\"\"\"\n    level: str = \"INFO\"\n    format: str = \"%(asctime)s - %(name)s - [%(levelname)s] - %(message)s\"\n    file: Optional[Path] = None\n    max_size: str = \"10MB\"\n    backup_count: int = 5\n    class Config:\n        env_prefix = \"WM_LOG_\"\nclass SecuritySettings(BaseSettings):",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "SecuritySettings",
        "kind": 6,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "class SecuritySettings(BaseSettings):\n    \"\"\"Security and authentication settings.\"\"\"\n    enable_cors: bool = True\n    allowed_origins: List[str] = [\"*\"]\n    require_auth: bool = False\n    api_key: Optional[str] = None\n    jwt_secret: Optional[str] = None\n    jwt_algorithm: str = \"HS256\"\n    class Config:\n        env_prefix = \"WM_SECURITY_\"",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "ServerSettings",
        "kind": 6,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "class ServerSettings(BaseSettings):\n    \"\"\"Server configuration settings.\"\"\"\n    host: str = \"localhost\"\n    port: int = 5000\n    workers: int = 4\n    debug: bool = False\n    timeout: int = 30\n    reload: bool = False\n    class Config:\n        env_prefix = \"WM_SERVER_\"",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "ModelSettings",
        "kind": 6,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "class ModelSettings(BaseSettings):\n    \"\"\"ML model configuration settings.\"\"\"\n    embedding_model: str = \"sentence-transformers/all-MiniLM-L6-v2\"\n    emotion_model: str = \"j-hartmann/emotion-english-distilroberta-base\"\n    spacy_model: str = \"en_core_web_lg\"\n    device: str = Field(default_factory=lambda: \"cuda\" if torch.cuda.is_available() else \"cpu\")\n    batch_size: int = 32\n    max_sequence_length: int = 512\n    cache_dir: Optional[Path] = None\n    class Config:",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "CacheSettings",
        "kind": 6,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "class CacheSettings(BaseSettings):\n    \"\"\"Cache configuration settings.\"\"\"\n    enable: bool = True\n    type: str = \"memory\"  # memory, redis, filesystem\n    max_size: int = 10000\n    ttl: int = 3600  # seconds\n    redis_url: Optional[str] = None\n    filesystem_path: Optional[Path] = None\n    class Config:\n        env_prefix = \"WM_CACHE_\"",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "Settings",
        "kind": 6,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "class Settings(BaseSettings):\n    \"\"\"Main configuration settings.\"\"\"\n    app_name: str = \"word-manifold\"\n    version: str = \"0.1.0\"\n    debug: bool = False\n    environment: str = \"development\"\n    # Nested configurations\n    logging: LoggingSettings = LoggingSettings()\n    security: SecuritySettings = SecuritySettings()\n    server: ServerSettings = ServerSettings()",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": "src.word_manifold.config.settings",
        "description": "src.word_manifold.config.settings",
        "peekOfCode": "settings = Settings()",
        "detail": "src.word_manifold.config.settings",
        "documentation": {}
    },
    {
        "label": "EmbeddingMetadata",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class EmbeddingMetadata:\n    \"\"\"Metadata for an embedding.\"\"\"\n    model_name: str\n    dimensions: int\n    created_at: float\n    version: str = \"1.0.0\"\n@dataclass\nclass EmbeddingResult(Generic[T_co]):\n    \"\"\"Result of an embedding operation.\"\"\"\n    vector: EmbeddingVector",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "EmbeddingResult",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class EmbeddingResult(Generic[T_co]):\n    \"\"\"Result of an embedding operation.\"\"\"\n    vector: EmbeddingVector\n    metadata: EmbeddingMetadata\n    extra: Optional[T_co] = None\nclass EmbeddingError(Exception):\n    \"\"\"Base class for embedding-related errors.\"\"\"\n    pass\nclass ModelLoadError(EmbeddingError):\n    \"\"\"Error loading embedding model.\"\"\"",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "EmbeddingError",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class EmbeddingError(Exception):\n    \"\"\"Base class for embedding-related errors.\"\"\"\n    pass\nclass ModelLoadError(EmbeddingError):\n    \"\"\"Error loading embedding model.\"\"\"\n    pass\nclass EmbeddingProvider(Protocol):\n    \"\"\"Protocol defining the interface for embedding providers.\"\"\"\n    @property\n    def dimensions(self) -> int:",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "ModelLoadError",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class ModelLoadError(EmbeddingError):\n    \"\"\"Error loading embedding model.\"\"\"\n    pass\nclass EmbeddingProvider(Protocol):\n    \"\"\"Protocol defining the interface for embedding providers.\"\"\"\n    @property\n    def dimensions(self) -> int:\n        \"\"\"Get the dimensionality of the embeddings.\"\"\"\n        ...\n    @property",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "EmbeddingProvider",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class EmbeddingProvider(Protocol):\n    \"\"\"Protocol defining the interface for embedding providers.\"\"\"\n    @property\n    def dimensions(self) -> int:\n        \"\"\"Get the dimensionality of the embeddings.\"\"\"\n        ...\n    @property\n    def model_name(self) -> str:\n        \"\"\"Get the name of the embedding model.\"\"\"\n        ...",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "BaseEmbeddingProvider",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class BaseEmbeddingProvider(ABC):\n    \"\"\"Abstract base class for embedding providers.\"\"\"\n    def __init__(\n        self,\n        model_name: str,\n        device: Optional[torch.device] = None,\n        cache_dir: Optional[Path] = None,\n        **kwargs: Any\n    ):\n        self.model_name = model_name",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "CachedEmbeddingProvider",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "class CachedEmbeddingProvider:\n    \"\"\"Decorator class for adding caching to embedding providers.\"\"\"\n    def __init__(\n        self,\n        provider: EmbeddingProvider,\n        cache_size: int = 10000,\n        ttl: Optional[int] = None\n    ):\n        self.provider = provider\n        self.cache: Dict[str, tuple[float, EmbeddingResult]] = {}",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "T_co",
        "kind": 5,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "T_co = TypeVar(\"T_co\", covariant=True)\nEmbeddingVector = npt.NDArray[np.float32]\n@dataclass\nclass EmbeddingMetadata:\n    \"\"\"Metadata for an embedding.\"\"\"\n    model_name: str\n    dimensions: int\n    created_at: float\n    version: str = \"1.0.0\"\n@dataclass",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "EmbeddingVector",
        "kind": 5,
        "importPath": "src.word_manifold.core.embeddings.base",
        "description": "src.word_manifold.core.embeddings.base",
        "peekOfCode": "EmbeddingVector = npt.NDArray[np.float32]\n@dataclass\nclass EmbeddingMetadata:\n    \"\"\"Metadata for an embedding.\"\"\"\n    model_name: str\n    dimensions: int\n    created_at: float\n    version: str = \"1.0.0\"\n@dataclass\nclass EmbeddingResult(Generic[T_co]):",
        "detail": "src.word_manifold.core.embeddings.base",
        "documentation": {}
    },
    {
        "label": "TransformerEmbeddingProvider",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.transformers",
        "description": "src.word_manifold.core.embeddings.transformers",
        "peekOfCode": "class TransformerEmbeddingProvider(BaseEmbeddingProvider):\n    \"\"\"Embedding provider using sentence-transformers models.\"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",\n        device: Optional[torch.device] = None,\n        cache_dir: Optional[Path] = None,\n        max_seq_length: int = 512,\n        normalize_embeddings: bool = True,\n        **kwargs: Any",
        "detail": "src.word_manifold.core.embeddings.transformers",
        "documentation": {}
    },
    {
        "label": "InstructEmbeddingProvider",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.transformers",
        "description": "src.word_manifold.core.embeddings.transformers",
        "peekOfCode": "class InstructEmbeddingProvider(TransformerEmbeddingProvider):\n    \"\"\"Embedding provider with instruction tuning support.\"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",\n        instruction: str = \"Represent this text for retrieval:\",\n        **kwargs: Any\n    ):\n        \"\"\"Initialize the instruction-tuned embedding provider.\n        Args:",
        "detail": "src.word_manifold.core.embeddings.transformers",
        "documentation": {}
    },
    {
        "label": "MultilingualEmbeddingProvider",
        "kind": 6,
        "importPath": "src.word_manifold.core.embeddings.transformers",
        "description": "src.word_manifold.core.embeddings.transformers",
        "peekOfCode": "class MultilingualEmbeddingProvider(TransformerEmbeddingProvider):\n    \"\"\"Embedding provider with multilingual support.\"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2\",\n        **kwargs: Any\n    ):\n        \"\"\"Initialize the multilingual embedding provider.\"\"\"\n        super().__init__(model_name=model_name, **kwargs)\n    async def translate_and_embed(self, text: str, source_lang: str) -> EmbeddingResult:",
        "detail": "src.word_manifold.core.embeddings.transformers",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.core.embeddings.transformers",
        "description": "src.word_manifold.core.embeddings.transformers",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass TransformerEmbeddingProvider(BaseEmbeddingProvider):\n    \"\"\"Embedding provider using sentence-transformers models.\"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",\n        device: Optional[torch.device] = None,\n        cache_dir: Optional[Path] = None,\n        max_seq_length: int = 512,\n        normalize_embeddings: bool = True,",
        "detail": "src.word_manifold.core.embeddings.transformers",
        "documentation": {}
    },
    {
        "label": "TermWorker",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.distributed_term_manager",
        "description": "src.word_manifold.embeddings.distributed_term_manager",
        "peekOfCode": "class TermWorker:\n    \"\"\"Worker for processing terms in parallel.\"\"\"\n    def __init__(self, model_name: str):\n        self.model = SentenceTransformer(model_name)\n        if torch.cuda.is_available():\n            self.model.to(torch.device(\"cuda\"))\n    def process_batch(self, terms: List[str]) -> Dict[str, np.ndarray]:\n        \"\"\"Process a batch of terms to get embeddings.\"\"\"\n        try:\n            embeddings = self.model.encode(terms, convert_to_numpy=True)",
        "detail": "src.word_manifold.embeddings.distributed_term_manager",
        "documentation": {}
    },
    {
        "label": "DistributedTermManager",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.distributed_term_manager",
        "description": "src.word_manifold.embeddings.distributed_term_manager",
        "peekOfCode": "class DistributedTermManager:\n    \"\"\"\n    Distributed term manager using Ray for parallel processing.\n    Coordinates multiple workers across machines for term embedding.\n    \"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",\n        cache_size: int = 10000,\n        batch_size: int = 32,",
        "detail": "src.word_manifold.embeddings.distributed_term_manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.distributed_term_manager",
        "description": "src.word_manifold.embeddings.distributed_term_manager",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@ray.remote\nclass TermWorker:\n    \"\"\"Worker for processing terms in parallel.\"\"\"\n    def __init__(self, model_name: str):\n        self.model = SentenceTransformer(model_name)\n        if torch.cuda.is_available():\n            self.model.to(torch.device(\"cuda\"))\n    def process_batch(self, terms: List[str]) -> Dict[str, np.ndarray]:\n        \"\"\"Process a batch of terms to get embeddings.\"\"\"",
        "detail": "src.word_manifold.embeddings.distributed_term_manager",
        "documentation": {}
    },
    {
        "label": "PhraseEmbedding",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "class PhraseEmbedding:\n    \"\"\"\n    A class representing the embedding of a phrase or sentence,\n    including both its semantic content and structural shape.\n    \"\"\"\n    def __init__(self, text: str, embedding: np.ndarray, shape_params: Dict):\n        self.text = text\n        self.embedding = embedding\n        self.shape_params = shape_params\n    def __repr__(self) -> str:",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "PhraseEmbedder",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "class PhraseEmbedder:\n    \"\"\"\n    A class for embedding phrases and sentences into a semantic manifold,\n    extracting both meaning and structural patterns.\n    \"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L12-v2\",  # Using smaller default model\n        emotion_model_name: str = \"j-hartmann/emotion-english-distilroberta-base\",  # Smaller emotion model\n        cache_size: int = 500,  # Reduced cache size",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "get_spacy_model",
        "kind": 2,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "def get_spacy_model(model_name: str = 'en_core_web_lg') -> spacy.language.Language:\n    \"\"\"Load spaCy model with fallback options.\"\"\"\n    global _spacy_model\n    if _spacy_model is None:\n        try:\n            logger.info(f\"Loading spaCy model '{model_name}'\")\n            _spacy_model = spacy.load(model_name)\n        except OSError:\n            logger.warning(f\"spaCy model '{model_name}' not found, downloading...\")\n            try:",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "get_emotion_vector",
        "kind": 2,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "def get_emotion_vector(emotion: str) -> np.ndarray:\n    \"\"\"Get cached emotion vector for a category.\"\"\"\n    words = EMOTION_CATEGORIES[emotion]\n    vectors = []\n    nlp = get_spacy_model()\n    # Try each word in the category\n    for word in words:\n        token = nlp(word)[0]\n        if token.has_vector:\n            vectors.append(token.vector)",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "get_emotion_anchors",
        "kind": 2,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "def get_emotion_anchors():\n    \"\"\"Get emotion anchors, initializing them if needed.\"\"\"\n    global _EMOTION_ANCHORS\n    if _EMOTION_ANCHORS is None:\n        _EMOTION_ANCHORS = {}\n        for emotion in EMOTION_CATEGORIES:\n            vector = get_emotion_vector(emotion)\n            if np.any(vector):  # Only add emotions with non-zero vectors\n                _EMOTION_ANCHORS[emotion] = vector\n    return _EMOTION_ANCHORS",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "BACKUP_MODEL",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "BACKUP_MODEL = \"sentence-transformers/all-MiniLM-L6-v2\"  # Using smaller model as backup\n# Configure module logger\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n# Create formatters and handlers if they don't exist\nif not logger.handlers:\n    # Create console handler with formatting\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    console_formatter = logging.Formatter(",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n# Create formatters and handlers if they don't exist\nif not logger.handlers:\n    # Create console handler with formatting\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    console_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - [%(levelname)s] - %(message)s'\n    )",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "_spacy_model",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "_spacy_model = None\ndef get_spacy_model(model_name: str = 'en_core_web_lg') -> spacy.language.Language:\n    \"\"\"Load spaCy model with fallback options.\"\"\"\n    global _spacy_model\n    if _spacy_model is None:\n        try:\n            logger.info(f\"Loading spaCy model '{model_name}'\")\n            _spacy_model = spacy.load(model_name)\n        except OSError:\n            logger.warning(f\"spaCy model '{model_name}' not found, downloading...\")",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "EMOTION_CATEGORIES",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "EMOTION_CATEGORIES = {\n    'joy': ['happy', 'joyful', 'delighted', 'elated', 'ecstatic', 'content', 'pleased'],\n    'sadness': ['sad', 'depressed', 'gloomy', 'melancholy', 'heartbroken', 'grieving', 'unhappy'],\n    'anger': ['angry', 'furious', 'enraged', 'hostile', 'irritated', 'outraged', 'mad'],\n    'fear': ['afraid', 'scared', 'terrified', 'anxious', 'panicked', 'worried', 'frightened'],\n    'surprise': ['surprised', 'amazed', 'astonished', 'shocked', 'startled', 'stunned', 'unexpected'],\n    'disgust': ['disgusted', 'repulsed', 'revolted', 'appalled', 'nauseated', 'offended', 'gross'],\n    'trust': ['trusting', 'confident', 'secure', 'reliable', 'faithful', 'assured', 'believing'],\n    'anticipation': ['expectant', 'eager', 'excited', 'hopeful', 'optimistic', 'ready', 'awaiting']\n}",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "_EMOTION_ANCHORS",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.phrase_embeddings",
        "description": "src.word_manifold.embeddings.phrase_embeddings",
        "peekOfCode": "_EMOTION_ANCHORS = None\ndef get_emotion_anchors():\n    \"\"\"Get emotion anchors, initializing them if needed.\"\"\"\n    global _EMOTION_ANCHORS\n    if _EMOTION_ANCHORS is None:\n        _EMOTION_ANCHORS = {}\n        for emotion in EMOTION_CATEGORIES:\n            vector = get_emotion_vector(emotion)\n            if np.any(vector):  # Only add emotions with non-zero vectors\n                _EMOTION_ANCHORS[emotion] = vector",
        "detail": "src.word_manifold.embeddings.phrase_embeddings",
        "documentation": {}
    },
    {
        "label": "TermManager",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.term_manager",
        "description": "src.word_manifold.embeddings.term_manager",
        "peekOfCode": "class TermManager:\n    \"\"\"\n    Manages terms and their embeddings in a background process.\n    Provides caching and asynchronous processing capabilities with proper synchronization.\n    \"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",\n        cache_size: int = 10000,\n        batch_size: int = 32,",
        "detail": "src.word_manifold.embeddings.term_manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.term_manager",
        "description": "src.word_manifold.embeddings.term_manager",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass TermManager:\n    \"\"\"\n    Manages terms and their embeddings in a background process.\n    Provides caching and asynchronous processing capabilities with proper synchronization.\n    \"\"\"\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",\n        cache_size: int = 10000,",
        "detail": "src.word_manifold.embeddings.term_manager",
        "documentation": {}
    },
    {
        "label": "WordEmbeddings",
        "kind": 6,
        "importPath": "src.word_manifold.embeddings.word_embeddings",
        "description": "src.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "class WordEmbeddings:\n    \"\"\"\n    Manages word embeddings with background processing support.\n    \"\"\"\n    DEFAULT_MODEL = DEFAULT_MODEL\n    BACKUP_MODEL = BACKUP_MODEL\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",\n        cache_size: int = 10000,",
        "detail": "src.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "os.environ[\"TOKENIZERS_PARALLELISM\"]",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.word_embeddings",
        "description": "src.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "os.environ[\"TOKENIZERS_PARALLELISM\"] = \"false\"\n# Configure logging\nlogging.basicConfig(level=logging.INFO,\n                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n# Default models - using smaller models by default\nDEFAULT_MODEL = 'sentence-transformers/all-MiniLM-L6-v2'  # Much smaller model\nBACKUP_MODEL = 'sentence-transformers/paraphrase-MiniLM-L3-v2'  # Even smaller backup\nclass WordEmbeddings:\n    \"\"\"",
        "detail": "src.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.word_embeddings",
        "description": "src.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Default models - using smaller models by default\nDEFAULT_MODEL = 'sentence-transformers/all-MiniLM-L6-v2'  # Much smaller model\nBACKUP_MODEL = 'sentence-transformers/paraphrase-MiniLM-L3-v2'  # Even smaller backup\nclass WordEmbeddings:\n    \"\"\"\n    Manages word embeddings with background processing support.\n    \"\"\"\n    DEFAULT_MODEL = DEFAULT_MODEL\n    BACKUP_MODEL = BACKUP_MODEL",
        "detail": "src.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "DEFAULT_MODEL",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.word_embeddings",
        "description": "src.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "DEFAULT_MODEL = 'sentence-transformers/all-MiniLM-L6-v2'  # Much smaller model\nBACKUP_MODEL = 'sentence-transformers/paraphrase-MiniLM-L3-v2'  # Even smaller backup\nclass WordEmbeddings:\n    \"\"\"\n    Manages word embeddings with background processing support.\n    \"\"\"\n    DEFAULT_MODEL = DEFAULT_MODEL\n    BACKUP_MODEL = BACKUP_MODEL\n    def __init__(\n        self,",
        "detail": "src.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "BACKUP_MODEL",
        "kind": 5,
        "importPath": "src.word_manifold.embeddings.word_embeddings",
        "description": "src.word_manifold.embeddings.word_embeddings",
        "peekOfCode": "BACKUP_MODEL = 'sentence-transformers/paraphrase-MiniLM-L3-v2'  # Even smaller backup\nclass WordEmbeddings:\n    \"\"\"\n    Manages word embeddings with background processing support.\n    \"\"\"\n    DEFAULT_MODEL = DEFAULT_MODEL\n    BACKUP_MODEL = BACKUP_MODEL\n    def __init__(\n        self,\n        model_name: str = \"sentence-transformers/all-MiniLM-L6-v2\",",
        "detail": "src.word_manifold.embeddings.word_embeddings",
        "documentation": {}
    },
    {
        "label": "ForceFieldDemo",
        "kind": 6,
        "importPath": "src.word_manifold.examples.force_field_demo",
        "description": "src.word_manifold.examples.force_field_demo",
        "peekOfCode": "class ForceFieldDemo:\n    def __init__(self, n_dimensions=3):\n        \"\"\"Initialize the force field demonstration.\n        Args:\n            n_dimensions (int): Number of dimensions for the semantic space\n        \"\"\"\n        self.n_dimensions = n_dimensions\n        self.embeddings = None\n        self.manifold = None\n        self.visualizer = None",
        "detail": "src.word_manifold.examples.force_field_demo",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.word_manifold.examples.force_field_demo",
        "description": "src.word_manifold.examples.force_field_demo",
        "peekOfCode": "def main():\n    \"\"\"Run the force field visualization demo.\"\"\"\n    # Create and run simulation\n    demo = ForceFieldDemo(n_dimensions=3)\n    demo.prepare_components()\n    viz_path = demo.simulate_force_field()\n    logger.info(f\"\"\"\n    Force field visualization complete!\n    This demonstration shows how concepts move through a semantic force field:\n    - Red points are attractors (positive concepts)",
        "detail": "src.word_manifold.examples.force_field_demo",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.examples.force_field_demo",
        "description": "src.word_manifold.examples.force_field_demo",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass ForceFieldDemo:\n    def __init__(self, n_dimensions=3):\n        \"\"\"Initialize the force field demonstration.\n        Args:\n            n_dimensions (int): Number of dimensions for the semantic space\n        \"\"\"\n        self.n_dimensions = n_dimensions\n        self.embeddings = None\n        self.manifold = None",
        "detail": "src.word_manifold.examples.force_field_demo",
        "documentation": {}
    },
    {
        "label": "HyperdimensionalRitual",
        "kind": 6,
        "importPath": "src.word_manifold.examples.hyperdimensional_ritual",
        "description": "src.word_manifold.examples.hyperdimensional_ritual",
        "peekOfCode": "class HyperdimensionalRitual:\n    \"\"\"\n    A class demonstrating hyperdimensional visualization of Thelemic rituals.\n    \"\"\"\n    def __init__(\n        self,\n        n_dimensions: int = 5,  # We'll use 5D for richer semantic representation\n        output_dir: str = \"visualizations/hyperdimensional\"\n    ):\n        self.n_dimensions = n_dimensions",
        "detail": "src.word_manifold.examples.hyperdimensional_ritual",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.word_manifold.examples.hyperdimensional_ritual",
        "description": "src.word_manifold.examples.hyperdimensional_ritual",
        "peekOfCode": "def main():\n    \"\"\"Run the hyperdimensional ritual visualization example.\"\"\"\n    # Create and prepare the ritual\n    ritual = HyperdimensionalRitual(n_dimensions=5)\n    ritual.prepare_components()\n    # Create visualization\n    viz_path = ritual.visualize_ritual_transformation()\n    logger.info(f\"\"\"\n    Hyperdimensional ritual visualization complete!\n    The visualization shows the evolution of Thelemic concepts through a 5-dimensional",
        "detail": "src.word_manifold.examples.hyperdimensional_ritual",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.examples.hyperdimensional_ritual",
        "description": "src.word_manifold.examples.hyperdimensional_ritual",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HyperdimensionalRitual:\n    \"\"\"\n    A class demonstrating hyperdimensional visualization of Thelemic rituals.\n    \"\"\"\n    def __init__(\n        self,\n        n_dimensions: int = 5,  # We'll use 5D for richer semantic representation\n        output_dir: str = \"visualizations/hyperdimensional\"\n    ):",
        "detail": "src.word_manifold.examples.hyperdimensional_ritual",
        "documentation": {}
    },
    {
        "label": "RitualWorking",
        "kind": 6,
        "importPath": "src.word_manifold.examples.ritual_evolution",
        "description": "src.word_manifold.examples.ritual_evolution",
        "peekOfCode": "class RitualWorking:\n    \"\"\"\n    A class that implements a complete magical working in word vector space.\n    \"\"\"\n    def _create_evolution_animation(self, key_terms):\n        \"\"\"\n        Create an animation of the evolution of machinic desires using fluid visual transformations and emergent patterns.\n        Args:\n            key_terms: List of key terms to highlight in the animation description\n        Returns:",
        "detail": "src.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "memoize",
        "kind": 2,
        "importPath": "src.word_manifold.examples.ritual_evolution",
        "description": "src.word_manifold.examples.ritual_evolution",
        "peekOfCode": "def memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.\n    Results are cached in memory and on disk for persistence between runs.\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        # Create a unique key based on function name and arguments\n        key_parts = [func.__name__]\n        # Add class name if it's a method",
        "detail": "src.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.word_manifold.examples.ritual_evolution",
        "description": "src.word_manifold.examples.ritual_evolution",
        "peekOfCode": "def main():\n    \"\"\" Demonstrate the ritual evolution process. \"\"\"\n    ritual = RitualWorking(\n        ritual_name=\"True Will Discovery\",\n        ritual_intent=\"To discover and align with one's True Will through semantic transformation\"\n    )\n    # Prepare components\n    ritual.prepare_components()\n    # Perform the ritual\n    ritual.perform_ritual()",
        "detail": "src.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.examples.ritual_evolution",
        "description": "src.word_manifold.examples.ritual_evolution",
        "peekOfCode": "logger = logging.getLogger(\"ritual_evolution\")\n# Directory for saving outputs\nOUTPUT_DIR = Path(\"ritual_outputs\")\nCACHE_DIR = Path(\".ritual_cache\")\n# Create cache directory if it doesn't exist\nCACHE_DIR.mkdir(exist_ok=True)\n# Function cache decorator with key based on function arguments\ndef memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.",
        "detail": "src.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "OUTPUT_DIR",
        "kind": 5,
        "importPath": "src.word_manifold.examples.ritual_evolution",
        "description": "src.word_manifold.examples.ritual_evolution",
        "peekOfCode": "OUTPUT_DIR = Path(\"ritual_outputs\")\nCACHE_DIR = Path(\".ritual_cache\")\n# Create cache directory if it doesn't exist\nCACHE_DIR.mkdir(exist_ok=True)\n# Function cache decorator with key based on function arguments\ndef memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.\n    Results are cached in memory and on disk for persistence between runs.\n    \"\"\"",
        "detail": "src.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "CACHE_DIR",
        "kind": 5,
        "importPath": "src.word_manifold.examples.ritual_evolution",
        "description": "src.word_manifold.examples.ritual_evolution",
        "peekOfCode": "CACHE_DIR = Path(\".ritual_cache\")\n# Create cache directory if it doesn't exist\nCACHE_DIR.mkdir(exist_ok=True)\n# Function cache decorator with key based on function arguments\ndef memoize(func):\n    \"\"\"\n    Decorator for memoizing function results.\n    Results are cached in memory and on disk for persistence between runs.\n    \"\"\"\n    @functools.wraps(func)",
        "detail": "src.word_manifold.examples.ritual_evolution",
        "documentation": {}
    },
    {
        "label": "ReadingStep",
        "kind": 6,
        "importPath": "src.word_manifold.examples.semantic_crystallization",
        "description": "src.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "class ReadingStep:\n    \"\"\"Represents a single step in the reading sequence.\"\"\"\n    card: str  # The card or concept being integrated\n    keywords: List[str]  # Associated keywords/meanings\n    position: str  # Position or aspect in the reading (e.g., \"past\", \"present\", \"future\")\n    influence: float = 1.0  # Relative influence of this step (0-1)\nterms=[\n                # Major Arcana\n                \"fool\", \"magician\", \"priestess\", \"empress\", \"emperor\",\n                \"hierophant\", \"lovers\", \"chariot\", \"strength\", \"hermit\",",
        "detail": "src.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "SemanticCrystallization",
        "kind": 6,
        "importPath": "src.word_manifold.examples.semantic_crystallization",
        "description": "src.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "class SemanticCrystallization:\n    \"\"\"\n    Visualizes the crystallization of meaning during a reading sequence.\n    This class tracks how semantic space transforms as each new card or concept\n    is integrated, showing the accumulation and crystallization of meaning over time.\n    \"\"\"\n    def __init__(\n        self,\n        n_dimensions: int = 5,\n        output_dir: str = \"visualizations/crystallization\",",
        "detail": "src.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.word_manifold.examples.semantic_crystallization",
        "description": "src.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "def main():\n    \"\"\"Run the semantic crystallization example.\"\"\"\n    # Create and prepare crystallization viewer\n    crystal = SemanticCrystallization(n_dimensions=5)\n    crystal.prepare_components()\n    # Example Celtic Cross reading sequence\n    reading_sequence = [\n        # Central cross\n        (\"present\", \"tower\", [\"disruption\", \"awakening\", \"revelation\"]),\n        (\"challenge\", \"death\", [\"transformation\", \"ending\", \"rebirth\"]),",
        "detail": "src.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.examples.semantic_crystallization",
        "description": "src.word_manifold.examples.semantic_crystallization",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass ReadingStep:\n    \"\"\"Represents a single step in the reading sequence.\"\"\"\n    card: str  # The card or concept being integrated\n    keywords: List[str]  # Associated keywords/meanings\n    position: str  # Position or aspect in the reading (e.g., \"past\", \"present\", \"future\")\n    influence: float = 1.0  # Relative influence of this step (0-1)\nterms=[\n                # Major Arcana",
        "detail": "src.word_manifold.examples.semantic_crystallization",
        "documentation": {}
    },
    {
        "label": "ThelemaMetrics",
        "kind": 6,
        "importPath": "src.word_manifold.examples.thelemic_evolution",
        "description": "src.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "class ThelemaMetrics:\n    \"\"\"\n    A class to calculate and track metrics for the Thelemic evolution of a word manifold.\n    Metrics include:\n    - Semantic entropy: Measure of semantic diversity\n    - Numerological alignment: Correspondence between numerological values\n    - Will manifestation: How closely the system follows its \"True Will\"\n    - Transmutation index: Degree of alchemical transformation\n    \"\"\"\n    def __init__(self):",
        "detail": "src.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "BasicVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.examples.thelemic_evolution",
        "description": "src.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "class BasicVisualizer:\n    \"\"\"\n    A basic visualization class for when the full visualizer is not available.\n    This creates simple 2D plots of the manifold's reduced representation.\n    \"\"\"\n    def __init__(self, manifold: VectorManifold, save_path: str):\n        \"\"\"\n        Initialize the basic visualizer.\n        Args:\n            manifold: The vector manifold to visualize",
        "detail": "src.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "run_thelemic_evolution",
        "kind": 2,
        "importPath": "src.word_manifold.examples.thelemic_evolution",
        "description": "src.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "def run_thelemic_evolution(\n    generations: int = 22,  # One for each Major Arcana\n    save_path: str = None,\n    model_name: str = \"bert-base-uncased\",\n    n_cells: int = 22,\n    random_state: int = 93  # Significant in Thelema/Crowley's work\n):\n    \"\"\"\n    Run the Thelemic evolution of the word manifold.\n    Args:",
        "detail": "src.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.examples.thelemic_evolution",
        "description": "src.word_manifold.examples.thelemic_evolution",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Add the project root to the Python path if running as a script\nif __name__ == \"__main__\":\n    project_root = str(Path(__file__).resolve().parents[3])\n    sys.path.insert(0, project_root)\n# Import Word Manifold components\nfrom word_manifold.embeddings.word_embeddings import WordEmbeddings\nfrom word_manifold.manifold.vector_manifold import VectorManifold, CellType\nfrom word_manifold.automata.cellular_rules import create_predefined_rules\nfrom word_manifold.automata.system import AutomataSystem, EvolutionPattern, SystemState",
        "detail": "src.word_manifold.examples.thelemic_evolution",
        "documentation": {}
    },
    {
        "label": "RecursiveReducer",
        "kind": 6,
        "importPath": "src.word_manifold.manifold.reduction",
        "description": "src.word_manifold.manifold.reduction",
        "peekOfCode": "class RecursiveReducer:\n    \"\"\"Handles recursive dimensionality reduction with fractal patterns.\"\"\"\n    def __init__(\n        self,\n        manifold,\n        depth: int = 3,\n        min_cluster_size: int = 5,\n        coherence_threshold: float = 0.8,\n        scale_factor: float = 0.5,\n        rotation_symmetry: int = 5",
        "detail": "src.word_manifold.manifold.reduction",
        "documentation": {}
    },
    {
        "label": "ShapePoint",
        "kind": 6,
        "importPath": "src.word_manifold.manifold.semantic_shape",
        "description": "src.word_manifold.manifold.semantic_shape",
        "peekOfCode": "class ShapePoint:\n    \"\"\"A point in the semantic shape with its associated properties.\"\"\"\n    position: np.ndarray\n    intensity: float  # Emotional/semantic intensity\n    direction: np.ndarray  # Flow direction\n    properties: Dict  # Additional shape properties\nclass SemanticShape:\n    \"\"\"\n    A class representing the shape of meaning in semantic space.\n    This captures both the geometric form and the dynamic properties",
        "detail": "src.word_manifold.manifold.semantic_shape",
        "documentation": {}
    },
    {
        "label": "SemanticShape",
        "kind": 6,
        "importPath": "src.word_manifold.manifold.semantic_shape",
        "description": "src.word_manifold.manifold.semantic_shape",
        "peekOfCode": "class SemanticShape:\n    \"\"\"\n    A class representing the shape of meaning in semantic space.\n    This captures both the geometric form and the dynamic properties\n    of a semantic expression (phrase, sentence, or text chunk).\n    \"\"\"\n    def __init__(\n        self,\n        phrase_embedding: PhraseEmbedding,\n        n_control_points: int = 10",
        "detail": "src.word_manifold.manifold.semantic_shape",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.manifold.semantic_shape",
        "description": "src.word_manifold.manifold.semantic_shape",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass ShapePoint:\n    \"\"\"A point in the semantic shape with its associated properties.\"\"\"\n    position: np.ndarray\n    intensity: float  # Emotional/semantic intensity\n    direction: np.ndarray  # Flow direction\n    properties: Dict  # Additional shape properties\nclass SemanticShape:\n    \"\"\"",
        "detail": "src.word_manifold.manifold.semantic_shape",
        "documentation": {}
    },
    {
        "label": "Cell",
        "kind": 6,
        "importPath": "src.word_manifold.manifold.vector_manifold",
        "description": "src.word_manifold.manifold.vector_manifold",
        "peekOfCode": "class Cell:\n    \"\"\"\n    A cell in the manifold representing a region in the vector space.\n    \"\"\"\n    id: int\n    terms: Set[str]  # Words or phrases that belong to this cell\n    centroid: np.ndarray  # Center point of the cell in embedding space\n    type: CellType  # Type of cell with occult significance\n    numerological_value: int  # Numerological value of the cell\n    boundary_points: Optional[np.ndarray] = None  # Points defining the boundary (if available)",
        "detail": "src.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "ManifoldReducedState",
        "kind": 6,
        "importPath": "src.word_manifold.manifold.vector_manifold",
        "description": "src.word_manifold.manifold.vector_manifold",
        "peekOfCode": "class ManifoldReducedState(NamedTuple):\n    \"\"\"State of the reduced manifold for visualization and cellular operations.\"\"\"\n    points: np.ndarray         # 2D or 3D points\n    labels: List[int]          # Cell labels for each point\n    cell_centroids: np.ndarray # Reduced centroids\n    boundaries: Any            # Boundary representations (e.g., Voronoi)\nclass VectorManifold:\n    \"\"\"\n    A class representing a manifold in vector space for word and phrase embeddings.\n    This class handles the geometric relationships between embeddings,",
        "detail": "src.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "VectorManifold",
        "kind": 6,
        "importPath": "src.word_manifold.manifold.vector_manifold",
        "description": "src.word_manifold.manifold.vector_manifold",
        "peekOfCode": "class VectorManifold:\n    \"\"\"\n    A class representing a manifold in vector space for word and phrase embeddings.\n    This class handles the geometric relationships between embeddings,\n    including Voronoi tessellation and neighborhood calculations.\n    \"\"\"\n    def __init__(\n        self,\n        embeddings: Union[WordEmbeddings, PhraseEmbedding],\n        n_cells: int = 22,  # Default to 22 cells (major arcana)",
        "detail": "src.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.manifold.vector_manifold",
        "description": "src.word_manifold.manifold.vector_manifold",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass Cell:\n    \"\"\"\n    A cell in the manifold representing a region in the vector space.\n    \"\"\"\n    id: int\n    terms: Set[str]  # Words or phrases that belong to this cell\n    centroid: np.ndarray  # Center point of the cell in embedding space\n    type: CellType  # Type of cell with occult significance",
        "detail": "src.word_manifold.manifold.vector_manifold",
        "documentation": {}
    },
    {
        "label": "PatternType",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.timeseries",
        "description": "src.word_manifold.visualization.engines.timeseries",
        "peekOfCode": "class PatternType(Enum):\n    \"\"\"Types of temporal patterns that can be generated.\"\"\"\n    CYCLIC = \"cyclic\"           # Cyclic patterns based on trigonometric functions\n    LINEAR = \"linear\"           # Linear trends with embedding-based slopes\n    HARMONIC = \"harmonic\"       # Multiple harmonics with embedding-weighted amplitudes\n    SPIRAL = \"spiral\"           # Spiral patterns showing cyclic evolution\n    WAVE = \"wave\"              # Complex waveforms combining multiple patterns\nclass TimeSeriesEngine(VisualizationEngine):\n    \"\"\"Engine for generating and processing time series data.\"\"\"\n    def __init__(self, embeddings: WordEmbeddings):",
        "detail": "src.word_manifold.visualization.engines.timeseries",
        "documentation": {}
    },
    {
        "label": "TimeSeriesEngine",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.engines.timeseries",
        "description": "src.word_manifold.visualization.engines.timeseries",
        "peekOfCode": "class TimeSeriesEngine(VisualizationEngine):\n    \"\"\"Engine for generating and processing time series data.\"\"\"\n    def __init__(self, embeddings: WordEmbeddings):\n        \"\"\"Initialize the engine with word embeddings.\"\"\"\n        super().__init__()\n        self.embeddings = embeddings\n    def generate_time_points(\n        self,\n        timeframe: str,\n        interval: str,",
        "detail": "src.word_manifold.visualization.engines.timeseries",
        "documentation": {}
    },
    {
        "label": "TimeSeriesRenderer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.renderers.timeseries",
        "description": "src.word_manifold.visualization.renderers.timeseries",
        "peekOfCode": "class TimeSeriesRenderer(VisualizationRenderer):\n    \"\"\"Renderer for time series visualizations.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize the renderer.\"\"\"\n        super().__init__()\n    def render_local(\n        self,\n        data: Dict[str, Any],\n        output_path: Path,\n        title: Optional[str] = None,",
        "detail": "src.word_manifold.visualization.renderers.timeseries",
        "documentation": {}
    },
    {
        "label": "VisualizationData",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.base",
        "description": "src.word_manifold.visualization.base",
        "peekOfCode": "class VisualizationData(Protocol):\n    \"\"\"Protocol for visualization data containers.\"\"\"\n    def to_plot_data(self) -> Dict[str, Any]: ...\n    def get_color_map(self) -> Dict[str, str]: ...\n    def get_labels(self) -> Dict[int, str]: ...\nclass Visualizer(ABC):\n    \"\"\"Abstract base class for visualizers.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize visualizer.\"\"\"\n        self._figure: Optional[Figure] = None",
        "detail": "src.word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "Visualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.base",
        "description": "src.word_manifold.visualization.base",
        "peekOfCode": "class Visualizer(ABC):\n    \"\"\"Abstract base class for visualizers.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize visualizer.\"\"\"\n        self._figure: Optional[Figure] = None\n    @abstractmethod\n    def prepare_data(self) -> VisualizationData:\n        \"\"\"Prepare data for visualization.\"\"\"\n        pass\n    @abstractmethod",
        "detail": "src.word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "InteractiveVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.base",
        "description": "src.word_manifold.visualization.base",
        "peekOfCode": "class InteractiveVisualizer(Visualizer):\n    \"\"\"Base class for interactive visualizers.\"\"\"\n    def __init__(self):\n        \"\"\"Initialize interactive visualizer.\"\"\"\n        super().__init__()\n        self._is_interactive = True\n    @abstractmethod\n    def update(self) -> None:\n        \"\"\"Update visualization based on current state.\"\"\"\n        pass",
        "detail": "src.word_manifold.visualization.base",
        "documentation": {}
    },
    {
        "label": "lazy_import",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def lazy_import(module_name: str) -> Callable:\n    \"\"\"Lazily import a module only when needed.\"\"\"\n    def get_module():\n        import importlib\n        try:\n            return importlib.import_module(module_name)\n        except ImportError as e:\n            logger.error(f\"Failed to import {module_name}: {e}\")\n            raise click.ClickException(f\"Required module {module_name} not found. Please install required dependencies.\")\n    return get_module",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "validate_server_config",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def validate_server_config(config: Dict) -> Tuple[bool, List[str]]:\n    \"\"\"Validate server configuration.\"\"\"\n    errors = []\n    # Validate server section\n    server = config.get('server', {})\n    if not isinstance(server.get('port', 0), int) or not 0 < server.get('port', 0) < 65536:\n        errors.append(\"Port must be an integer between 1 and 65535\")\n    if not isinstance(server.get('timeout', 0), (int, float)) or server.get('timeout', 0) <= 0:\n        errors.append(\"Timeout must be a positive number\")\n    # Validate security section",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_server_process",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def get_server_process(port: int) -> Optional['psutil.Process']:\n    \"\"\"Find server process by port.\"\"\"\n    for proc in psutil.process_iter(['pid', 'name']):\n        try:\n            for conn in proc.net_connections(kind='inet'):\n                if conn.laddr.port == port and conn.status == 'LISTEN':\n                    return proc\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.Error):\n            continue\n    return None",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def load_config(config_path: Optional[Path] = None) -> Dict:\n    \"\"\"Load configuration from file or return defaults.\"\"\"\n    if config_path and config_path.exists():\n        with open(config_path) as f:\n            user_config = yaml.safe_load(f)\n            # Merge with defaults\n            return {**DEFAULT_CONFIG, **user_config}\n    return DEFAULT_CONFIG\n# Server configuration\nconfig = load_config(Path('word_manifold.yaml'))",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "handle_server_request",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def handle_server_request(method: str, endpoint: str, data: Dict[str, Any] = None, timeout: int = DEFAULT_TIMEOUTS['server']) -> Dict[str, Any]:\n    \"\"\"Handle server request with proper error handling and retries.\"\"\"\n    try:\n        if method.upper() == 'GET':\n            response = requests.get(f'{SERVER_URL}{endpoint}', timeout=timeout)\n        else:\n            response = requests.post(f'{SERVER_URL}{endpoint}', json=data, timeout=timeout)\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.Timeout as exc:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "ensure_server_running",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def ensure_server_running():\n    \"\"\"Start visualization server if not running.\"\"\"\n    try:\n        response = requests.get(f'{SERVER_URL}/health', timeout=DEFAULT_TIMEOUTS['health'])\n        if response.status_code == 200:\n            return\n    except (requests.exceptions.ConnectionError, requests.exceptions.Timeout):\n        logger.info(\"Starting visualization server...\")\n        # Import server module only when needed\n        try:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "with_progress",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def with_progress(desc: str = None):\n    \"\"\"Progress bar decorator for long-running operations.\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            with tqdm(desc=desc or func.__name__, leave=True) as pbar:\n                result = func(*args, **kwargs)\n                pbar.update(1)\n                return result\n        return wrapper",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_retry_decorator",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def get_retry_decorator():\n    \"\"\"Get the appropriate retry decorator based on availability.\"\"\"\n    if not RETRY_ENABLED:\n        return lambda x: x  # No-op decorator\n    return retry(\n        stop=stop_after_attempt(3),\n        wait=wait_exponential(multiplier=1, min=4, max=10),\n        retry=retry_if_exception_type((requests.exceptions.Timeout, requests.exceptions.ConnectionError)),\n        before=before_log(logger, logging.DEBUG),\n        after=before_log(logger, logging.DEBUG),",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def cli(debug, config):\n    \"\"\"Word Manifold visualization and analysis tools.\"\"\"\n    # Print package location to verify we're using local source\n    import word_manifold\n    logger.info(f\"Using word-manifold package from: {Path(word_manifold.__file__).parent}\")\n    # Set logging level based on debug flag\n    logger.setLevel(logging.DEBUG if debug else logging.INFO)\n    # Propagate to other loggers\n    logging.getLogger('word_manifold').setLevel(logging.DEBUG if debug else logging.INFO)\n    # Load configuration if provided",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "server",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def server():\n    \"\"\"Server management commands.\"\"\"\n    pass\n@server.command()\n@click.option('--host', default=DEFAULT_HOST, help='Server host address')\n@click.option('--port', default=DEFAULT_PORT, help='Server port')\n@click.option('--remote/--local', default=False, help='Run in remote or local mode')\n@click.option('--workers', default=1, type=int, help='Number of worker processes')\n@click.option('--daemon/--no-daemon', default=False, help='Run server as daemon process')\n@click.option('--debug/--no-debug', default=False, help='Enable debug mode')",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "start",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def start(host: str, port: int, remote: bool, workers: int, daemon: bool, debug: bool):\n    \"\"\"Start the visualization server.\"\"\"\n    try:\n        # Set logging level based on debug flag\n        if debug:\n            logger.setLevel(logging.DEBUG)\n            logging.getLogger('word_manifold').setLevel(logging.DEBUG)\n            logging.getLogger('flask').setLevel(logging.DEBUG)\n        # Import server modules only when needed\n        try:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "status",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def status(host: str, port: int, config: Optional[Path]):\n    \"\"\"Check detailed server status.\"\"\"\n    url = f\"http://{host}:{port}\"\n    try:\n        # Check basic connectivity\n        health_response = requests.get(f\"{url}/health\", timeout=DEFAULT_TIMEOUTS['health'])\n        if health_response.status_code != 200:\n            click.echo(click.style(\"✗ Server is not healthy\", fg=\"red\"))\n            return\n        # Get process information",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "stop",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def stop(host: str, port: int, force: bool):\n    \"\"\"Stop the server with graceful shutdown.\"\"\"\n    url = f\"http://{host}:{port}/shutdown\"\n    proc = get_server_process(port)\n    try:\n        if not force:\n            # Try graceful shutdown first\n            response = requests.post(url, timeout=DEFAULT_TIMEOUTS['shutdown'])\n            if response.status_code == 200:\n                click.echo(click.style(\"✓ Server stopped gracefully\", fg=\"green\"))",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "restart",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def restart(host: str, port: int):\n    \"\"\"Restart the server.\"\"\"\n    try:\n        # Stop server\n        click.echo(\"Stopping server...\")\n        stop.callback(host=host, port=port, force=False)\n        # Wait for port to be available\n        max_wait = 10\n        for i in range(max_wait):\n            if not get_server_process(port):",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "visualize",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def visualize(interactive, output_dir, dimensions, model):\n    \"\"\"Create visualizations of the word manifold.\"\"\"\n    try:\n        # Initialize embeddings and manifold\n        embeddings = get_word_embeddings().WordEmbeddings(model_name=model)\n        # Define example terms\n        terms = [\n            \"light\", \"darkness\", \"wisdom\", \"understanding\",\n            \"beauty\", \"strength\", \"mercy\", \"severity\"\n        ]",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "symbolic",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def symbolic(text: str, output_dir: str, width: int, height: int):\n    \"\"\"Create symbolic visualizations of text.\"\"\"\n    try:\n        # Lazy load dependencies\n        WordEmbeddings = get_word_embeddings().WordEmbeddings\n        SymbolicVisualizer = get_symbolic_vis().SymbolicVisualizer\n        embeddings = WordEmbeddings()\n        visualizer = SymbolicVisualizer(embeddings, width=width, height=height)\n        output_path = Path(output_dir)\n        output_path.mkdir(parents=True, exist_ok=True)",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "semantic_tree",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def semantic_tree(text: str, output_dir: str, max_depth: int, branching_factor: int):\n    \"\"\"Generate semantic tree visualization for text.\"\"\"\n    try:\n        embeddings = get_word_embeddings().WordEmbeddings()\n        visualizer = get_semantic_tree().SemanticTreeVisualizer(embeddings)\n        # Find related terms\n        related_terms = []\n        for term in text.split():\n            similar = embeddings.find_similar_terms(term, k=5)\n            related_terms.extend([t for t, _ in similar])",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "shapes",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def shapes(text: str, output_dir: str, chunk_size: int):\n    \"\"\"Generate shape field visualizations for text.\"\"\"\n    try:\n        visualizer = get_shape_vis().ShapeVisualizer()\n        output_path = Path(output_dir)\n        output_path.mkdir(parents=True, exist_ok=True)\n        # Create shape field visualization\n        visualizer.create_shape_field(text, chunk_size=chunk_size)\n        # Move generated files to output directory\n        for file in Path('.').glob('shape_field*.png'):",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "automata",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def automata(text: str, rule: str, output_dir: str, iterations: int):\n    \"\"\"Apply cellular automata rules to transform text.\"\"\"\n    try:\n        embeddings = get_word_embeddings().WordEmbeddings()\n        manifold = get_vector_manifold().VectorManifold(embeddings)\n        rules = get_cellular_rules().create_predefined_rules()\n        # Initialize manifold with text\n        for term in text.split():\n            vector = embeddings.get_embedding(term)\n            if vector is not None:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "manifold",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def manifold(terms: List[str], model: str, dimensions: int, output: str, save_format: str):\n    \"\"\"Generate static manifold visualization for given terms.\"\"\"\n    ensure_server_running()\n    try:\n        # Validate input\n        if not terms:\n            raise click.ClickException(\"Please provide at least one term to visualize\")\n        if dimensions < 2 or dimensions > 3:\n            raise click.ClickException(\"Dimensions must be 2 or 3\")\n        # Create output directory",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "timeseries",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def timeseries(terms: Optional[List[str]], timeframe: str, interval: str, output_dir: str, \n               casting_method: str, local: bool, pattern_type: str):\n    \"\"\"Generate time-series visualization showing term evolution over time. If no terms provided, uses I Ching-based temporal analysis.\"\"\"\n    try:\n        # Import required modules\n        from word_manifold.automata.hexagram_rules import (\n            create_hexagram_rules, cast_hexagram, get_default_text,\n            CastingMethod, DEFAULT_TEXTS\n        )\n        from word_manifold.embeddings.word_embeddings import WordEmbeddings",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "hexagrams",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "def hexagrams(text: Optional[str], output_dir: str, casting_method: str):\n    \"\"\"Generate hexagram-based visualizations for text transformations. If no text is provided, casts the oracle bones.\"\"\"\n    try:\n        # Import required modules\n        from word_manifold.automata.hexagram_rules import (\n            create_hexagram_rules, cast_hexagram, get_default_text,\n            CastingMethod\n        )\n        from word_manifold.visualization.hexagram_visualizer import HexagramVisualizer\n        from word_manifold.embeddings.word_embeddings import WordEmbeddings",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef lazy_import(module_name: str) -> Callable:\n    \"\"\"Lazily import a module only when needed.\"\"\"\n    def get_module():\n        import importlib\n        try:\n            return importlib.import_module(module_name)\n        except ImportError as e:\n            logger.error(f\"Failed to import {module_name}: {e}\")\n            raise click.ClickException(f\"Required module {module_name} not found. Please install required dependencies.\")",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_word_embeddings",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_word_embeddings = lazy_import('word_manifold.embeddings.word_embeddings')\nget_vector_manifold = lazy_import('word_manifold.manifold.vector_manifold')\nget_hypertools = lazy_import('word_manifold.visualization.hypertools_visualizer')\nget_shape_vis = lazy_import('word_manifold.visualization.shape_visualizer')\nget_symbolic_vis = lazy_import('word_manifold.visualization.symbolic_visualizer')\nget_semantic_tree = lazy_import('word_manifold.visualization.semantic_tree_visualizer')\nget_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_vector_manifold",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_vector_manifold = lazy_import('word_manifold.manifold.vector_manifold')\nget_hypertools = lazy_import('word_manifold.visualization.hypertools_visualizer')\nget_shape_vis = lazy_import('word_manifold.visualization.shape_visualizer')\nget_symbolic_vis = lazy_import('word_manifold.visualization.symbolic_visualizer')\nget_semantic_tree = lazy_import('word_manifold.visualization.semantic_tree_visualizer')\nget_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_hypertools",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_hypertools = lazy_import('word_manifold.visualization.hypertools_visualizer')\nget_shape_vis = lazy_import('word_manifold.visualization.shape_visualizer')\nget_symbolic_vis = lazy_import('word_manifold.visualization.symbolic_visualizer')\nget_semantic_tree = lazy_import('word_manifold.visualization.semantic_tree_visualizer')\nget_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\n# Progress bar support (lightweight)",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_shape_vis",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_shape_vis = lazy_import('word_manifold.visualization.shape_visualizer')\nget_symbolic_vis = lazy_import('word_manifold.visualization.symbolic_visualizer')\nget_semantic_tree = lazy_import('word_manifold.visualization.semantic_tree_visualizer')\nget_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\n# Progress bar support (lightweight)\ntry:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_symbolic_vis",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_symbolic_vis = lazy_import('word_manifold.visualization.symbolic_visualizer')\nget_semantic_tree = lazy_import('word_manifold.visualization.semantic_tree_visualizer')\nget_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_semantic_tree",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_semantic_tree = lazy_import('word_manifold.visualization.semantic_tree_visualizer')\nget_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm\nexcept ImportError:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_manifold_vis",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_manifold_vis = lazy_import('word_manifold.visualization.manifold_vis')\nget_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm\nexcept ImportError:\n    # Fallback progress bar if tqdm not available",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_interactive_vis",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_interactive_vis = lazy_import('word_manifold.visualization.interactive')\nget_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm\nexcept ImportError:\n    # Fallback progress bar if tqdm not available\n    class tqdm:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_cellular_rules",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_cellular_rules = lazy_import('word_manifold.automata.cellular_rules')\nget_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm\nexcept ImportError:\n    # Fallback progress bar if tqdm not available\n    class tqdm:\n        def __init__(self, *args, **kwargs):",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_server",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_server = lazy_import('word_manifold.visualization.server')\nget_remote_server = lazy_import('word_manifold.visualization.remote_server')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm\nexcept ImportError:\n    # Fallback progress bar if tqdm not available\n    class tqdm:\n        def __init__(self, *args, **kwargs):\n            pass",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "get_remote_server",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "get_remote_server = lazy_import('word_manifold.visualization.remote_server')\n# Progress bar support (lightweight)\ntry:\n    from tqdm import tqdm\nexcept ImportError:\n    # Fallback progress bar if tqdm not available\n    class tqdm:\n        def __init__(self, *args, **kwargs):\n            pass\n        def __enter__(self):",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "DEFAULT_HOST",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "DEFAULT_HOST = 'localhost'\nDEFAULT_PORT = 5000\nDEFAULT_TIMEOUTS = {\n    'server': 15,      # Default server request timeout\n    'health': 5,       # Health check timeout\n    'shutdown': 10,    # Graceful shutdown timeout\n    'startup': 30,     # Server startup timeout\n    'process': 5,      # Process operation timeout\n}\nSERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PORT",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "DEFAULT_PORT = 5000\nDEFAULT_TIMEOUTS = {\n    'server': 15,      # Default server request timeout\n    'health': 5,       # Health check timeout\n    'shutdown': 10,    # Graceful shutdown timeout\n    'startup': 30,     # Server startup timeout\n    'process': 5,      # Process operation timeout\n}\nSERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n# Default configuration",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TIMEOUTS",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "DEFAULT_TIMEOUTS = {\n    'server': 15,      # Default server request timeout\n    'health': 5,       # Health check timeout\n    'shutdown': 10,    # Graceful shutdown timeout\n    'startup': 30,     # Server startup timeout\n    'process': 5,      # Process operation timeout\n}\nSERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n# Default configuration\nDEFAULT_CONFIG = {",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "SERVER_URL",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "SERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n# Default configuration\nDEFAULT_CONFIG = {\n    'server': {\n        'host': DEFAULT_HOST,\n        'port': DEFAULT_PORT,\n        'timeout': DEFAULT_TIMEOUTS['server'],\n        'max_workers': 4,\n        'request_queue_size': 100,\n        'max_connections': 1000,",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "DEFAULT_CONFIG",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "DEFAULT_CONFIG = {\n    'server': {\n        'host': DEFAULT_HOST,\n        'port': DEFAULT_PORT,\n        'timeout': DEFAULT_TIMEOUTS['server'],\n        'max_workers': 4,\n        'request_queue_size': 100,\n        'max_connections': 1000,\n        'shutdown_timeout': DEFAULT_TIMEOUTS['shutdown'],\n    },",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "config = load_config(Path('word_manifold.yaml'))\nDEFAULT_HOST = config['server']['host']\nDEFAULT_PORT = config['server']['port']\nSERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=4, max=10),\n    retry=retry_if_exception_type((requests.exceptions.Timeout, requests.exceptions.ConnectionError))\n)\ndef handle_server_request(method: str, endpoint: str, data: Dict[str, Any] = None, timeout: int = DEFAULT_TIMEOUTS['server']) -> Dict[str, Any]:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "DEFAULT_HOST",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "DEFAULT_HOST = config['server']['host']\nDEFAULT_PORT = config['server']['port']\nSERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=4, max=10),\n    retry=retry_if_exception_type((requests.exceptions.Timeout, requests.exceptions.ConnectionError))\n)\ndef handle_server_request(method: str, endpoint: str, data: Dict[str, Any] = None, timeout: int = DEFAULT_TIMEOUTS['server']) -> Dict[str, Any]:\n    \"\"\"Handle server request with proper error handling and retries.\"\"\"",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PORT",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "DEFAULT_PORT = config['server']['port']\nSERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=4, max=10),\n    retry=retry_if_exception_type((requests.exceptions.Timeout, requests.exceptions.ConnectionError))\n)\ndef handle_server_request(method: str, endpoint: str, data: Dict[str, Any] = None, timeout: int = DEFAULT_TIMEOUTS['server']) -> Dict[str, Any]:\n    \"\"\"Handle server request with proper error handling and retries.\"\"\"\n    try:",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "SERVER_URL",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.cli",
        "description": "src.word_manifold.visualization.cli",
        "peekOfCode": "SERVER_URL = f'http://{DEFAULT_HOST}:{DEFAULT_PORT}'\n@retry(\n    stop=stop_after_attempt(3),\n    wait=wait_exponential(multiplier=1, min=4, max=10),\n    retry=retry_if_exception_type((requests.exceptions.Timeout, requests.exceptions.ConnectionError))\n)\ndef handle_server_request(method: str, endpoint: str, data: Dict[str, Any] = None, timeout: int = DEFAULT_TIMEOUTS['server']) -> Dict[str, Any]:\n    \"\"\"Handle server request with proper error handling and retries.\"\"\"\n    try:\n        if method.upper() == 'GET':",
        "detail": "src.word_manifold.visualization.cli",
        "documentation": {}
    },
    {
        "label": "HexagramVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.hexagram_visualizer",
        "description": "src.word_manifold.visualization.hexagram_visualizer",
        "peekOfCode": "class HexagramVisualizer:\n    \"\"\"Visualizer for hexagram-based transformations.\"\"\"\n    # Visual constants\n    LINE_LENGTH = 1.0\n    LINE_SPACING = 0.3\n    YIN_GAP = 0.2\n    LINE_THICKNESS = 0.1\n    # Colors for different aspects\n    COLORS = {\n        'yang': '#E74C3C',  # Red for yang energy",
        "detail": "src.word_manifold.visualization.hexagram_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.hexagram_visualizer",
        "description": "src.word_manifold.visualization.hexagram_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HexagramVisualizer:\n    \"\"\"Visualizer for hexagram-based transformations.\"\"\"\n    # Visual constants\n    LINE_LENGTH = 1.0\n    LINE_SPACING = 0.3\n    YIN_GAP = 0.2\n    LINE_THICKNESS = 0.1\n    # Colors for different aspects\n    COLORS = {",
        "detail": "src.word_manifold.visualization.hexagram_visualizer",
        "documentation": {}
    },
    {
        "label": "VisualizationLayer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.hypertools_visualizer",
        "description": "src.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "class VisualizationLayer:\n    \"\"\"A layer in the visualization stack.\"\"\"\n    def __init__(self, name: str, visible: bool = True):\n        self.name = name\n        self.visible = visible\n        self.data = {}\n        self.style = {}\n    def update(self, data: Dict[str, Any]) -> None:\n        \"\"\"Update layer data.\"\"\"\n        self.data.update(data)",
        "detail": "src.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "HyperToolsVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.hypertools_visualizer",
        "description": "src.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "class HyperToolsVisualizer:\n    \"\"\"Visualizer for high-dimensional data using HyperTools.\"\"\"\n    def __init__(self, \n                 word_embeddings: WordEmbeddings,\n                 output_dir: str = \"visualizations/hypertools\",\n                 interactive: bool = False,\n                 n_dimensions: int = 3,\n                 reduction_method: str = \"UMAP\",\n                 enable_sacred_geometry: bool = True,\n                 enable_audio: bool = False):",
        "detail": "src.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.hypertools_visualizer",
        "description": "src.word_manifold.visualization.hypertools_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Filter specific warnings\nwarnings.filterwarnings('ignore', category=FutureWarning, module='sklearn')\nwarnings.filterwarnings('ignore', category=UserWarning, module='umap')\nclass VisualizationLayer:\n    \"\"\"A layer in the visualization stack.\"\"\"\n    def __init__(self, name: str, visible: bool = True):\n        self.name = name\n        self.visible = visible\n        self.data = {}",
        "detail": "src.word_manifold.visualization.hypertools_visualizer",
        "documentation": {}
    },
    {
        "label": "InteractiveManifoldVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.interactive",
        "description": "src.word_manifold.visualization.interactive",
        "peekOfCode": "class InteractiveManifoldVisualizer(InteractiveVisualizer):\n    \"\"\"Interactive visualizer for manifold structures with parameter controls.\"\"\"\n    def __init__(self, embeddings: np.ndarray, terms: List[List[str]]):\n        \"\"\"Initialize interactive visualizer.\n        Args:\n            embeddings: Matrix of embeddings\n            terms: List of term lists for each embedding\n        \"\"\"\n        super().__init__()\n        self.embeddings = embeddings",
        "detail": "src.word_manifold.visualization.interactive",
        "documentation": {}
    },
    {
        "label": "ManifoldPlotData",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.manifold_vis",
        "description": "src.word_manifold.visualization.manifold_vis",
        "peekOfCode": "class ManifoldPlotData:\n    \"\"\"Container for manifold visualization data.\"\"\"\n    points: np.ndarray\n    embeddings: np.ndarray\n    terms: List[List[str]]\n    coherence: Optional[np.ndarray] = None\n    def to_plot_data(self) -> Dict[str, Any]:\n        \"\"\"Convert to plottable format.\"\"\"\n        return {\n            'points': self.points,",
        "detail": "src.word_manifold.visualization.manifold_vis",
        "documentation": {}
    },
    {
        "label": "ManifoldVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.manifold_vis",
        "description": "src.word_manifold.visualization.manifold_vis",
        "peekOfCode": "class ManifoldVisualizer(Visualizer):\n    \"\"\"Visualizer for manifold structures.\"\"\"\n    def __init__(self, embeddings: np.ndarray, terms: List[List[str]], n_components: int = 2):\n        \"\"\"Initialize visualizer.\n        Args:\n            embeddings: Matrix of embeddings\n            terms: List of term lists for each embedding\n            n_components: Number of visualization dimensions (2 or 3)\n        \"\"\"\n        super().__init__()",
        "detail": "src.word_manifold.visualization.manifold_vis",
        "documentation": {}
    },
    {
        "label": "RitualPhase",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.ritual_visualizer",
        "description": "src.word_manifold.visualization.ritual_visualizer",
        "peekOfCode": "class RitualPhase(Enum):\n    \"\"\"Phases of ritual transformation.\"\"\"\n    PREPARATION = auto()\n    INVOCATION = auto()\n    TRANSFORMATION = auto()\n    INTEGRATION = auto()\n    COMPLETION = auto()\n@dataclass\nclass RitualState:\n    \"\"\"Represents the current state of a ritual transformation.\"\"\"",
        "detail": "src.word_manifold.visualization.ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "RitualState",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.ritual_visualizer",
        "description": "src.word_manifold.visualization.ritual_visualizer",
        "peekOfCode": "class RitualState:\n    \"\"\"Represents the current state of a ritual transformation.\"\"\"\n    phase: RitualPhase\n    active_terms: Set[str]\n    transformed_terms: Set[str]\n    energy_level: float\n    resonance_pattern: Dict[HermeticPrinciple, float]\n    dominant_principle: HermeticPrinciple\n    timestamp: datetime\nclass RitualVisualizer:",
        "detail": "src.word_manifold.visualization.ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "RitualVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.ritual_visualizer",
        "description": "src.word_manifold.visualization.ritual_visualizer",
        "peekOfCode": "class RitualVisualizer:\n    \"\"\"\n    Visualizes ritual transformations by combining semantic, geometric,\n    and energetic aspects into cohesive visual representations.\n    \"\"\"\n    def __init__(\n        self,\n        word_embeddings: WordEmbeddings,\n        output_dir: str = \"visualizations/rituals\",\n        n_dims: int = 3,",
        "detail": "src.word_manifold.visualization.ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "SemanticNode",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.semantic_tree_visualizer",
        "description": "src.word_manifold.visualization.semantic_tree_visualizer",
        "peekOfCode": "class SemanticNode:\n    \"\"\"Represents a node in the semantic tree with hierarchical relationships.\"\"\"\n    def __init__(self, text: str, embedding: np.ndarray):\n        \"\"\"\n        Initialize a semantic node.\n        Args:\n            text: The text content of the node\n            embedding: The vector embedding of the text\n        \"\"\"\n        self.text = text",
        "detail": "src.word_manifold.visualization.semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "SemanticTreeVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.semantic_tree_visualizer",
        "description": "src.word_manifold.visualization.semantic_tree_visualizer",
        "peekOfCode": "class SemanticTreeVisualizer:\n    \"\"\"Visualizer for semantic trees with customizable appearance and layout.\"\"\"\n    def __init__(\n        self,\n        output_dir: str = \"visualizations/semantic_trees\",\n        model_name: str = \"sentence-transformers/all-mpnet-base-v2\",\n        color_scheme: str = \"viridis\",\n        node_size_base: int = 1000,\n        min_similarity: float = 0.3\n    ):",
        "detail": "src.word_manifold.visualization.semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.semantic_tree_visualizer",
        "description": "src.word_manifold.visualization.semantic_tree_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass SemanticNode:\n    \"\"\"Represents a node in the semantic tree with hierarchical relationships.\"\"\"\n    def __init__(self, text: str, embedding: np.ndarray):\n        \"\"\"\n        Initialize a semantic node.\n        Args:\n            text: The text content of the node\n            embedding: The vector embedding of the text\n        \"\"\"",
        "detail": "src.word_manifold.visualization.semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "add_security_headers",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "def add_security_headers(response):\n    \"\"\"Add security headers to all responses.\"\"\"\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, OPTIONS'\n    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'\n    return response\n_embeddings = None\n_visualizers: Dict[str, Any] = {}\n@app.route('/health', methods=['GET'])\ndef health_check():",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "health_check",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "def health_check():\n    \"\"\"Health check endpoint.\"\"\"\n    return jsonify({'status': 'healthy'})\ndef get_embeddings(model_name: str = 'sentence-transformers/all-MiniLM-L6-v2') -> WordEmbeddings:\n    \"\"\"Get or create embeddings instance.\"\"\"\n    global _embeddings\n    if _embeddings is None:\n        try:\n            logger.info(f\"Initializing embeddings with model {model_name}\")\n            _embeddings = WordEmbeddings(model_name=model_name)",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "get_embeddings",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "def get_embeddings(model_name: str = 'sentence-transformers/all-MiniLM-L6-v2') -> WordEmbeddings:\n    \"\"\"Get or create embeddings instance.\"\"\"\n    global _embeddings\n    if _embeddings is None:\n        try:\n            logger.info(f\"Initializing embeddings with model {model_name}\")\n            _embeddings = WordEmbeddings(model_name=model_name)\n        except Exception as e:\n            logger.error(f\"Error initializing embeddings: {str(e)}\\n{traceback.format_exc()}\")\n            raise",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "create_static_visualization",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "def create_static_visualization():\n    \"\"\"Create static manifold visualization.\"\"\"\n    try:\n        data = request.json\n        terms = data.get('terms', [])\n        model = data.get('model', 'sentence-transformers/all-MiniLM-L6-v2')\n        dimensions = data.get('dimensions', 2)\n        logger.info(f\"Creating static visualization for terms: {terms}\")\n        # Get embeddings\n        embeddings = get_embeddings(model)",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "create_interactive_visualization",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "def create_interactive_visualization():\n    \"\"\"Create interactive visualization session.\"\"\"\n    try:\n        data = request.json\n        terms = data.get('terms', [])\n        model = data.get('model', 'sentence-transformers/all-MiniLM-L6-v2')\n        dimensions = data.get('dimensions', 2)\n        logger.info(f\"Creating interactive visualization for terms: {terms}\")\n        # Get embeddings\n        embeddings = get_embeddings(model)",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "update_interactive_visualization",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "def update_interactive_visualization():\n    \"\"\"Update interactive visualization state.\"\"\"\n    try:\n        data = request.json\n        session_id = data.get('session_id')\n        state = data.get('state', {})\n        logger.info(f\"Updating visualization for session: {session_id}\")\n        if session_id not in _visualizers:\n            logger.error(f\"Invalid session ID: {session_id}\")\n            return jsonify({'error': 'Invalid session ID'}), 404",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "close_interactive_visualization",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "def close_interactive_visualization():\n    \"\"\"Close interactive visualization session.\"\"\"\n    try:\n        data = request.json\n        session_id = data.get('session_id')\n        logger.info(f\"Closing visualization session: {session_id}\")\n        if session_id in _visualizers:\n            visualizer = _visualizers[session_id]\n            visualizer.close()\n            del _visualizers[session_id]",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "run_server",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "def run_server(host: str = 'localhost', port: int = 5000, debug: bool = False):\n    \"\"\"Run the visualization server.\n    Args:\n        host: Host address to bind to\n        port: Port to listen on\n        debug: Whether to run in debug mode\n    \"\"\"\n    logger.info(f\"Starting visualization server on {host}:{port} (debug={debug})\")\n    if debug:\n        # Enable more detailed Flask logging",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "logger = logging.getLogger(__name__)\napp = Flask(__name__)\nCORS(app)  # Enable CORS for all routes\n# Security headers\n@app.after_request\ndef add_security_headers(response):\n    \"\"\"Add security headers to all responses.\"\"\"\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, OPTIONS'\n    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "app = Flask(__name__)\nCORS(app)  # Enable CORS for all routes\n# Security headers\n@app.after_request\ndef add_security_headers(response):\n    \"\"\"Add security headers to all responses.\"\"\"\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    response.headers['Access-Control-Allow-Methods'] = 'GET, POST, OPTIONS'\n    response.headers['Access-Control-Allow-Headers'] = 'Content-Type'\n    return response",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "_embeddings",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.server",
        "description": "src.word_manifold.visualization.server",
        "peekOfCode": "_embeddings = None\n_visualizers: Dict[str, Any] = {}\n@app.route('/health', methods=['GET'])\ndef health_check():\n    \"\"\"Health check endpoint.\"\"\"\n    return jsonify({'status': 'healthy'})\ndef get_embeddings(model_name: str = 'sentence-transformers/all-MiniLM-L6-v2') -> WordEmbeddings:\n    \"\"\"Get or create embeddings instance.\"\"\"\n    global _embeddings\n    if _embeddings is None:",
        "detail": "src.word_manifold.visualization.server",
        "documentation": {}
    },
    {
        "label": "ExportConfig",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.shape_visualizer",
        "description": "src.word_manifold.visualization.shape_visualizer",
        "peekOfCode": "class ExportConfig:\n    \"\"\"Configuration for exporting visualizations.\"\"\"\n    def __init__(\n        self,\n        format: str = \"mp4\",\n        dpi: int = 300,\n        fps: int = 60,\n        bitrate: int = 2000,\n        save_frames: bool = True,\n        output_dir: Optional[str] = None",
        "detail": "src.word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "ShapeVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.shape_visualizer",
        "description": "src.word_manifold.visualization.shape_visualizer",
        "peekOfCode": "class ShapeVisualizer:\n    \"\"\"\n    Advanced visualization class for semantic shapes with enhanced visual encoding.\n    \"\"\"\n    def __init__(\n        self,\n        color_scheme: str = \"semantic\",\n        use_textures: bool = True,\n        export_config: Optional[ExportConfig] = None\n    ):",
        "detail": "src.word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.shape_visualizer",
        "description": "src.word_manifold.visualization.shape_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)  # Default to INFO level\n# Create formatters and handlers if they don't exist\nif not logger.handlers:\n    # Create console handler with formatting\n    console_handler = logging.StreamHandler()\n    console_handler.setLevel(logging.INFO)\n    console_formatter = logging.Formatter(\n        '%(asctime)s - %(name)s - [%(levelname)s] - %(message)s'\n    )",
        "detail": "src.word_manifold.visualization.shape_visualizer",
        "documentation": {}
    },
    {
        "label": "SymbolicPattern",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.symbolic_visualizer",
        "description": "src.word_manifold.visualization.symbolic_visualizer",
        "peekOfCode": "class SymbolicPattern:\n    \"\"\"A pattern of symbols that can transform.\"\"\"\n    base_symbols: str  # Core symbols that make up the pattern\n    transformations: List[str]  # Sequence of transformation states\n    meaning: str  # Semantic meaning of the pattern\n    energy: float  # Current energy level (affects transformation rate)\n    resonance: Set[str]  # Terms that resonate with this pattern\n    def __repr__(self) -> str:\n        \"\"\"String representation of the pattern.\"\"\"\n        return f\"SymbolicPattern(meaning='{self.meaning}', energy={self.energy:.2f}, n_transforms={len(self.transformations)})\"",
        "detail": "src.word_manifold.visualization.symbolic_visualizer",
        "documentation": {}
    },
    {
        "label": "SymbolicVisualizer",
        "kind": 6,
        "importPath": "src.word_manifold.visualization.symbolic_visualizer",
        "description": "src.word_manifold.visualization.symbolic_visualizer",
        "peekOfCode": "class SymbolicVisualizer:\n    \"\"\"Creates living ASCII mandalas from semantic spaces.\"\"\"\n    # Symbol sets for different semantic qualities\n    ABSTRACT_SYMBOLS: str = \"◇○□△▽⬡⬢⬣\"  # Abstract concepts\n    ORGANIC_SYMBOLS: str = \"~≈≋∿☘❀❁❃\"    # Natural/flowing concepts\n    TECH_SYMBOLS: str = \"⌘⌥⌦⌬⌸⌹⍋⍚\"       # Technological concepts\n    SACRED_SYMBOLS: str = \"☯☮✴✵✶✷\"      # Spiritual concepts\n    EMOTIONAL_SYMBOLS: str = \"♡♢♤♧♪♫\"    # Emotional concepts\n    def __init__(\n        self, ",
        "detail": "src.word_manifold.visualization.symbolic_visualizer",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.word_manifold.visualization.symbolic_visualizer",
        "description": "src.word_manifold.visualization.symbolic_visualizer",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass SymbolicPattern:\n    \"\"\"A pattern of symbols that can transform.\"\"\"\n    base_symbols: str  # Core symbols that make up the pattern\n    transformations: List[str]  # Sequence of transformation states\n    meaning: str  # Semantic meaning of the pattern\n    energy: float  # Current energy level (affects transformation rate)\n    resonance: Set[str]  # Terms that resonate with this pattern\n    def __repr__(self) -> str:",
        "detail": "src.word_manifold.visualization.symbolic_visualizer",
        "documentation": {}
    },
    {
        "label": "create_color_gradient",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.utils",
        "description": "src.word_manifold.visualization.utils",
        "peekOfCode": "def create_color_gradient(n_colors: int, start_color: str = '#1f77b4', end_color: str = '#ff7f0e') -> Colormap:\n    \"\"\"Create a continuous color gradient between two colors.\n    Args:\n        n_colors: Number of colors in gradient\n        start_color: Starting hex color code\n        end_color: Ending hex color code\n    Returns:\n        matplotlib colormap\n    \"\"\"\n    return LinearSegmentedColormap.from_list('custom', [start_color, end_color], N=n_colors)",
        "detail": "src.word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "scale_coordinates",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.utils",
        "description": "src.word_manifold.visualization.utils",
        "peekOfCode": "def scale_coordinates(coords: np.ndarray, scale: float = 1.0) -> np.ndarray:\n    \"\"\"Scale coordinates to specified range while preserving relative distances.\n    Args:\n        coords: Array of coordinates to scale\n        scale: Scale factor to apply\n    Returns:\n        Scaled coordinates array\n    \"\"\"\n    scaler = MinMaxScaler(feature_range=(-scale, scale))\n    return scaler.fit_transform(coords)",
        "detail": "src.word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "calculate_marker_sizes",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.utils",
        "description": "src.word_manifold.visualization.utils",
        "peekOfCode": "def calculate_marker_sizes(\n    values: np.ndarray,\n    min_size: float = 20.0,\n    max_size: float = 200.0\n) -> np.ndarray:\n    \"\"\"Calculate marker sizes based on values.\n    Args:\n        values: Array of values to map to sizes\n        min_size: Minimum marker size\n        max_size: Maximum marker size",
        "detail": "src.word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "create_subplot_grid",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.utils",
        "description": "src.word_manifold.visualization.utils",
        "peekOfCode": "def create_subplot_grid(\n    n_plots: int,\n    max_cols: int = 3\n) -> Tuple[plt.Figure, np.ndarray]:\n    \"\"\"Create a grid of subplots.\n    Args:\n        n_plots: Number of plots needed\n        max_cols: Maximum number of columns\n    Returns:\n        Figure and array of axes",
        "detail": "src.word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "add_colorbar",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.utils",
        "description": "src.word_manifold.visualization.utils",
        "peekOfCode": "def add_colorbar(\n    fig: plt.Figure,\n    mappable: Any,\n    label: str,\n    orientation: str = 'vertical'\n) -> None:\n    \"\"\"Add a colorbar to the figure.\n    Args:\n        fig: Figure to add colorbar to\n        mappable: The mappable object to create colorbar from",
        "detail": "src.word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "create_legend",
        "kind": 2,
        "importPath": "src.word_manifold.visualization.utils",
        "description": "src.word_manifold.visualization.utils",
        "peekOfCode": "def create_legend(\n    ax: plt.Axes,\n    labels: Dict[Any, str],\n    markers: Optional[Dict[Any, str]] = None,\n    colors: Optional[Dict[Any, str]] = None,\n    title: Optional[str] = None\n) -> None:\n    \"\"\"Add a legend to the axes.\n    Args:\n        ax: Axes to add legend to",
        "detail": "src.word_manifold.visualization.utils",
        "documentation": {}
    },
    {
        "label": "CellType",
        "kind": 6,
        "importPath": "src.word_manifold.types",
        "description": "src.word_manifold.types",
        "peekOfCode": "class CellType(Enum):\n    \"\"\"Types of cells with occult correspondences.\"\"\"\n    ELEMENTAL = auto()   # Corresponds to the four elements\n    PLANETARY = auto()   # Corresponds to planetary influences\n    ZODIACAL = auto()    # Corresponds to zodiac signs\n    TAROT = auto()       # Corresponds to tarot archetypes\n    SEPHIROTIC = auto()  # Corresponds to Kabbalistic sephiroth\n    OTHER = auto()       # Default/unclassified\nclass DistanceType(Enum):\n    \"\"\"Types of distance metrics for cell relationships.\"\"\"",
        "detail": "src.word_manifold.types",
        "documentation": {}
    },
    {
        "label": "DistanceType",
        "kind": 6,
        "importPath": "src.word_manifold.types",
        "description": "src.word_manifold.types",
        "peekOfCode": "class DistanceType(Enum):\n    \"\"\"Types of distance metrics for cell relationships.\"\"\"\n    EUCLIDEAN = auto()      # Standard Euclidean distance\n    COSINE = auto()         # Cosine distance (semantic similarity)\n    NUMEROLOGICAL = auto()  # Distance weighted by numerological values\n    HYBRID = auto()         # Combination of semantic and numerological",
        "detail": "src.word_manifold.types",
        "documentation": {}
    },
    {
        "label": "mock_manifold",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def mock_manifold():\n    \"\"\"Create a mock manifold for testing automata systems.\"\"\"\n    mock = Mock()\n    # Mock the cells attribute with some test data\n    mock.cells = {\n        0: Mock(centroid=np.zeros(10)),\n        1: Mock(centroid=np.zeros(10))\n    }\n    # Mock transform to return the same vectors\n    mock.transform = MagicMock(return_value=np.zeros((2, 10)))",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "base_embeddings",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def base_embeddings():\n    \"\"\"Create a WordEmbeddings instance with test terms.\"\"\"\n    embeddings = WordEmbeddings()\n    test_terms = {\n        \"thelema\", \"will\", \"love\", \"magick\", \"ritual\",\n        \"knowledge\", \"wisdom\", \"power\", \"light\", \"dark\"\n    }\n    embeddings.load_terms(test_terms)\n    return embeddings\n@pytest.fixture",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "base_system",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def base_system(mock_manifold):\n    \"\"\"Create a base AutomataSystem for testing.\"\"\"\n    from word_manifold.automata.cellular_rules import create_predefined_rules\n    rules = create_predefined_rules()\n    return AutomataSystem(\n        manifold=mock_manifold,\n        rules_dict=rules,\n        sequences_dict={},\n        evolution_pattern=EvolutionPattern.THELEMIC,\n        save_path=\"test_outputs\"",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "TestAutomataSystem",
        "kind": 6,
        "importPath": "tests.test_automata",
        "description": "tests.test_automata",
        "peekOfCode": "class TestAutomataSystem:\n    \"\"\"Tests for the AutomataSystem class.\"\"\"\n    def test_initialization(self, base_system, mock_manifold):\n        \"\"\"Test system initialization and basic properties.\"\"\"\n        assert base_system.manifold == mock_manifold\n        assert len(base_system.rules) > 0\n        assert base_system.generation == 0\n        assert base_system.evolution_pattern == EvolutionPattern.THELEMIC\n    def test_evolution_state(self, base_system):\n        \"\"\"Test evolution state management.\"\"\"",
        "detail": "tests.test_automata",
        "documentation": {}
    },
    {
        "label": "TestCellularRules",
        "kind": 6,
        "importPath": "tests.test_automata",
        "description": "tests.test_automata",
        "peekOfCode": "class TestCellularRules:\n    \"\"\"Tests for cellular automata rules.\"\"\"\n    def test_predefined_rules(self):\n        \"\"\"Test creation and properties of predefined rules.\"\"\"\n        rules = create_predefined_rules()\n        # Check basic rule properties\n        assert len(rules) > 0\n        for name, rule in rules.items():\n            assert isinstance(rule, CellularRule)\n            # assert rule.name in str(name).lower().replace(' ', '_')  # More flexible name matching",
        "detail": "tests.test_automata",
        "documentation": {}
    },
    {
        "label": "mock_manifold",
        "kind": 2,
        "importPath": "tests.test_automata",
        "description": "tests.test_automata",
        "peekOfCode": "def mock_manifold():\n    mock = Mock()\n    # Mock the cells attribute with some test data\n    mock.cells = {\n        0: Mock(centroid=np.zeros(10)),\n        1: Mock(centroid=np.zeros(10))\n    }\n    # Mock transform to return the same vectors\n    mock.transform = MagicMock(return_value=np.zeros((2, 10)))\n    # Mock get_manifold_state to return a valid state",
        "detail": "tests.test_automata",
        "documentation": {}
    },
    {
        "label": "base_system",
        "kind": 2,
        "importPath": "tests.test_automata",
        "description": "tests.test_automata",
        "peekOfCode": "def base_system(mock_manifold):\n    rules = create_predefined_rules()\n    return AutomataSystem(\n        manifold=mock_manifold,\n        rules_dict=rules,\n        sequences_dict={},\n        evolution_pattern=EvolutionPattern.THELEMIC,\n        save_path=\"test_outputs\"\n    )\nclass TestAutomataSystem:",
        "detail": "tests.test_automata",
        "documentation": {}
    },
    {
        "label": "TestCell",
        "kind": 6,
        "importPath": "tests.test_core_components",
        "description": "tests.test_core_components",
        "peekOfCode": "class TestCell:\n    \"\"\"Tests for the Cell data structure.\"\"\"\n    def test_cell_creation(self):\n        \"\"\"Test Cell dataclass creation and basic properties.\"\"\"\n        cell = Cell(\n            id=1,\n            terms=[\"thelema\", \"will\"],\n            centroid=np.array([0.1, 0.2, 0.3]),\n            type=CellType.TAROT,\n            numerological_value=93",
        "detail": "tests.test_core_components",
        "documentation": {}
    },
    {
        "label": "TestVectorManifold",
        "kind": 6,
        "importPath": "tests.test_core_components",
        "description": "tests.test_core_components",
        "peekOfCode": "class TestVectorManifold:\n    \"\"\"Tests for the VectorManifold class.\"\"\"\n    def test_initialization(self, base_embeddings):\n        \"\"\"Test VectorManifold initialization and basic properties.\"\"\"\n        manifold = VectorManifold(base_embeddings)\n        # Check basic properties\n        assert manifold.term_to_index is not None\n        assert len(manifold.term_to_index) == len(base_embeddings.terms)\n        assert manifold.n_cells == 22  # Default value\n        assert manifold.reduction_dims == 3  # Default value",
        "detail": "tests.test_core_components",
        "documentation": {}
    },
    {
        "label": "TestWordEmbeddings",
        "kind": 6,
        "importPath": "tests.test_core_components",
        "description": "tests.test_core_components",
        "peekOfCode": "class TestWordEmbeddings:\n    \"\"\"Tests for the WordEmbeddings class.\"\"\"\n    def test_initialization(self):\n        \"\"\"Test WordEmbeddings initialization.\"\"\"\n        embeddings = WordEmbeddings()\n        assert embeddings.model is not None\n        assert embeddings.tokenizer is not None\n        assert len(embeddings.terms) == 0\n    def test_term_loading(self, base_embeddings):\n        \"\"\"Test loading terms and computing embeddings.\"\"\"",
        "detail": "tests.test_core_components",
        "documentation": {}
    },
    {
        "label": "word_embeddings",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def word_embeddings():\n    \"\"\"Create a WordEmbeddings instance for testing.\"\"\"\n    embeddings = WordEmbeddings(model_name=\"all-MiniLM-L6-v2\")\n    test_terms = [\"light\", \"wisdom\", \"truth\", \"love\", \"power\"]\n    embeddings.load_terms(test_terms)\n    return embeddings\n@pytest.fixture\ndef test_output_dir(tmp_path):\n    \"\"\"Create a temporary directory for test outputs.\"\"\"\n    output_dir = tmp_path / \"test_ritual_viz\"",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_output_dir",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_output_dir(tmp_path):\n    \"\"\"Create a temporary directory for test outputs.\"\"\"\n    output_dir = tmp_path / \"test_ritual_viz\"\n    output_dir.mkdir(exist_ok=True)\n    return str(output_dir)\n@pytest.fixture\ndef ritual_visualizer(word_embeddings, test_output_dir):\n    \"\"\"Create a RitualVisualizer instance for testing.\"\"\"\n    return RitualVisualizer(\n        word_embeddings=word_embeddings,",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "ritual_visualizer",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def ritual_visualizer(word_embeddings, test_output_dir):\n    \"\"\"Create a RitualVisualizer instance for testing.\"\"\"\n    return RitualVisualizer(\n        word_embeddings=word_embeddings,\n        output_dir=test_output_dir,\n        n_dims=3,\n        frame_duration=100,  # Faster for testing\n        energy_threshold=0.7,\n        resonance_threshold=0.8\n    )",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_initialization",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_initialization(ritual_visualizer, test_output_dir):\n    \"\"\"Test proper initialization of RitualVisualizer.\"\"\"\n    assert ritual_visualizer.output_dir == test_output_dir\n    assert ritual_visualizer.n_dims == 3\n    assert ritual_visualizer.frame_duration == 100\n    assert ritual_visualizer.energy_threshold == 0.7\n    assert ritual_visualizer.resonance_threshold == 0.8\n    assert os.path.exists(test_output_dir)\n    assert isinstance(ritual_visualizer.states, list)\n    assert isinstance(ritual_visualizer.term_evolution, dict)",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_process_transformation",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_process_transformation(ritual_visualizer):\n    \"\"\"Test processing of term transformations.\"\"\"\n    initial_terms = {\"light\", \"wisdom\"}\n    transformed_terms = {\"illumination\", \"understanding\"}\n    ritual_visualizer.process_transformation(\n        initial_terms,\n        transformed_terms,\n        RitualPhase.TRANSFORMATION\n    )\n    assert len(ritual_visualizer.states) == 1",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_calculate_energy_levels",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_calculate_energy_levels(ritual_visualizer):\n    \"\"\"Test energy level calculations.\"\"\"\n    terms = {\"light\", \"wisdom\", \"truth\"}\n    energy = ritual_visualizer._calculate_energy_level(terms)\n    assert isinstance(energy, float)\n    assert 0 <= energy <= 1\ndef test_determine_resonance(ritual_visualizer):\n    \"\"\"Test resonance pattern determination.\"\"\"\n    terms = {\"light\", \"wisdom\", \"truth\"}\n    resonance = ritual_visualizer._determine_resonance_pattern(terms)",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_determine_resonance",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_determine_resonance(ritual_visualizer):\n    \"\"\"Test resonance pattern determination.\"\"\"\n    terms = {\"light\", \"wisdom\", \"truth\"}\n    resonance = ritual_visualizer._determine_resonance_pattern(terms)\n    assert isinstance(resonance, dict)\n    assert all(isinstance(k, HermeticPrinciple) for k in resonance.keys())\n    assert all(isinstance(v, float) for v in resonance.values())\n    assert all(0 <= v <= 1 for v in resonance.values())\ndef test_identify_dominant_principle(ritual_visualizer):\n    \"\"\"Test dominant principle identification.\"\"\"",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_identify_dominant_principle",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_identify_dominant_principle(ritual_visualizer):\n    \"\"\"Test dominant principle identification.\"\"\"\n    terms = {\"light\", \"wisdom\", \"truth\"}\n    principle = ritual_visualizer._identify_dominant_principle(terms)\n    assert isinstance(principle, HermeticPrinciple)\ndef test_generate_visualization(ritual_visualizer, test_output_dir):\n    \"\"\"Test visualization generation.\"\"\"\n    # Process a few transformations\n    initial = {\"light\", \"wisdom\"}\n    transformed = {\"illumination\", \"understanding\"}",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_generate_visualization",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_generate_visualization(ritual_visualizer, test_output_dir):\n    \"\"\"Test visualization generation.\"\"\"\n    # Process a few transformations\n    initial = {\"light\", \"wisdom\"}\n    transformed = {\"illumination\", \"understanding\"}\n    final = {\"enlightenment\", \"knowledge\"}\n    ritual_visualizer.process_transformation(initial, transformed, RitualPhase.PREPARATION)\n    ritual_visualizer.process_transformation(transformed, final, RitualPhase.TRANSFORMATION)\n    # Generate visualization\n    output_path = ritual_visualizer.generate_visualization()",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_error_handling",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_error_handling(ritual_visualizer):\n    \"\"\"Test error handling for invalid inputs.\"\"\"\n    # Empty term sets\n    with pytest.raises(ValueError):\n        ritual_visualizer.process_transformation(set(), {\"light\"}, RitualPhase.PREPARATION)\n    with pytest.raises(ValueError):\n        ritual_visualizer.process_transformation({\"light\"}, set(), RitualPhase.PREPARATION)\n    # Invalid terms\n    with pytest.raises(ValueError):\n        ritual_visualizer.process_transformation(",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "test_state_tracking",
        "kind": 2,
        "importPath": "tests.test_ritual_visualizer",
        "description": "tests.test_ritual_visualizer",
        "peekOfCode": "def test_state_tracking(ritual_visualizer):\n    \"\"\"Test proper tracking of ritual state history.\"\"\"\n    transformations = [\n        ({\"light\"}, {\"illumination\"}, RitualPhase.PREPARATION),\n        ({\"illumination\"}, {\"enlightenment\"}, RitualPhase.TRANSFORMATION),\n        ({\"enlightenment\"}, {\"wisdom\"}, RitualPhase.INTEGRATION)\n    ]\n    for initial, transformed, phase in transformations:\n        ritual_visualizer.process_transformation(initial, transformed, phase)\n    assert len(ritual_visualizer.states) == len(transformations)",
        "detail": "tests.test_ritual_visualizer",
        "documentation": {}
    },
    {
        "label": "visualizer",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def visualizer():\n    \"\"\"Create a test visualizer instance.\"\"\"\n    return SemanticTreeVisualizer(\n        output_dir=\"test_outputs/semantic_trees\",\n        color_scheme=\"viridis\",\n        node_size_base=800,\n        min_similarity=0.3\n    )\n@pytest.fixture\ndef sample_embedding():",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "sample_embedding",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def sample_embedding():\n    \"\"\"Create a sample embedding vector.\"\"\"\n    return np.random.rand(768)  # Common embedding dimension\ndef test_semantic_node_creation(sample_embedding):\n    \"\"\"Test creation of semantic nodes.\"\"\"\n    node = SemanticNode(\"test\", sample_embedding)\n    assert node.text == \"test\"\n    assert node.level == 0\n    assert node.parent is None\n    assert len(node.children) == 0",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_semantic_node_creation",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_semantic_node_creation(sample_embedding):\n    \"\"\"Test creation of semantic nodes.\"\"\"\n    node = SemanticNode(\"test\", sample_embedding)\n    assert node.text == \"test\"\n    assert node.level == 0\n    assert node.parent is None\n    assert len(node.children) == 0\n    assert node.similarity_to_parent == 1.0\n    assert node.semantic_weight == 1.0\ndef test_semantic_node_child_addition(sample_embedding):",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_semantic_node_child_addition",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_semantic_node_child_addition(sample_embedding):\n    \"\"\"Test adding child nodes.\"\"\"\n    parent = SemanticNode(\"parent\", sample_embedding)\n    child = SemanticNode(\"child\", sample_embedding)\n    parent.add_child(child, similarity=0.8)\n    assert len(parent.children) == 1\n    assert child.parent == parent\n    assert child.level == 1\n    assert child.similarity_to_parent == 0.8\ndef test_semantic_weight_calculation(sample_embedding):",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_semantic_weight_calculation",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_semantic_weight_calculation(sample_embedding):\n    \"\"\"Test semantic weight calculation.\"\"\"\n    root = SemanticNode(\"root\", sample_embedding)\n    child = SemanticNode(\"child\", sample_embedding)\n    grandchild = SemanticNode(\"grandchild\", sample_embedding)\n    root.add_child(child, similarity=0.8)\n    child.add_child(grandchild, similarity=0.7)\n    assert root.calculate_semantic_weight() == 1.0\n    assert abs(child.calculate_semantic_weight() - 0.8 * 0.8) < 1e-6\n    assert abs(grandchild.calculate_semantic_weight() - 0.8 * 0.7 * 0.8 * 0.8) < 1e-6",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_visualizer_initialization",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_visualizer_initialization(visualizer):\n    \"\"\"Test visualizer initialization.\"\"\"\n    assert os.path.exists(visualizer.output_dir)\n    assert visualizer.color_scheme == \"viridis\"\n    assert visualizer.node_size_base == 800\n    assert visualizer.min_similarity == 0.3\ndef test_tree_building(visualizer):\n    \"\"\"Test building a semantic tree.\"\"\"\n    root = visualizer.build_semantic_tree(\n        root_text=\"machine learning\",",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_tree_building",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_tree_building(visualizer):\n    \"\"\"Test building a semantic tree.\"\"\"\n    root = visualizer.build_semantic_tree(\n        root_text=\"machine learning\",\n        related_terms=[\n            \"neural networks\",\n            \"deep learning\",\n            \"artificial intelligence\",\n            \"data science\"\n        ],",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_tree_visualization",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_tree_visualization(visualizer):\n    \"\"\"Test tree visualization.\"\"\"\n    root = visualizer.build_semantic_tree(\n        root_text=\"python\",\n        related_terms=[\n            \"programming\",\n            \"coding\",\n            \"software\",\n            \"development\"\n        ],",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_minimum_similarity_threshold",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_minimum_similarity_threshold(visualizer):\n    \"\"\"Test minimum similarity threshold.\"\"\"\n    visualizer.min_similarity = 0.9  # Set very high threshold\n    root = visualizer.build_semantic_tree(\n        root_text=\"test\",\n        related_terms=[\"unrelated1\", \"unrelated2\"],\n        max_depth=2,\n        branching_factor=2\n    )\n    # Should have no children due to high similarity threshold",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "test_invalid_terms_handling",
        "kind": 2,
        "importPath": "tests.test_semantic_tree_visualizer",
        "description": "tests.test_semantic_tree_visualizer",
        "peekOfCode": "def test_invalid_terms_handling(visualizer):\n    \"\"\"Test handling of invalid terms.\"\"\"\n    root = visualizer.build_semantic_tree(\n        root_text=\"test\",\n        related_terms=[\"\", \"   \", None],  # Invalid terms\n        max_depth=2,\n        branching_factor=2\n    )\n    # Should create root node without children\n    assert root.text == \"test\"",
        "detail": "tests.test_semantic_tree_visualizer",
        "documentation": {}
    },
    {
        "label": "MockVisualizationData",
        "kind": 6,
        "importPath": "tests.test_visualization",
        "description": "tests.test_visualization",
        "peekOfCode": "class MockVisualizationData:\n    \"\"\"Mock visualization data for testing.\"\"\"\n    def __init__(self, points, labels, colors):\n        self.points = points\n        self.labels = labels\n        self.colors = colors\n    def to_plot_data(self):\n        return {'points': self.points}\n    def get_color_map(self):\n        return self.colors",
        "detail": "tests.test_visualization",
        "documentation": {}
    },
    {
        "label": "MockVisualizer",
        "kind": 6,
        "importPath": "tests.test_visualization",
        "description": "tests.test_visualization",
        "peekOfCode": "class MockVisualizer(Visualizer):\n    \"\"\"Mock visualizer for testing.\"\"\"\n    def prepare_data(self):\n        points = np.array([[1, 2], [3, 4]])\n        labels = {0: 'A', 1: 'B'}\n        colors = {'A': 'red', 'B': 'blue'}\n        return MockVisualizationData(points, labels, colors)\n    def plot(self, data):\n        fig = Figure()\n        ax = fig.add_subplot(111)",
        "detail": "tests.test_visualization",
        "documentation": {}
    },
    {
        "label": "test_visualizer_base",
        "kind": 2,
        "importPath": "tests.test_visualization",
        "description": "tests.test_visualization",
        "peekOfCode": "def test_visualizer_base():\n    \"\"\"Test base visualizer functionality.\"\"\"\n    vis = MockVisualizer()\n    # Test data preparation\n    data = vis.prepare_data()\n    assert isinstance(data, VisualizationData)\n    assert 'points' in data.to_plot_data()\n    # Test plotting\n    fig = vis.plot(data)\n    assert isinstance(fig, Figure)",
        "detail": "tests.test_visualization",
        "documentation": {}
    },
    {
        "label": "test_manifold_visualizer",
        "kind": 2,
        "importPath": "tests.test_visualization",
        "description": "tests.test_visualization",
        "peekOfCode": "def test_manifold_visualizer():\n    \"\"\"Test manifold visualizer functionality.\"\"\"\n    # Create test data\n    embeddings = np.random.randn(10, 5)\n    terms = [['cat', 'feline'], ['dog', 'canine'], ['bird', 'avian']] * 3 + ['fish']\n    vis = ManifoldVisualizer(embeddings, terms)\n    # Test data preparation\n    data = vis.prepare_data()\n    assert isinstance(data, ManifoldPlotData)\n    plot_data = data.to_plot_data()",
        "detail": "tests.test_visualization",
        "documentation": {}
    },
    {
        "label": "test_interactive_visualizer",
        "kind": 2,
        "importPath": "tests.test_visualization",
        "description": "tests.test_visualization",
        "peekOfCode": "def test_interactive_visualizer():\n    \"\"\"Test interactive visualizer functionality.\"\"\"\n    embeddings = np.random.randn(5, 3)\n    terms = [['term1'], ['term2'], ['term3'], ['term4'], ['term5']]\n    vis = InteractiveManifoldVisualizer(embeddings, terms)\n    # Test data preparation\n    data = vis.prepare_data()\n    assert isinstance(data, ManifoldPlotData)\n    # Test initial state\n    state = vis.get_state()",
        "detail": "tests.test_visualization",
        "documentation": {}
    },
    {
        "label": "test_visualization_utils",
        "kind": 2,
        "importPath": "tests.test_visualization",
        "description": "tests.test_visualization",
        "peekOfCode": "def test_visualization_utils():\n    \"\"\"Test visualization utility functions.\"\"\"\n    # Test color gradient\n    cmap = create_color_gradient(10)\n    assert len(cmap.colors) == 10\n    # Test coordinate scaling\n    coords = np.random.randn(10, 2)\n    scaled = scale_coordinates(coords)\n    assert np.all(scaled >= -1) and np.all(scaled <= 1)\n    # Test marker size calculation",
        "detail": "tests.test_visualization",
        "documentation": {}
    },
    {
        "label": "embeddings",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def embeddings():\n    \"\"\"Create a WordEmbeddings instance for testing.\"\"\"\n    return WordEmbeddings()\ndef test_initialization():\n    \"\"\"Test basic initialization with default model.\"\"\"\n    we = WordEmbeddings()\n    assert we.model_name == WordEmbeddings.DEFAULT_MODEL\n    assert we.cache_size == 1024\n    assert isinstance(we.embeddings, dict)\ndef test_model_fallback():",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_initialization",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_initialization():\n    \"\"\"Test basic initialization with default model.\"\"\"\n    we = WordEmbeddings()\n    assert we.model_name == WordEmbeddings.DEFAULT_MODEL\n    assert we.cache_size == 1024\n    assert isinstance(we.embeddings, dict)\ndef test_model_fallback():\n    \"\"\"Test fallback to backup model with invalid model name.\"\"\"\n    we = WordEmbeddings(model_name=\"invalid_model_name\")\n    assert we.model_name == WordEmbeddings.BACKUP_MODEL",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_model_fallback",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_model_fallback():\n    \"\"\"Test fallback to backup model with invalid model name.\"\"\"\n    we = WordEmbeddings(model_name=\"invalid_model_name\")\n    assert we.model_name == WordEmbeddings.BACKUP_MODEL\ndef test_embedding_generation(embeddings):\n    \"\"\"Test embedding generation for single and multiple terms.\"\"\"\n    # Single term\n    term = \"test\"\n    embedding = embeddings.get_embedding(term)\n    assert isinstance(embedding, np.ndarray)",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_embedding_generation",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_embedding_generation(embeddings):\n    \"\"\"Test embedding generation for single and multiple terms.\"\"\"\n    # Single term\n    term = \"test\"\n    embedding = embeddings.get_embedding(term)\n    assert isinstance(embedding, np.ndarray)\n    assert embedding.shape == (embeddings.get_embedding_dim(),)\n    # Multiple terms\n    terms = [\"test\", \"example\", \"word\"]\n    batch_embeddings = embeddings.get_embeddings(terms)",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_embedding_caching",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_embedding_caching(embeddings):\n    \"\"\"Test that embeddings are properly cached.\"\"\"\n    term = \"cache_test\"\n    # First call should compute embedding\n    first_embedding = embeddings.get_embedding(term)\n    # Second call should return cached value\n    second_embedding = embeddings.get_embedding(term)\n    assert np.array_equal(first_embedding, second_embedding)\n    assert term in embeddings.embeddings\ndef test_similar_terms(embeddings):",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_similar_terms",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_similar_terms(embeddings):\n    \"\"\"Test finding similar terms.\"\"\"\n    # Load some test terms\n    test_terms = [\"king\", \"queen\", \"prince\", \"princess\", \"castle\"]\n    embeddings.load_terms(test_terms)\n    similar = embeddings.find_similar_terms(\"king\", n=2)\n    assert isinstance(similar, list)\n    assert len(similar) == 2\n    assert all(t in test_terms for t in similar)\n    assert \"king\" not in similar  # Should not include the query term",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_numerological_value",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_numerological_value(embeddings):\n    \"\"\"Test numerological value calculation.\"\"\"\n    # Test basic calculation\n    assert embeddings.calculate_numerological_value(\"test\") <= 21\n    assert embeddings.calculate_numerological_value(\"\") == 0\n    # Test reduction to Tarot range\n    value = embeddings.calculate_numerological_value(\"pneumonoultramicroscopicsilicovolcanoconiosis\")\n    assert 0 <= value <= 21\ndef test_term_info(embeddings):\n    \"\"\"Test comprehensive term information retrieval.\"\"\"",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_term_info",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_term_info(embeddings):\n    \"\"\"Test comprehensive term information retrieval.\"\"\"\n    info = embeddings.get_term_info(\"testing\")\n    assert isinstance(info, dict)\n    assert \"embedding\" in info\n    assert \"numerological_value\" in info\n    assert \"length\" in info\n    assert info[\"length\"] == 7\ndef test_error_handling(embeddings):\n    \"\"\"Test error handling for various edge cases.\"\"\"",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_error_handling",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_error_handling(embeddings):\n    \"\"\"Test error handling for various edge cases.\"\"\"\n    # Empty string\n    embedding = embeddings.get_embedding(\"\")\n    assert isinstance(embedding, np.ndarray)\n    assert not np.any(embedding)  # Should be zero vector\n    # Very long input\n    long_text = \"a\" * 1000\n    embedding = embeddings.get_embedding(long_text)\n    assert isinstance(embedding, np.ndarray)",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_batch_processing",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_batch_processing(embeddings):\n    \"\"\"Test batch processing efficiency.\"\"\"\n    # Generate a large batch of terms\n    terms = [f\"term_{i}\" for i in range(100)]\n    # Process in batch\n    batch_results = embeddings.get_embeddings(terms)\n    assert len(batch_results) == len(terms)\n    assert all(isinstance(e, np.ndarray) for e in batch_results.values())\n    # Verify dimensions\n    dim = embeddings.get_embedding_dim()",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_word_embeddings_initialization",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_word_embeddings_initialization():\n    \"\"\"Test that WordEmbeddings initializes with default model.\"\"\"\n    embeddings = WordEmbeddings()\n    assert embeddings.model is not None\n    assert isinstance(embeddings.model, SentenceTransformer)\ndef test_word_embeddings_fallback():\n    \"\"\"Test that WordEmbeddings falls back to backup model.\"\"\"\n    embeddings = WordEmbeddings(model_name=\"invalid_model_name\")\n    assert embeddings.model is not None\n    assert isinstance(embeddings.model, SentenceTransformer)",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_word_embeddings_fallback",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_word_embeddings_fallback():\n    \"\"\"Test that WordEmbeddings falls back to backup model.\"\"\"\n    embeddings = WordEmbeddings(model_name=\"invalid_model_name\")\n    assert embeddings.model is not None\n    assert isinstance(embeddings.model, SentenceTransformer)\ndef test_embedding_generation():\n    \"\"\"Test that embeddings are generated correctly.\"\"\"\n    embeddings = WordEmbeddings()\n    terms = [\"test\", \"example\", \"word\"]\n    embeddings.load_terms(terms)",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_embedding_generation",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_embedding_generation():\n    \"\"\"Test that embeddings are generated correctly.\"\"\"\n    embeddings = WordEmbeddings()\n    terms = [\"test\", \"example\", \"word\"]\n    embeddings.load_terms(terms)\n    # Test single term embedding\n    emb = embeddings.get_embedding(\"test\")\n    assert isinstance(emb, np.ndarray)\n    assert len(emb.shape) == 1\n    assert emb.shape[0] == embeddings.get_embedding_dim()",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_similarity_search",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_similarity_search():\n    \"\"\"Test finding similar terms.\"\"\"\n    embeddings = WordEmbeddings()\n    terms = [\"king\", \"queen\", \"prince\", \"princess\", \"duke\", \"duchess\"]\n    embeddings.load_terms(terms)\n    similar = embeddings.find_similar_terms(\"king\", n=2)\n    assert len(similar) == 2\n    assert \"king\" not in similar  # Should not include the query term\n    assert all(isinstance(term, str) for term in similar)\ndef test_numerological_values():",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "test_numerological_values",
        "kind": 2,
        "importPath": "tests.test_word_embeddings",
        "description": "tests.test_word_embeddings",
        "peekOfCode": "def test_numerological_values():\n    \"\"\"Test numerological value calculation.\"\"\"\n    embeddings = WordEmbeddings()\n    value = embeddings.calculate_numerological_value(\"test\")\n    assert isinstance(value, int)\n    assert 0 <= value <= 21  # For Tarot-based numerology",
        "detail": "tests.test_word_embeddings",
        "documentation": {}
    },
    {
        "label": "CodeChangeHandler",
        "kind": 6,
        "importPath": "dev_watch",
        "description": "dev_watch",
        "peekOfCode": "class CodeChangeHandler(FileSystemEventHandler):\n    \"\"\"Handle file system change events.\"\"\"\n    def __init__(self):\n        self.last_run = 0\n        self.debounce_seconds = 2.0  # Minimum seconds between runs\n    def on_modified(self, event):\n        if event.is_directory:\n            return\n        # Only process Python files\n        if not event.src_path.endswith('.py'):",
        "detail": "dev_watch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "dev_watch",
        "description": "dev_watch",
        "peekOfCode": "def main():\n    \"\"\"Run the development watch script.\"\"\"\n    # Create an observer and event handler\n    observer = Observer()\n    handler = CodeChangeHandler()\n    # Watch both src and tests directories\n    paths_to_watch = [\"src\", \"tests\"]\n    for path in paths_to_watch:\n        observer.schedule(handler, path, recursive=True)\n    # Start the observer",
        "detail": "dev_watch",
        "documentation": {}
    }
]